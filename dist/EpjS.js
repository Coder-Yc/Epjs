/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Epjs"] = factory();
	else
		root["Epjs"] = factory();
})(global, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar parse = (__webpack_require__(/*! @babel/parser */ \"./node_modules/@babel/parser/lib/index.js\").parse);\ndebugger;\nvar code = \"console.log(\\\"hello, world\\\")\";\nvar escode = parse(code, {\n    sourceType: 'module'\n});\nconsole.log(escode);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMuanMiLCJtYXBwaW5ncyI6IjtBQUFRLFNBQUssR0FBSyw2RkFBTCxDQUE2QjtBQUMxQyxRQUFRO0FBQ1IsSUFBTSxJQUFJLEdBQUcsK0JBQTZCO0FBQzFDLElBQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxJQUFJLEVBQUU7SUFDekIsVUFBVSxFQUFFLFFBQVE7Q0FDckIsQ0FBQztBQUNGLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vRXBqcy8uL3NyYy9pbmRleC50cz9mZmI0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgcGFyc2UgfSA9IHJlcXVpcmUoJ0BiYWJlbC9wYXJzZXInKVxuZGVidWdnZXJcbmNvbnN0IGNvZGUgPSBgY29uc29sZS5sb2coXCJoZWxsbywgd29ybGRcIilgXG5jb25zdCBlc2NvZGUgPSBwYXJzZShjb2RlLCB7XG4gIHNvdXJjZVR5cGU6ICdtb2R1bGUnXG59KVxuY29uc29sZS5sb2coZXNjb2RlKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ }),

/***/ "./node_modules/@babel/parser/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@babel/parser/lib/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nclass Position {\n  constructor(line, col, index) {\n    this.line = void 0;\n    this.column = void 0;\n    this.index = void 0;\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n\n}\nfunction createPositionWithColumnOffset(position, columnOffset) {\n  const {\n    line,\n    column,\n    index\n  } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\n\nvar ParseErrorCode = {\n  SyntaxError: \"BABEL_PARSER_SYNTAX_ERROR\",\n  SourceTypeModuleError: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n};\n\nconst reflect = (keys, last = keys.length - 1) => ({\n  get() {\n    return keys.reduce((object, key) => object[key], this);\n  },\n\n  set(value) {\n    keys.reduce((item, key, i) => i === last ? item[key] = value : item[key], this);\n  }\n\n});\n\nconst instantiate = (constructor, properties, descriptors) => Object.keys(descriptors).map(key => [key, descriptors[key]]).filter(([, descriptor]) => !!descriptor).map(([key, descriptor]) => [key, typeof descriptor === \"function\" ? {\n  value: descriptor,\n  enumerable: false\n} : typeof descriptor.reflect === \"string\" ? Object.assign({}, descriptor, reflect(descriptor.reflect.split(\".\"))) : descriptor]).reduce((instance, [key, descriptor]) => Object.defineProperty(instance, key, Object.assign({\n  configurable: true\n}, descriptor)), Object.assign(new constructor(), properties));\n\nvar ModuleErrors = {\n  ImportMetaOutsideModule: {\n    message: `import.meta may appear only with 'sourceType: \"module\"'`,\n    code: ParseErrorCode.SourceTypeModuleError\n  },\n  ImportOutsideModule: {\n    message: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n    code: ParseErrorCode.SourceTypeModuleError\n  }\n};\n\nconst NodeDescriptions = {\n  ArrayPattern: \"array destructuring pattern\",\n  AssignmentExpression: \"assignment expression\",\n  AssignmentPattern: \"assignment expression\",\n  ArrowFunctionExpression: \"arrow function expression\",\n  ConditionalExpression: \"conditional expression\",\n  CatchClause: \"catch clause\",\n  ForOfStatement: \"for-of statement\",\n  ForInStatement: \"for-in statement\",\n  ForStatement: \"for-loop\",\n  FormalParameters: \"function parameter list\",\n  Identifier: \"identifier\",\n  ImportSpecifier: \"import specifier\",\n  ImportDefaultSpecifier: \"import default specifier\",\n  ImportNamespaceSpecifier: \"import namespace specifier\",\n  ObjectPattern: \"object destructuring pattern\",\n  ParenthesizedExpression: \"parenthesized expression\",\n  RestElement: \"rest element\",\n  UpdateExpression: {\n    true: \"prefix operation\",\n    false: \"postfix operation\"\n  },\n  VariableDeclarator: \"variable declaration\",\n  YieldExpression: \"yield expression\"\n};\n\nconst toNodeDescription = ({\n  type,\n  prefix\n}) => type === \"UpdateExpression\" ? NodeDescriptions.UpdateExpression[String(prefix)] : NodeDescriptions[type];\n\nvar StandardErrors = {\n  AccessorIsGenerator: ({\n    kind\n  }) => `A ${kind}ter cannot be a generator.`,\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods.\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block.\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function.\",\n  AwaitBindingIdentifierInStaticBlock: \"Can not use 'await' as identifier inside a static block.\",\n  AwaitExpressionFormalParameter: \"'await' is not allowed in async function parameters.\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncFunction: \"'await' is only allowed within async functions.\",\n  BadGetterArity: \"A 'get' accesor must not have any formal parameters.\",\n  BadSetterArity: \"A 'set' accesor must have exactly one formal parameter.\",\n  BadSetterRestParameter: \"A 'set' accesor function argument must not be a rest parameter.\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'.\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n  ConstructorIsAsync: \"Constructor can't be an async function.\",\n  ConstructorIsGenerator: \"Constructor can't be a generator.\",\n  DeclarationMissingInitializer: ({\n    kind\n  }) => `Missing initializer in ${kind} declaration.`,\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n  DeletePrivateField: \"Deleting a private field is not allowed.\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class.\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: ({\n    exportName\n  }) => `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`,\n  DuplicateProto: \"Redefinition of __proto__ property.\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n  ElementAfterRest: \"Rest element must be last element.\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n  ExportBindingIsString: ({\n    localName,\n    exportName\n  }) => `A string literal cannot be used as an exported binding without \\`from\\`.\\n- Did you mean \\`export { '${localName}' as '${exportName}' } from 'some-module'\\`?`,\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'.\",\n  ForInOfLoopInitializer: ({\n    type\n  }) => `'${type === \"ForInStatement\" ? \"for-in\" : \"for-of\"}' loop variable declaration may not have an initializer.`,\n  ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block.\",\n  IllegalBreakContinue: ({\n    type\n  }) => `Unsyntactic ${type === \"BreakStatement\" ? \"break\" : \"continue\"}.`,\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n  IllegalReturn: \"'return' outside of function.\",\n  ImportBindingIsString: ({\n    importName\n  }) => `A string literal cannot be used as an imported binding.\\n- Did you mean \\`import { \"${importName}\" as foo }\\`?`,\n  ImportCallArgumentTrailingComma: \"Trailing comma is disallowed inside import(...) arguments.\",\n  ImportCallArity: ({\n    maxArgumentCount\n  }) => `\\`import()\\` requires exactly ${maxArgumentCount === 1 ? \"one argument\" : \"one or two arguments\"}.`,\n  ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n  ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n  ImportJSONBindingNotDefault: \"A JSON module can only be imported with `default`.\",\n  IncompatibleRegExpUVFlags: \"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\",\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n  InvalidCodePoint: \"Code point out of bounds.\",\n  InvalidCoverInitializedName: \"Invalid shorthand property initializer.\",\n  InvalidDecimal: \"Invalid decimal.\",\n  InvalidDigit: ({\n    radix\n  }) => `Expected number in radix ${radix}.`,\n  InvalidEscapeSequence: \"Bad character escape sequence.\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n  InvalidEscapedReservedWord: ({\n    reservedWord\n  }) => `Escape sequence in keyword ${reservedWord}.`,\n  InvalidIdentifier: ({\n    identifierName\n  }) => `Invalid identifier ${identifierName}.`,\n  InvalidLhs: ({\n    ancestor\n  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsBinding: ({\n    ancestor\n  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidNumber: \"Invalid number.\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'.\",\n  InvalidOrUnexpectedToken: ({\n    unexpected\n  }) => `Unexpected character '${unexpected}'.`,\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n  InvalidPrivateFieldResolution: ({\n    identifierName\n  }) => `Private name #${identifierName} is not defined.`,\n  InvalidPropertyBindingPattern: \"Binding member expression.\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions.\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n  LabelRedeclaration: ({\n    labelName\n  }) => `Label '${labelName}' is already declared.`,\n  LetInLexicalBinding: \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag.\",\n  MissingClassName: \"A class name is required.\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon.\",\n  MissingPlugin: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingOneOfPlugins: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`.\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values.\",\n  ModuleAttributesWithDuplicateKeys: ({\n    key\n  }) => `Duplicate key \"${key}\" is not allowed in module attributes.`,\n  ModuleExportNameHasLoneSurrogate: ({\n    surrogateCharCode\n  }) => `An export name cannot include a lone surrogate, found '\\\\u${surrogateCharCode.toString(16)}'.`,\n  ModuleExportUndefined: ({\n    localName\n  }) => `Export '${localName}' is not defined.`,\n  MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n  NewlineAfterThrow: \"Illegal newline after throw.\",\n  NoCatchOrFinally: \"Missing catch or finally clause.\",\n  NumberIdentifier: \"Identifier directly after number.\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n  ObsoleteAwaitStar: \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"Constructors in/after an Optional Chain are not allowed.\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain.\",\n  OverrideOnConstructor: \"'override' modifier cannot appear on a constructor declaration.\",\n  ParamDupe: \"Argument name clash.\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n  PatternHasMethod: \"Object pattern can't contain methods.\",\n  PrivateInExpectedIn: ({\n    identifierName\n  }) => `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`,\n  PrivateNameRedeclaration: ({\n    identifierName\n  }) => `Duplicate private name #${identifierName}.`,\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n  StaticPrototype: \"Classes may not have static property named prototype.\",\n  SuperNotAllowed: \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super.\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level.\",\n  UnexpectedKeyword: ({\n    keyword\n  }) => `Unexpected keyword '${keyword}'.`,\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration.\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context.\",\n  UnexpectedNewTarget: \"`new.target` can only be used in functions or class properties.\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits.\",\n  UnexpectedPrivateField: \"Unexpected private name.\",\n  UnexpectedReservedWord: ({\n    reservedWord\n  }) => `Unexpected reserved word '${reservedWord}'.`,\n  UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n  UnexpectedToken: ({\n    expected,\n    unexpected\n  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : \"\"}${expected ? `, expected \"${expected}\"` : \"\"}`,\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration.\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"`import` can only be used in `import()` or `import.meta`.\",\n  UnsupportedMetaProperty: ({\n    target,\n    onlyValidPropertyName\n  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters.\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties.\",\n  UnsupportedSuper: \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n  UnterminatedComment: \"Unterminated comment.\",\n  UnterminatedRegExp: \"Unterminated regular expression.\",\n  UnterminatedString: \"Unterminated string constant.\",\n  UnterminatedTemplate: \"Unterminated template.\",\n  VarRedeclaration: ({\n    identifierName\n  }) => `Identifier '${identifierName}' has already been declared.`,\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator.\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0.\"\n};\n\nvar StrictModeErrors = {\n  StrictDelete: \"Deleting local variable in strict mode.\",\n  StrictEvalArguments: ({\n    referenceName\n  }) => `Assigning to '${referenceName}' in strict mode.`,\n  StrictEvalArgumentsBinding: ({\n    bindingName\n  }) => `Binding '${bindingName}' in strict mode.`,\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block.\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'.\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n  StrictWith: \"'with' in strict mode.\"\n};\n\nconst UnparenthesizedPipeBodyDescriptions = new Set([\"ArrowFunctionExpression\", \"AssignmentExpression\", \"ConditionalExpression\", \"YieldExpression\"]);\nvar PipelineOperatorErrors = {\n  PipeBodyIsTighter: \"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PipeTopicUnbound: \"Topic reference is unbound; it must be inside a pipe body.\",\n  PipeTopicUnconfiguredToken: ({\n    token\n  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"${token}\" }.`,\n  PipeTopicUnused: \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n  PipeUnparenthesizedBody: ({\n    type\n  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n    type\n  })}; please wrap it in parentheses.`,\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression.\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression.\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference.\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding.\",\n  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.'\n};\n\nconst _excluded$1 = [\"toMessage\"],\n      _excluded2$1 = [\"message\"];\n\nfunction toParseErrorConstructor(_ref) {\n  let {\n    toMessage\n  } = _ref,\n      properties = _objectWithoutPropertiesLoose(_ref, _excluded$1);\n\n  return function constructor({\n    loc,\n    details\n  }) {\n    return instantiate(SyntaxError, Object.assign({}, properties, {\n      loc\n    }), {\n      clone(overrides = {}) {\n        const loc = overrides.loc || {};\n        return constructor({\n          loc: new Position(\"line\" in loc ? loc.line : this.loc.line, \"column\" in loc ? loc.column : this.loc.column, \"index\" in loc ? loc.index : this.loc.index),\n          details: Object.assign({}, this.details, overrides.details)\n        });\n      },\n\n      details: {\n        value: details,\n        enumerable: false\n      },\n      message: {\n        get() {\n          return `${toMessage(this.details)} (${this.loc.line}:${this.loc.column})`;\n        },\n\n        set(value) {\n          Object.defineProperty(this, \"message\", {\n            value\n          });\n        }\n\n      },\n      pos: {\n        reflect: \"loc.index\",\n        enumerable: true\n      },\n      missingPlugin: \"missingPlugin\" in details && {\n        reflect: \"details.missingPlugin\",\n        enumerable: true\n      }\n    });\n  };\n}\n\nfunction ParseErrorEnum(argument, syntaxPlugin) {\n  if (Array.isArray(argument)) {\n    return parseErrorTemplates => ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n\n  const ParseErrorConstructors = {};\n\n  for (const reasonCode of Object.keys(argument)) {\n    const template = argument[reasonCode];\n\n    const _ref2 = typeof template === \"string\" ? {\n      message: () => template\n    } : typeof template === \"function\" ? {\n      message: template\n    } : template,\n          {\n      message\n    } = _ref2,\n          rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);\n\n    const toMessage = typeof message === \"string\" ? () => message : message;\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({\n      code: ParseErrorCode.SyntaxError,\n      reasonCode,\n      toMessage\n    }, syntaxPlugin ? {\n      syntaxPlugin\n    } : {}, rest));\n  }\n\n  return ParseErrorConstructors;\n}\nconst Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));\n\nconst {\n  defineProperty\n} = Object;\n\nconst toUnenumerable = (object, key) => defineProperty(object, key, {\n  enumerable: false,\n  value: object[key]\n});\n\nfunction toESTreeLocation(node) {\n  node.loc.start && toUnenumerable(node.loc.start, \"index\");\n  node.loc.end && toUnenumerable(node.loc.end, \"index\");\n  return node;\n}\n\nvar estree = (superClass => class ESTreeParserMixin extends superClass {\n  parse() {\n    const file = toESTreeLocation(super.parse());\n\n    if (this.options.tokens) {\n      file.tokens = file.tokens.map(toESTreeLocation);\n    }\n\n    return file;\n  }\n\n  parseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {}\n\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n\n  parseBigIntLiteral(value) {\n    let bigInt;\n\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n\n  parseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n\n  parseStringLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n\n  parseNumericLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n\n  parseNullLiteral() {\n    return this.estreeParseLiteral(null);\n  }\n\n  parseBooleanLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n\n  directiveToStmt(directive) {\n    const directiveLiteral = directive.value;\n    const stmt = this.startNodeAt(directive.start, directive.loc.start);\n    const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);\n    expression.value = directiveLiteral.extra.expressionValue;\n    expression.raw = directiveLiteral.extra.raw;\n    stmt.expression = this.finishNodeAt(expression, \"Literal\", directiveLiteral.loc.end);\n    stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n    return this.finishNodeAt(stmt, \"ExpressionStatement\", directive.loc.end);\n  }\n\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\n  }\n\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n\n    classBody.body.push(method);\n  }\n\n  parsePrivateName() {\n    const node = super.parsePrivateName();\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return node;\n      }\n    }\n    return this.convertPrivateNameToPrivateIdentifier(node);\n  }\n\n  convertPrivateNameToPrivateIdentifier(node) {\n    const name = super.getPrivateNameSV(node);\n    node = node;\n    delete node.id;\n    node.name = name;\n    node.type = \"PrivateIdentifier\";\n    return node;\n  }\n\n  isPrivateName(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.isPrivateName(node);\n      }\n    }\n    return node.type === \"PrivateIdentifier\";\n  }\n\n  getPrivateNameSV(node) {\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return super.getPrivateNameSV(node);\n      }\n    }\n    return node.name;\n  }\n\n  parseLiteral(value, type) {\n    const node = super.parseLiteral(value, type);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n\n    if (type === \"ClassPrivateMethod\") {\n      node.computed = false;\n    }\n\n    return this.finishNode(node, \"MethodDefinition\");\n  }\n\n  parseClassProperty(...args) {\n    const propertyNode = super.parseClassProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    return propertyNode;\n  }\n\n  parseClassPrivateProperty(...args) {\n    const propertyNode = super.parseClassPrivateProperty(...args);\n    {\n      if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = \"PropertyDefinition\";\n    propertyNode.computed = false;\n    return propertyNode;\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\n\n    if (node) {\n      node.type = \"Property\";\n\n      if (node.kind === \"method\") {\n        node.kind = \"init\";\n      }\n\n      node.shorthand = false;\n    }\n\n    return node;\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n\n    return node;\n  }\n\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return type === \"Property\" ? \"value\" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n\n  isAssignable(node, isBinding) {\n    if (node != null && this.isObjectProperty(node)) {\n      return this.isAssignable(node.value, isBinding);\n    }\n\n    return super.isAssignable(node, isBinding);\n  }\n\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      const {\n        key,\n        value\n      } = node;\n\n      if (this.isPrivateName(key)) {\n        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n      }\n\n      this.toAssignable(value, isLHS);\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      this.raise(Errors.PatternHasAccessor, {\n        at: prop.key\n      });\n    } else if (prop.method) {\n      this.raise(Errors.PatternHasMethod, {\n        at: prop.key\n      });\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n    }\n  }\n\n  finishCallExpression(unfinished, optional) {\n    const node = super.finishCallExpression(unfinished, optional);\n\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n\n      if (this.hasPlugin(\"importAssertions\")) {\n        var _node$arguments$;\n\n        node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;\n      }\n\n      delete node.arguments;\n      delete node.callee;\n    }\n\n    return node;\n  }\n\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n\n    super.toReferencedArguments(node);\n  }\n\n  parseExport(unfinished) {\n    const node = super.parseExport(unfinished);\n\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n\n        break;\n    }\n\n    return node;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    const node = super.parseSubscript(base, startPos, startLoc, noCalls, state);\n\n    if (state.optionalChainMember) {\n      if (node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\") {\n        node.type = node.type.substring(8);\n      }\n\n      if (state.stop) {\n        const chain = this.startNodeAtNode(node);\n        chain.expression = node;\n        return this.finishNode(chain, \"ChainExpression\");\n      }\n    } else if (node.type === \"MemberExpression\" || node.type === \"CallExpression\") {\n      node.optional = false;\n    }\n\n    return node;\n  }\n\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n\n    return super.hasPropertyAsPrivateName(node);\n  }\n\n  isOptionalChain(node) {\n    return node.type === \"ChainExpression\";\n  }\n\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n\n  isObjectMethod(node) {\n    return node.method || node.kind === \"get\" || node.kind === \"set\";\n  }\n\n  finishNodeAt(node, type, endLoc) {\n    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n  }\n\n  resetStartLocation(node, start, startLoc) {\n    super.resetStartLocation(node, start, startLoc);\n    toESTreeLocation(node);\n  }\n\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    super.resetEndLocation(node, endLoc);\n    toESTreeLocation(node);\n  }\n\n});\n\nclass TokContext {\n  constructor(token, preserveSpace) {\n    this.token = void 0;\n    this.preserveSpace = void 0;\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n\n}\nconst types = {\n  brace: new TokContext(\"{\"),\n  j_oTag: new TokContext(\"<tag\"),\n  j_cTag: new TokContext(\"</tag\"),\n  j_expr: new TokContext(\"<tag>...</tag>\", true)\n};\n{\n  types.template = new TokContext(\"`\", true);\n}\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass ExportedTokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    {\n      this.updateContext = null;\n    }\n  }\n\n}\nconst keywords$1 = new Map();\n\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords$1.set(name, token);\n  return token;\n}\n\nfunction createBinop(name, binop) {\n  return createToken(name, {\n    beforeExpr,\n    binop\n  });\n}\n\nlet tokenTypeCounter = -1;\nconst tokenTypes = [];\nconst tokenLabels = [];\nconst tokenBinops = [];\nconst tokenBeforeExprs = [];\nconst tokenStartsExprs = [];\nconst tokenPrefixes = [];\n\nfunction createToken(name, options = {}) {\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\n\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n  return tokenTypeCounter;\n}\n\nfunction createKeywordLike(name, options = {}) {\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\n\n  ++tokenTypeCounter;\n  keywords$1.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n  return tokenTypeCounter;\n}\n\nconst tt = {\n  bracketL: createToken(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: createToken(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: createToken(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: createToken(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: createToken(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: createToken(\"}\"),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", {\n    beforeExpr\n  }),\n  semi: createToken(\";\", {\n    beforeExpr\n  }),\n  colon: createToken(\":\", {\n    beforeExpr\n  }),\n  doubleColon: createToken(\"::\", {\n    beforeExpr\n  }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", {\n    beforeExpr\n  }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", {\n    beforeExpr\n  }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", {\n    beforeExpr\n  }),\n  backQuote: createToken(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: createToken(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  templateTail: createToken(\"...`\", {\n    startsExpr\n  }),\n  templateNonTail: createToken(\"...${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: createToken(\"#!...\"),\n  eq: createToken(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  slashAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  xorAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  moduloAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: createToken(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: createToken(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: createToken(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  doubleCaret: createToken(\"^^\", {\n    startsExpr\n  }),\n  doubleAt: createToken(\"@@\", {\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  bitShiftL: createBinop(\"<</>>/>>>\", 8),\n  bitShiftR: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: createToken(\"%\", {\n    binop: 10,\n    startsExpr\n  }),\n  star: createToken(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _as: createKeywordLike(\"as\", {\n    startsExpr\n  }),\n  _assert: createKeywordLike(\"assert\", {\n    startsExpr\n  }),\n  _async: createKeywordLike(\"async\", {\n    startsExpr\n  }),\n  _await: createKeywordLike(\"await\", {\n    startsExpr\n  }),\n  _from: createKeywordLike(\"from\", {\n    startsExpr\n  }),\n  _get: createKeywordLike(\"get\", {\n    startsExpr\n  }),\n  _let: createKeywordLike(\"let\", {\n    startsExpr\n  }),\n  _meta: createKeywordLike(\"meta\", {\n    startsExpr\n  }),\n  _of: createKeywordLike(\"of\", {\n    startsExpr\n  }),\n  _sent: createKeywordLike(\"sent\", {\n    startsExpr\n  }),\n  _set: createKeywordLike(\"set\", {\n    startsExpr\n  }),\n  _static: createKeywordLike(\"static\", {\n    startsExpr\n  }),\n  _yield: createKeywordLike(\"yield\", {\n    startsExpr\n  }),\n  _asserts: createKeywordLike(\"asserts\", {\n    startsExpr\n  }),\n  _checks: createKeywordLike(\"checks\", {\n    startsExpr\n  }),\n  _exports: createKeywordLike(\"exports\", {\n    startsExpr\n  }),\n  _global: createKeywordLike(\"global\", {\n    startsExpr\n  }),\n  _implements: createKeywordLike(\"implements\", {\n    startsExpr\n  }),\n  _intrinsic: createKeywordLike(\"intrinsic\", {\n    startsExpr\n  }),\n  _infer: createKeywordLike(\"infer\", {\n    startsExpr\n  }),\n  _is: createKeywordLike(\"is\", {\n    startsExpr\n  }),\n  _mixins: createKeywordLike(\"mixins\", {\n    startsExpr\n  }),\n  _proto: createKeywordLike(\"proto\", {\n    startsExpr\n  }),\n  _require: createKeywordLike(\"require\", {\n    startsExpr\n  }),\n  _keyof: createKeywordLike(\"keyof\", {\n    startsExpr\n  }),\n  _readonly: createKeywordLike(\"readonly\", {\n    startsExpr\n  }),\n  _unique: createKeywordLike(\"unique\", {\n    startsExpr\n  }),\n  _abstract: createKeywordLike(\"abstract\", {\n    startsExpr\n  }),\n  _declare: createKeywordLike(\"declare\", {\n    startsExpr\n  }),\n  _enum: createKeywordLike(\"enum\", {\n    startsExpr\n  }),\n  _module: createKeywordLike(\"module\", {\n    startsExpr\n  }),\n  _namespace: createKeywordLike(\"namespace\", {\n    startsExpr\n  }),\n  _interface: createKeywordLike(\"interface\", {\n    startsExpr\n  }),\n  _type: createKeywordLike(\"type\", {\n    startsExpr\n  }),\n  _opaque: createKeywordLike(\"opaque\", {\n    startsExpr\n  }),\n  name: createToken(\"name\", {\n    startsExpr\n  }),\n  string: createToken(\"string\", {\n    startsExpr\n  }),\n  num: createToken(\"num\", {\n    startsExpr\n  }),\n  bigint: createToken(\"bigint\", {\n    startsExpr\n  }),\n  decimal: createToken(\"decimal\", {\n    startsExpr\n  }),\n  regexp: createToken(\"regexp\", {\n    startsExpr\n  }),\n  privateName: createToken(\"#name\", {\n    startsExpr\n  }),\n  eof: createToken(\"eof\"),\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", {\n    beforeExpr: true\n  }),\n  jsxTagStart: createToken(\"jsxTagStart\", {\n    startsExpr: true\n  }),\n  jsxTagEnd: createToken(\"jsxTagEnd\"),\n  placeholder: createToken(\"%%\", {\n    startsExpr: true\n  })\n};\nfunction tokenIsIdentifier(token) {\n  return token >= 93 && token <= 128;\n}\nfunction tokenKeywordOrIdentifierIsKeyword(token) {\n  return token <= 92;\n}\nfunction tokenIsKeywordOrIdentifier(token) {\n  return token >= 58 && token <= 128;\n}\nfunction tokenIsLiteralPropertyName(token) {\n  return token >= 58 && token <= 132;\n}\nfunction tokenComesBeforeExpression(token) {\n  return tokenBeforeExprs[token];\n}\nfunction tokenCanStartExpression(token) {\n  return tokenStartsExprs[token];\n}\nfunction tokenIsAssignment(token) {\n  return token >= 29 && token <= 33;\n}\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\n  return token >= 125 && token <= 127;\n}\nfunction tokenIsLoop(token) {\n  return token >= 90 && token <= 92;\n}\nfunction tokenIsKeyword(token) {\n  return token >= 58 && token <= 92;\n}\nfunction tokenIsOperator(token) {\n  return token >= 39 && token <= 59;\n}\nfunction tokenIsPostfix(token) {\n  return token === 34;\n}\nfunction tokenIsPrefix(token) {\n  return tokenPrefixes[token];\n}\nfunction tokenIsTSTypeOperator(token) {\n  return token >= 117 && token <= 119;\n}\nfunction tokenIsTSDeclarationStart(token) {\n  return token >= 120 && token <= 126;\n}\nfunction tokenLabelName(token) {\n  return tokenLabels[token];\n}\nfunction tokenOperatorPrecedence(token) {\n  return tokenBinops[token];\n}\nfunction tokenIsRightAssociative(token) {\n  return token === 57;\n}\nfunction tokenIsTemplate(token) {\n  return token >= 24 && token <= 25;\n}\nfunction getExportedToken(token) {\n  return tokenTypes[token];\n}\n{\n  tokenTypes[8].updateContext = context => {\n    context.pop();\n  };\n\n  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {\n    context.push(types.brace);\n  };\n\n  tokenTypes[22].updateContext = context => {\n    if (context[context.length - 1] === types.template) {\n      context.pop();\n    } else {\n      context.push(types.template);\n    }\n  };\n\n  tokenTypes[138].updateContext = context => {\n    context.push(types.j_expr, types.j_oTag);\n  };\n}\n\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ca\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7d9\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0898-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n\n  return false;\n}\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\n\nfunction isIteratorStart(current, next, next2) {\n  return current === 64 && next === 64 && isIdentifierStart(next2);\n}\nconst reservedWordLikeSet = new Set([\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"eval\", \"arguments\", \"enum\", \"await\"]);\nfunction canBeReservedWord(word) {\n  return reservedWordLikeSet.has(word);\n}\n\nconst SCOPE_OTHER = 0b000000000,\n      SCOPE_PROGRAM = 0b000000001,\n      SCOPE_FUNCTION = 0b000000010,\n      SCOPE_ARROW = 0b000000100,\n      SCOPE_SIMPLE_CATCH = 0b000001000,\n      SCOPE_SUPER = 0b000010000,\n      SCOPE_DIRECT_SUPER = 0b000100000,\n      SCOPE_CLASS = 0b001000000,\n      SCOPE_STATIC_BLOCK = 0b010000000,\n      SCOPE_TS_MODULE = 0b100000000,\n      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;\nconst BIND_KIND_VALUE = 0b000000000001,\n      BIND_KIND_TYPE = 0b000000000010,\n      BIND_SCOPE_VAR = 0b000000000100,\n      BIND_SCOPE_LEXICAL = 0b000000001000,\n      BIND_SCOPE_FUNCTION = 0b000000010000,\n      BIND_FLAGS_NONE = 0b000001000000,\n      BIND_FLAGS_CLASS = 0b000010000000,\n      BIND_FLAGS_TS_ENUM = 0b000100000000,\n      BIND_FLAGS_TS_CONST_ENUM = 0b001000000000,\n      BIND_FLAGS_TS_EXPORT_ONLY = 0b010000000000,\n      BIND_FLAGS_FLOW_DECLARE_FN = 0b100000000000;\nconst BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,\n      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,\n      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,\n      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,\n      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,\n      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,\n      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,\n      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;\nconst CLASS_ELEMENT_FLAG_STATIC = 0b100,\n      CLASS_ELEMENT_KIND_GETTER = 0b010,\n      CLASS_ELEMENT_KIND_SETTER = 0b001,\n      CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\nconst CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,\n      CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,\n      CLASS_ELEMENT_OTHER = 0;\n\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n\n  hasPlugin(pluginConfig) {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n\n      const actualOptions = this.plugins.get(pluginName);\n\n      for (const key of Object.keys(pluginOptions)) {\n        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  getPluginOption(plugin, name) {\n    var _this$plugins$get;\n\n    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];\n  }\n\n}\n\nfunction setTrailingComments(node, comments) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\n\nfunction setLeadingComments(node, comments) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\n\nfunction setInnerComments(node, comments) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\n\nfunction adjustInnerComments(node, elements, commentWS) {\n  let lastElement = null;\n  let i = elements.length;\n\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\n\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.comments.push(comment);\n  }\n\n  processComment(node) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n\n    const {\n      start: nodeStart\n    } = node;\n\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n\n      if (commentEnd > nodeStart) {\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n\n        break;\n      }\n    }\n  }\n\n  finalizeComment(commentWS) {\n    const {\n      comments\n    } = commentWS;\n\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      const {\n        containingNode: node,\n        start: commentStart\n      } = commentWS;\n\n      if (this.input.charCodeAt(commentStart - 1) === 44) {\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n\n          default:\n            {\n              setInnerComments(node, comments);\n            }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n\n  finalizeRemainingComments() {\n    const {\n      commentStack\n    } = this.state;\n\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n\n    this.state.commentStack = [];\n  }\n\n  resetPreviousNodeTrailingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n\n  takeSurroundingComments(node, start, end) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n\n}\n\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/y;\nconst skipWhiteSpaceToLineBreak = new RegExp(\"(?=(\" + skipWhiteSpaceInLine.source + \"))\\\\1\" + /(?=[\\n\\r\\u2028\\u2029]|\\/\\*(?!.*?\\*\\/)|$)/.source, \"y\");\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass State {\n  constructor() {\n    this.strict = void 0;\n    this.curLine = void 0;\n    this.lineStart = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.maybeInArrowParameters = false;\n    this.inType = false;\n    this.noAnonFunctionType = false;\n    this.hasFlowComment = false;\n    this.isAmbientContext = false;\n    this.inAbstractClass = false;\n    this.inDisallowConditionalTypesContext = false;\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.soloAwait = false;\n    this.inFSharpPipelineDirectBody = false;\n    this.labels = [];\n    this.decoratorStack = [[]];\n    this.comments = [];\n    this.commentStack = [];\n    this.pos = 0;\n    this.type = 135;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.lastTokStart = 0;\n    this.context = [types.brace];\n    this.canStartJSXElement = true;\n    this.containsEsc = false;\n    this.strictErrors = new Map();\n    this.tokensLength = 0;\n  }\n\n  init({\n    strictMode,\n    sourceType,\n    startLine,\n    startColumn\n  }) {\n    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === \"module\";\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);\n  }\n\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos);\n  }\n\n  clone(skipArrays) {\n    const state = new State();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      let val = this[key];\n\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      state[key] = val;\n    }\n\n    return state;\n  }\n\n}\n\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\n\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: ch => ch === 48 || ch === 49,\n  oct: ch => ch >= 48 && ch <= 55,\n  dec: ch => ch >= 48 && ch <= 57,\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = \"\";\n  let containsInvalid = false;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n\n    const ch = input.charCodeAt(pos);\n\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      let escaped;\n      ({\n        ch: escaped,\n        pos,\n        lineStart,\n        curLine\n      } = readEscapedChar(input, pos, lineStart, curLine, type === \"template\", errors));\n\n      if (escaped === null) {\n        containsInvalid = true;\n      } else {\n        out += escaped;\n      }\n\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n\n  return {\n    pos,\n    str: out,\n    containsInvalid,\n    lineStart,\n    curLine\n  };\n}\n\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === \"template\") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n\n  return ch === (type === \"double\" ? 34 : 39);\n}\n\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n\n  const res = ch => ({\n    pos,\n    ch,\n    lineStart,\n    curLine\n  });\n\n  const ch = input.charCodeAt(pos++);\n\n  switch (ch) {\n    case 110:\n      return res(\"\\n\");\n\n    case 114:\n      return res(\"\\r\");\n\n    case 120:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCharCode(code));\n      }\n\n    case 117:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCodePoint(code));\n      }\n\n    case 116:\n      return res(\"\\t\");\n\n    case 98:\n      return res(\"\\b\");\n\n    case 118:\n      return res(\"\\u000b\");\n\n    case 102:\n      return res(\"\\f\");\n\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n\n    case 10:\n      lineStart = pos;\n      ++curLine;\n\n    case 8232:\n    case 8233:\n      return res(\"\");\n\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = input.slice(startPos, pos + 2).match(/^[0-7]+/);\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n\n        if (octalStr !== \"0\" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n\n        return res(String.fromCharCode(octal));\n      }\n\n      return res(String.fromCharCode(ch));\n  }\n}\n\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors));\n\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n\n  return {\n    code: n,\n    pos\n  };\n}\n\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n\n    if (code === 95 && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n\n      if (!allowNumSeparator) {\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n\n      ++pos;\n      continue;\n    }\n\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } else if (code >= 65) {\n      val = code - 65 + 10;\n    } else if (_isDigit(code)) {\n      val = code - 48;\n    } else {\n      val = Infinity;\n    }\n\n    if (val >= radix) {\n      if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n\n    ++pos;\n    total = total * radix + val;\n  }\n\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code;\n\n  if (ch === 123) {\n    ++pos;\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf(\"}\", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n\n  return {\n    code,\n    pos\n  };\n}\n\nconst _excluded = [\"at\"],\n      _excluded2 = [\"at\"];\n\nfunction buildPosition(pos, lineStart, curLine) {\n  return new Position(curLine, pos - lineStart, pos);\n}\n\nconst VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n}\nclass Tokenizer extends CommentsParser {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.errorHandlers_readInt = {\n      invalidDigit: (pos, lineStart, curLine, radix) => {\n        if (!this.options.errorRecovery) return false;\n        this.raise(Errors.InvalidDigit, {\n          at: buildPosition(pos, lineStart, curLine),\n          radix\n        });\n        return true;\n      },\n      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),\n      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)\n    };\n    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {\n      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)\n    });\n    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: (pos, lineStart, curLine) => {\n        this.recordStrictModeErrors(Errors.StrictNumericEscape, {\n          at: buildPosition(pos, lineStart, curLine)\n        });\n      },\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedString, {\n          at: buildPosition(pos - 1, lineStart, curLine)\n        });\n      }\n    });\n    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedTemplate, {\n          at: buildPosition(pos, lineStart, curLine)\n        });\n      }\n    });\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  next() {\n    this.checkKeywordEscapes();\n\n    if (this.options.tokens) {\n      this.pushToken(new Token(this.state));\n    }\n\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  match(type) {\n    return this.state.type === type;\n  }\n\n  createLookaheadState(state) {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition\n    };\n  }\n\n  lookahead() {\n    const old = this.state;\n    this.state = this.createLookaheadState(old);\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  codePointAtPos(pos) {\n    let cp = this.input.charCodeAt(pos);\n\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n\n    return cp;\n  }\n\n  setStrict(strict) {\n    this.state.strict = strict;\n\n    if (strict) {\n      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, {\n        at\n      }));\n      this.state.strictErrors.clear();\n    }\n  }\n\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  nextToken() {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n\n    if (this.state.pos >= this.length) {\n      this.finishToken(135);\n      return;\n    }\n\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n\n  skipBlockComment() {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(\"*/\", start + 2);\n\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, {\n        at: this.state.curPosition()\n      });\n    }\n\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start + 2;\n\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n\n    if (this.isLookahead) return;\n    const comment = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start,\n      end: end + 2,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    if (this.isLookahead) return;\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n    const comment = {\n      type: \"CommentLine\",\n      value,\n      start,\n      end,\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  skipSpace() {\n    const spaceStart = this.state.pos;\n    const comments = [];\n\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              {\n                const comment = this.skipBlockComment();\n\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n\n                break;\n              }\n\n            case 47:\n              {\n                const comment = this.skipLineComment(2);\n\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n\n                break;\n              }\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (ch === 45 && !this.inModule) {\n            const pos = this.state.pos;\n\n            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\n              const comment = this.skipLineComment(3);\n\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (ch === 60 && !this.inModule) {\n            const pos = this.state.pos;\n\n            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\n              const comment = this.skipLineComment(4);\n\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n\n      }\n    }\n\n    if (comments.length > 0) {\n      const end = this.state.pos;\n      const commentWhitespace = {\n        start: spaceStart,\n        end,\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n\n  replaceToken(type) {\n    this.state.type = type;\n    this.updateContext();\n  }\n\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n\n    if (next >= 48 && next <= 57) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, {\n        at: this.state.curPosition()\n      });\n    }\n\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"hash\") {\n        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {\n          at: this.state.curPosition()\n        });\n      }\n\n      this.state.pos += 2;\n\n      if (next === 123) {\n        this.finishToken(7);\n      } else {\n        this.finishToken(1);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(134, this.readWord1(next));\n    } else if (next === 92) {\n      ++this.state.pos;\n      this.finishToken(134, this.readWord1());\n    } else {\n      this.finishOp(27, 1);\n    }\n  }\n\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(21);\n    } else {\n      ++this.state.pos;\n      this.finishToken(16);\n    }\n  }\n\n  readToken_slash() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(31, 2);\n    } else {\n      this.finishOp(56, 1);\n    }\n  }\n\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(28, value);\n    return true;\n  }\n\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? 55 : 54;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = 57;\n    }\n\n    if (next === 61 && !this.state.inType) {\n      width++;\n      type = code === 37 ? 33 : 30;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(code === 124 ? 41 : 42, 2);\n      }\n\n      return;\n    }\n\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(39, 2);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition()\n          });\n        }\n\n        this.state.pos += 2;\n        this.finishToken(9);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {\n            at: this.state.curPosition()\n          });\n        }\n\n        this.state.pos += 2;\n        this.finishToken(4);\n        return;\n      }\n    }\n\n    if (next === 61) {\n      this.finishOp(30, 2);\n      return;\n    }\n\n    this.finishOp(code === 124 ? 43 : 45, 1);\n  }\n\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61 && !this.state.inType) {\n      this.finishOp(32, 2);\n    } else if (next === 94 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"^^\"\n    }])) {\n      this.finishOp(37, 2);\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n\n      if (lookaheadCh === 94) {\n        throw this.unexpected();\n      }\n    } else {\n      this.finishOp(44, 1);\n    }\n  }\n\n  readToken_atSign() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 64 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"@@\"\n    }])) {\n      this.finishOp(38, 2);\n    } else {\n      this.finishOp(26, 1);\n    }\n  }\n\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      this.finishOp(34, 2);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(30, 2);\n    } else {\n      this.finishOp(53, 1);\n    }\n  }\n\n  readToken_lt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === 60) {\n      if (this.input.charCodeAt(pos + 2) === 61) {\n        this.finishOp(30, 3);\n        return;\n      }\n\n      this.finishOp(51, 2);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n\n    this.finishOp(47, 1);\n  }\n\n  readToken_gt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === 62) {\n      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;\n\n      if (this.input.charCodeAt(pos + size) === 61) {\n        this.finishOp(30, size + 1);\n        return;\n      }\n\n      this.finishOp(52, size);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n\n    this.finishOp(48, 1);\n  }\n\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(19);\n      return;\n    }\n\n    this.finishOp(code === 61 ? 29 : 35, 1);\n  }\n\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(40, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(18);\n    } else {\n      ++this.state.pos;\n      this.finishToken(17);\n    }\n  }\n\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n\n      case 40:\n        ++this.state.pos;\n        this.finishToken(10);\n        return;\n\n      case 41:\n        ++this.state.pos;\n        this.finishToken(11);\n        return;\n\n      case 59:\n        ++this.state.pos;\n        this.finishToken(13);\n        return;\n\n      case 44:\n        ++this.state.pos;\n        this.finishToken(12);\n        return;\n\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {\n              at: this.state.curPosition()\n            });\n          }\n\n          this.state.pos += 2;\n          this.finishToken(2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(0);\n        }\n\n        return;\n\n      case 93:\n        ++this.state.pos;\n        this.finishToken(3);\n        return;\n\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {\n              at: this.state.curPosition()\n            });\n          }\n\n          this.state.pos += 2;\n          this.finishToken(6);\n        } else {\n          ++this.state.pos;\n          this.finishToken(5);\n        }\n\n        return;\n\n      case 125:\n        ++this.state.pos;\n        this.finishToken(8);\n        return;\n\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(15, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(14);\n        }\n\n        return;\n\n      case 63:\n        this.readToken_question();\n        return;\n\n      case 96:\n        this.readTemplateToken();\n        return;\n\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n\n      case 47:\n        this.readToken_slash();\n        return;\n\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case 94:\n        this.readToken_caret();\n        return;\n\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n\n      case 60:\n        this.readToken_lt();\n        return;\n\n      case 62:\n        this.readToken_gt();\n        return;\n\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n\n      case 126:\n        this.finishOp(36, 1);\n        return;\n\n      case 64:\n        this.readToken_atSign();\n        return;\n\n      case 35:\n        this.readToken_numberSign();\n        return;\n\n      case 92:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n\n    }\n\n    throw this.raise(Errors.InvalidOrUnexpectedToken, {\n      at: this.state.curPosition(),\n      unexpected: String.fromCodePoint(code)\n    });\n  }\n\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp() {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let {\n      pos\n    } = this.state;\n\n    for (;; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1)\n        });\n      }\n\n      const ch = this.input.charCodeAt(pos);\n\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, {\n          at: createPositionWithColumnOffset(startLoc, 1)\n        });\n      }\n\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === 91) {\n          inClass = true;\n        } else if (ch === 93 && inClass) {\n          inClass = false;\n        } else if (ch === 47 && !inClass) {\n          break;\n        }\n\n        escaped = ch === 92;\n      }\n    }\n\n    const content = this.input.slice(start, pos);\n    ++pos;\n    let mods = \"\";\n\n    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);\n\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      const char = String.fromCharCode(cp);\n\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === 118) {\n          this.expectPlugin(\"regexpUnicodeSets\", nextPos());\n\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, {\n              at: nextPos()\n            });\n          }\n        } else if (cp === 117) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, {\n              at: nextPos()\n            });\n          }\n        }\n\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, {\n            at: nextPos()\n          });\n        }\n      } else if (isIdentifierChar(cp) || cp === 92) {\n        this.raise(Errors.MalformedRegExpFlags, {\n          at: nextPos()\n        });\n      } else {\n        break;\n      }\n\n      ++pos;\n      mods += char;\n    }\n\n    this.state.pos = pos;\n    this.finishToken(133, {\n      pattern: content,\n      flags: mods\n    });\n  }\n\n  readInt(radix, len, forceLen = false, allowNumSeparator = true) {\n    const {\n      n,\n      pos\n    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt);\n    this.state.pos = pos;\n    return n;\n  }\n\n  readRadixNumber(radix) {\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, {\n        at: createPositionWithColumnOffset(startLoc, 2),\n        radix\n      });\n    }\n\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(Errors.InvalidDecimal, {\n        at: startLoc\n      });\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition()\n      });\n    }\n\n    if (isBigInt) {\n      const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(131, str);\n      return;\n    }\n\n    this.finishToken(130, val);\n  }\n\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, {\n        at: this.state.curPosition()\n      });\n    }\n\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, {\n        at: startLoc\n      });\n\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n\n        if (underscorePos > 0) {\n          this.raise(Errors.ZeroDigitNumericSeparator, {\n            at: createPositionWithColumnOffset(startLoc, underscorePos)\n          });\n        }\n      }\n\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, {\n          at: startLoc\n        });\n      }\n\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, {\n          at: startLoc\n        });\n      }\n\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, {\n          at: startLoc\n        });\n      }\n\n      ++this.state.pos;\n      isDecimal = true;\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, {\n        at: this.state.curPosition()\n      });\n    }\n\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(131, str);\n      return;\n    }\n\n    if (isDecimal) {\n      this.finishToken(132, str);\n      return;\n    }\n\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(130, val);\n  }\n\n  readCodePoint(throwOnInvalid) {\n    const {\n      code,\n      pos\n    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);\n    this.state.pos = pos;\n    return code;\n  }\n\n  readString(quote) {\n    const {\n      str,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(quote === 34 ? \"double\" : \"single\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(129, str);\n  }\n\n  readTemplateContinuation() {\n    if (!this.match(8)) {\n      this.unexpected(null, 8);\n    }\n\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n\n  readTemplateToken() {\n    const opening = this.input[this.state.pos];\n    const {\n      str,\n      containsInvalid,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(\"template\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n\n    if (this.input.codePointAt(pos) === 96) {\n      this.finishToken(24, containsInvalid ? null : opening + str + \"`\");\n    } else {\n      this.state.pos++;\n      this.finishToken(25, containsInvalid ? null : opening + str + \"${\");\n    }\n  }\n\n  recordStrictModeErrors(toParseError, {\n    at\n  }) {\n    const index = at.index;\n\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, {\n        at\n      });\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n\n  readWord1(firstCode) {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(Errors.MissingUnicodeEscape, {\n            at: this.state.curPosition()\n          });\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, {\n              at: escStart\n            });\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  readWord(firstCode) {\n    const word = this.readWord1(firstCode);\n    const type = keywords$1.get(word);\n\n    if (type !== undefined) {\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(128, word);\n    }\n  }\n\n  checkKeywordEscapes() {\n    const {\n      type\n    } = this.state;\n\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, {\n        at: this.state.startLoc,\n        reservedWord: tokenLabelName(type)\n      });\n    }\n  }\n\n  raise(toParseError, raiseProperties) {\n    const {\n      at\n    } = raiseProperties,\n          details = _objectWithoutPropertiesLoose(raiseProperties, _excluded);\n\n    const loc = at instanceof Position ? at : at.loc.start;\n    const error = toParseError({\n      loc,\n      details\n    });\n    if (!this.options.errorRecovery) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n    return error;\n  }\n\n  raiseOverwrite(toParseError, raiseProperties) {\n    const {\n      at\n    } = raiseProperties,\n          details = _objectWithoutPropertiesLoose(raiseProperties, _excluded2);\n\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n\n      if (error.loc.index === pos) {\n        return errors[i] = toParseError({\n          loc,\n          details\n        });\n      }\n\n      if (error.loc.index < pos) break;\n    }\n\n    return this.raise(toParseError, raiseProperties);\n  }\n\n  updateContext(prevType) {}\n\n  unexpected(loc, type) {\n    throw this.raise(Errors.UnexpectedToken, {\n      expected: type ? tokenLabelName(type) : null,\n      at: loc != null ? loc : this.state.startLoc\n    });\n  }\n\n  expectPlugin(pluginName, loc) {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n\n    throw this.raise(Errors.MissingPlugin, {\n      at: loc != null ? loc : this.state.startLoc,\n      missingPlugin: [pluginName]\n    });\n  }\n\n  expectOnePlugin(pluginNames) {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, {\n        at: this.state.startLoc,\n        missingPlugin: pluginNames\n      });\n    }\n  }\n\n  errorBuilder(error) {\n    return (pos, lineStart, curLine) => {\n      this.raise(error, {\n        at: buildPosition(pos, lineStart, curLine)\n      });\n    };\n  }\n\n}\n\nclass Scope {\n  constructor(flags) {\n    this.var = new Set();\n    this.lexical = new Set();\n    this.functions = new Set();\n    this.flags = flags;\n  }\n\n}\nclass ScopeHandler {\n  constructor(parser, inModule) {\n    this.parser = void 0;\n    this.scopeStack = [];\n    this.inModule = void 0;\n    this.undefinedExports = new Map();\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n\n  get inFunction() {\n    return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;\n  }\n\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;\n  }\n\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;\n  }\n\n  get inClass() {\n    return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;\n  }\n\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;\n  }\n\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n\n      if (flags & SCOPE_STATIC_BLOCK) {\n        return true;\n      }\n\n      if (flags & (SCOPE_VAR | SCOPE_CLASS)) {\n        return false;\n      }\n    }\n  }\n\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;\n  }\n\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags) {\n    return new Scope(flags);\n  }\n\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit() {\n    this.scopeStack.pop();\n  }\n\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & (SCOPE_FUNCTION | SCOPE_STATIC_BLOCK) || !this.parser.inModule && scope.flags & SCOPE_PROGRAM);\n  }\n\n  declareName(name, bindingType, loc) {\n    let scope = this.currentScope();\n\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n\n      if (bindingType & BIND_SCOPE_FUNCTION) {\n        scope.functions.add(name);\n      } else {\n        scope.lexical.add(name);\n      }\n\n      if (bindingType & BIND_SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BIND_SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.var.add(name);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & SCOPE_VAR) break;\n      }\n    }\n\n    if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope, name) {\n    if (this.parser.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(scope, name, bindingType, loc) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, {\n        at: loc,\n        identifierName: name\n      });\n    }\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\n\n    if (bindingType & BIND_SCOPE_LEXICAL) {\n      return scope.lexical.has(name) || scope.functions.has(name) || scope.var.has(name);\n    }\n\n    if (bindingType & BIND_SCOPE_FUNCTION) {\n      return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope.var.has(name);\n    }\n\n    return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);\n  }\n\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    const topLevelScope = this.scopeStack[0];\n\n    if (!topLevelScope.lexical.has(name) && !topLevelScope.var.has(name) && !topLevelScope.functions.has(name)) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  currentVarScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n\n      if (flags & SCOPE_VAR) {\n        return flags;\n      }\n    }\n  }\n\n  currentThisScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n\n      if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {\n        return flags;\n      }\n    }\n  }\n\n}\n\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = new Set();\n  }\n\n}\n\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n\n    super.declareName(name, bindingType, loc);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;\n\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));\n    }\n\n    return false;\n  }\n\n  checkLocalExport(id) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n\n}\nclass ClassScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.parser = parser;\n  }\n\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, {\n          at: loc,\n          identifierName: name\n        });\n      }\n    }\n  }\n\n  declarePrivateName(name, elementType, loc) {\n    const {\n      privateNames,\n      loneAccessors,\n      undefinedPrivateNames\n    } = this.current();\n    let redefined = privateNames.has(name);\n\n    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {\n      const accessor = redefined && loneAccessors.get(name);\n\n      if (accessor) {\n        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;\n        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;\n        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;\n        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, {\n        at: loc,\n        identifierName: name\n      });\n    }\n\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n\n  usePrivateName(name, loc) {\n    let classScope;\n\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, {\n        at: loc,\n        identifierName: name\n      });\n    }\n  }\n\n}\n\nconst kExpression = 0,\n      kMaybeArrowParameterDeclaration = 1,\n      kMaybeAsyncArrowParameterDeclaration = 2,\n      kParameterDeclaration = 3;\n\nclass ExpressionScope {\n  constructor(type = kExpression) {\n    this.type = void 0;\n    this.type = type;\n  }\n\n  canBeArrowParameterDeclaration() {\n    return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;\n  }\n\n  isCertainlyParameterDeclaration() {\n    return this.type === kParameterDeclaration;\n  }\n\n}\n\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.declarationErrors = new Map();\n  }\n\n  recordDeclarationError(ParsingErrorClass, {\n    at\n  }) {\n    const index = at.index;\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n\n  clearDeclarationError(index) {\n    this.declarationErrors.delete(index);\n  }\n\n  iterateErrors(iterator) {\n    this.declarationErrors.forEach(iterator);\n  }\n\n}\n\nclass ExpressionScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [new ExpressionScope()];\n    this.parser = parser;\n  }\n\n  enter(scope) {\n    this.stack.push(scope);\n  }\n\n  exit() {\n    this.stack.pop();\n  }\n\n  recordParameterInitializerError(toParseError, {\n    at: node\n  }) {\n    const origin = {\n      at: node.loc.start\n    };\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        return;\n      }\n\n      scope = stack[--i];\n    }\n\n    this.parser.raise(toParseError, origin);\n  }\n\n  recordArrowParemeterBindingError(error, {\n    at: node\n  }) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n    const origin = {\n      at: node.loc.start\n    };\n\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n\n  recordAsyncArrowParametersError({\n    at\n  }) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === kMaybeAsyncArrowParameterDeclaration) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, {\n          at\n        });\n      }\n\n      scope = stack[--i];\n    }\n  }\n\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, {\n        at: loc\n      });\n      let i = stack.length - 2;\n      let scope = stack[i];\n\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(kParameterDeclaration);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\n\nconst PARAM = 0b0000,\n      PARAM_YIELD = 0b0001,\n      PARAM_AWAIT = 0b0010,\n      PARAM_RETURN = 0b0100,\n      PARAM_IN = 0b1000;\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n\n  exit() {\n    this.stacks.pop();\n  }\n\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n\n  get hasAwait() {\n    return (this.currentFlags() & PARAM_AWAIT) > 0;\n  }\n\n  get hasYield() {\n    return (this.currentFlags() & PARAM_YIELD) > 0;\n  }\n\n  get hasReturn() {\n    return (this.currentFlags() & PARAM_RETURN) > 0;\n  }\n\n  get hasIn() {\n    return (this.currentFlags() & PARAM_IN) > 0;\n  }\n\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);\n}\n\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, value, enumerable = true) {\n    if (!node) return;\n    const extra = node.extra = node.extra || {};\n\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, {\n        enumerable,\n        value\n      });\n    }\n  }\n\n  isContextual(token) {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);\n    }\n\n    return false;\n  }\n\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  eatContextual(token) {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n\n    return false;\n  }\n\n  expectContextual(token, toParseError) {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, {\n          at: this.state.startLoc\n        });\n      }\n\n      throw this.unexpected(null, token);\n    }\n  }\n\n  canInsertSemicolon() {\n    return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();\n  }\n\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));\n  }\n\n  hasFollowingLineBreak() {\n    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;\n    return skipWhiteSpaceToLineBreak.test(this.input);\n  }\n\n  isLineTerminator() {\n    return this.eat(13) || this.canInsertSemicolon();\n  }\n\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;\n    this.raise(Errors.MissingSemicolon, {\n      at: this.state.lastTokEndLoc\n    });\n  }\n\n  expect(type, loc) {\n    this.eat(type) || this.unexpected(loc, type);\n  }\n\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc\n    } = refExpressionErrors;\n    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;\n\n    if (!andThrow) {\n      return hasErrors;\n    }\n\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, {\n        at: shorthandAssignLoc\n      });\n    }\n\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, {\n        at: doubleProtoLoc\n      });\n    }\n\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, {\n        at: privateKeyLoc\n      });\n    }\n\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n  }\n\n  isLiteralPropertyName() {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n\n  isOptionalChain(node) {\n    return node.type === \"OptionalMemberExpression\" || node.type === \"OptionalCallExpression\";\n  }\n\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n\n  initializeScopes(inModule = this.options.sourceType === \"module\") {\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n    return () => {\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n\n  enterInitialScopes() {\n    let paramFlags = PARAM;\n\n    if (this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n  }\n\n  checkDestructuringPrivate(refExpressionErrors) {\n    const {\n      privateKeyLoc\n    } = refExpressionErrors;\n\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssignLoc = null;\n    this.doubleProtoLoc = null;\n    this.privateKeyLoc = null;\n    this.optionalParametersLoc = null;\n  }\n\n}\n\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser != null && parser.options.ranges) this.range = [pos, 0];\n    if (parser != null && parser.filename) this.loc.filename = parser.filename;\n  }\n\n}\n\nconst NodePrototype = Node.prototype;\n{\n  NodePrototype.__clone = function () {\n    const newNode = new Node();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n\n    return newNode;\n  };\n}\n\nfunction clonePlaceholder(node) {\n  return cloneIdentifier(node);\n}\n\nfunction cloneIdentifier(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra,\n    name\n  } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n\n  if (type === \"Placeholder\") {\n    cloned.expectedNode = node.expectedNode;\n  }\n\n  return cloned;\n}\nfunction cloneStringLiteral(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra\n  } = node;\n\n  if (type === \"Placeholder\") {\n    return clonePlaceholder(node);\n  }\n\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n\n  if (node.raw !== undefined) {\n    cloned.raw = node.raw;\n  } else {\n    cloned.extra = extra;\n  }\n\n  cloned.value = node.value;\n  return cloned;\n}\nclass NodeUtils extends UtilParser {\n  startNode() {\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt(pos, loc) {\n    return new Node(this, pos, loc);\n  }\n\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.start, type.loc.start);\n  }\n\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n\n  finishNodeAt(node, type, endLoc) {\n\n    node.type = type;\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n    if (this.options.attachComment) this.processComment(node);\n    return node;\n  }\n\n  resetStartLocation(node, start, startLoc) {\n    node.start = start;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = start;\n  }\n\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n  }\n\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\n  }\n\n}\n\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  AssignReservedType: ({\n    reservedType\n  }) => `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName\n  }) => `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName\n  }) => `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({\n    enumName\n  }) => `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName\n  }) => `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName\n  }) => `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType\n  }) => `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName\n  }) => `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName\n  }) => `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion\n  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName\n  }) => `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitailized: ({\n    enumName\n  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: Object.assign({\n    message: \"A binding pattern parameter cannot be optional in an implementation signature.\"\n  }, {\n    reasonCode: \"OptionalBindingPattern\"\n  }),\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired: \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor: \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst: \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({\n    reservedType\n  }) => `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion\n  }) => `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\"\n});\n\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\n\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(type) {\n  return tokenIsKeywordOrIdentifier(type) && type !== 97;\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\n\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = (superClass => class FlowParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.flowPragma = undefined;\n  }\n\n  getScopeHandler() {\n    return FlowScopeHandler;\n  }\n\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n\n  shouldParseEnums() {\n    return !!this.getPluginOption(\"flow\", \"enums\");\n  }\n\n  finishToken(type, val) {\n    if (type !== 129 && type !== 13 && type !== 28) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n\n    return super.finishToken(type, val);\n  }\n\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n\n      if (!matches) ; else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n\n    return super.addComment(comment);\n  }\n\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || 14);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    this.next();\n    this.expectContextual(107);\n\n    if (this.state.lastTokStart > moduloLoc.index + 1) {\n      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {\n        at: moduloLoc\n      });\n    }\n\n    if (this.eat(10)) {\n      node.value = super.parseExpression();\n      this.expect(11);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(14);\n    let type = null;\n    let predicate = null;\n\n    if (this.match(54)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n\n      if (this.match(54)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n\n    return [type, predicate];\n  }\n\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n\n    if (this.match(47)) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n\n    this.expect(10);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    typeNode.this = tmp._this;\n    this.expect(11);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.loc.start);\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n\n  flowParseDeclare(node, insideModule) {\n    if (this.match(80)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(68)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(74)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(123)) {\n      if (this.match(16)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(FlowErrors.NestedDeclareModule, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(126)) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(127)) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(125)) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(82)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      throw this.unexpected();\n    }\n  }\n\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, BIND_VAR, node.id.loc.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n\n  flowParseDeclareModule(node) {\n    this.scope.enter(SCOPE_OTHER);\n\n    if (this.match(129)) {\n      node.id = super.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(5);\n\n    while (!this.match(8)) {\n      let bodyNode = this.startNode();\n\n      if (this.match(83)) {\n        this.next();\n\n        if (!this.isContextual(126) && !this.match(87)) {\n          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n\n        super.parseImport(bodyNode);\n      } else {\n        this.expectContextual(121, FlowErrors.UnsupportedStatementInDeclareModule);\n        bodyNode = this.flowParseDeclare(bodyNode, true);\n      }\n\n      body.push(bodyNode);\n    }\n\n    this.scope.exit();\n    this.expect(8);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n            at: bodyElement\n          });\n        }\n\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(FlowErrors.DuplicateDeclareModuleExports, {\n            at: bodyElement\n          });\n        }\n\n        if (kind === \"ES\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, {\n            at: bodyElement\n          });\n        }\n\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(82);\n\n    if (this.eat(65)) {\n      if (this.match(68) || this.match(80)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !insideModule) {\n        const label = this.state.value;\n        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {\n          at: this.state.startLoc,\n          unsupportedExportKind: label,\n          suggestion: exportSuggestions[label]\n        });\n      }\n\n      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n        node.default = false;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127)) {\n        node = this.parseExport(node);\n\n        if (node.type === \"ExportNamedDeclaration\") {\n          node.type = \"ExportDeclaration\";\n          node.default = false;\n          delete node.exportKind;\n        }\n\n        node.type = \"Declare\" + node.type;\n        return node;\n      }\n    }\n\n    throw this.unexpected();\n  }\n\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(108);\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    const finished = this.flowParseTypeAlias(node);\n    finished.type = \"DeclareTypeAlias\";\n    return finished;\n  }\n\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    const finished = this.flowParseOpaqueType(node, true);\n    finished.type = \"DeclareOpaqueType\";\n    return finished;\n  }\n\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n\n  flowParseInterfaceish(node, isClass = false) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.loc.start);\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.extends = [];\n    node.implements = [];\n    node.mixins = [];\n\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(12));\n    }\n\n    if (this.isContextual(114)) {\n      this.next();\n\n      do {\n        node.mixins.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n\n    if (this.isContextual(110)) {\n      this.next();\n\n      do {\n        node.implements.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(FlowErrors.UnexpectedReservedUnderscore, {\n        at: this.state.startLoc\n      });\n    }\n  }\n\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {\n      at: startLoc,\n      reservedType: word\n    });\n  }\n\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.startLoc, declaration);\n    return this.parseIdentifier(liberal);\n  }\n\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.right = this.flowParseTypeInitialiser(29);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(126);\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.loc.start);\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.supertype = null;\n\n    if (this.match(14)) {\n      node.supertype = this.flowParseTypeInitialiser(14);\n    }\n\n    node.impltype = null;\n\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(29);\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStartLoc = this.state.startLoc;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n\n    if (this.match(29)) {\n      this.eat(29);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(FlowErrors.MissingTypeParamDefault, {\n          at: nodeStartLoc\n        });\n      }\n    }\n\n    return this.finishNode(node, \"TypeParameter\");\n  }\n\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n\n    if (this.match(47) || this.match(138)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    let defaultRequired = false;\n\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    } while (!this.match(48));\n\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    this.state.noAnonFunctionType = false;\n\n    while (!this.match(48)) {\n      node.params.push(this.flowParseType());\n\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n\n    this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n\n  flowParseTypeParameterInstantiationCallOrNew() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n\n    while (!this.match(48)) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(125);\n    node.extends = [];\n\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n\n  flowParseObjectPropertyKey() {\n    return this.match(130) || this.match(129) ? super.parseExprAtom() : this.parseIdentifier(true);\n  }\n\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n\n    if (this.lookahead().type === 14) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n\n    this.expect(3);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(3);\n    this.expect(3);\n\n    if (this.match(47) || this.match(10)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n    } else {\n      node.method = false;\n\n      if (this.eat(17)) {\n        node.optional = true;\n      }\n\n      node.value = this.flowParseTypeInitialiser();\n    }\n\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n    node.this = null;\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    this.expect(10);\n\n    if (this.match(78)) {\n      node.this = this.flowParseFunctionTypeParam(true);\n      node.this.name = null;\n\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n\n    while (!this.match(11) && !this.match(21)) {\n      node.params.push(this.flowParseFunctionTypeParam(false));\n\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n\n    if (this.eat(21)) {\n      node.rest = this.flowParseFunctionTypeParam(false);\n    }\n\n    this.expect(11);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n\n    if (allowExact && this.match(6)) {\n      this.expect(6);\n      endDelim = 9;\n      exact = true;\n    } else {\n      this.expect(5);\n      endDelim = 8;\n      exact = false;\n    }\n\n    nodeStart.exact = exact;\n\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStartLoc = null;\n      let inexactStartLoc = null;\n      const node = this.startNode();\n\n      if (allowProto && this.isContextual(115)) {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          protoStartLoc = this.state.startLoc;\n          allowStatic = false;\n        }\n      }\n\n      if (allowStatic && this.isContextual(104)) {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          isStatic = true;\n        }\n      }\n\n      const variance = this.flowParseVariance();\n\n      if (this.eat(0)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n\n        if (this.eat(0)) {\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(10) || this.match(47)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n\n        if (this.isContextual(98) || this.isContextual(103)) {\n          const lookahead = this.lookahead();\n\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStartLoc = this.state.lastTokStartLoc;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n\n      this.flowObjectTypeSemicolon();\n\n      if (inexactStartLoc && !this.match(8) && !this.match(9)) {\n        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {\n          at: inexactStartLoc\n        });\n      }\n    }\n\n    this.expect(endDelim);\n\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n\n  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(21)) {\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\n\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(FlowErrors.InexactInsideNonObject, {\n            at: this.state.lastTokStartLoc\n          });\n        } else if (!allowInexact) {\n          this.raise(FlowErrors.InexactInsideExact, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n\n        if (variance) {\n          this.raise(FlowErrors.InexactVariance, {\n            at: variance\n          });\n        }\n\n        return null;\n      }\n\n      if (!allowSpread) {\n        this.raise(FlowErrors.UnexpectedSpreadType, {\n          at: this.state.lastTokStartLoc\n        });\n      }\n\n      if (protoStartLoc != null) {\n        this.unexpected(protoStartLoc);\n      }\n\n      if (variance) {\n        this.raise(FlowErrors.SpreadVariance, {\n          at: variance\n        });\n      }\n\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStartLoc != null;\n      node.kind = kind;\n      let optional = false;\n\n      if (this.match(47) || this.match(10)) {\n        node.method = true;\n\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n\n        if (!allowSpread && node.key.name === \"constructor\" && node.value.this) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, {\n            at: node.value.this\n          });\n        }\n      } else {\n        if (kind !== \"init\") this.unexpected();\n        node.method = false;\n\n        if (this.eat(17)) {\n          optional = true;\n        }\n\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n\n    if (property.value.this) {\n      this.raise(property.kind === \"get\" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {\n        at: property.value.this\n      });\n    }\n\n    if (length !== paramCount) {\n      this.raise(property.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, {\n        at: property\n      });\n    }\n\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(Errors.BadSetterRestParameter, {\n        at: property\n      });\n    }\n  }\n\n  flowObjectTypeSemicolon() {\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\n      this.unexpected();\n    }\n  }\n\n  flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n\n    while (this.eat(16)) {\n      const node2 = this.startNodeAt(startPos, startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n\n    return node;\n  }\n\n  flowParseGenericType(startPos, startLoc, id) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(87);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(0);\n\n    while (this.state.pos < this.length && !this.match(3)) {\n      node.types.push(this.flowParseType());\n      if (this.match(3)) break;\n      this.expect(12);\n    }\n\n    this.expect(3);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n\n  flowParseFunctionTypeParam(first) {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n    const isThis = this.state.type === 78;\n\n    if (lh.type === 14 || lh.type === 17) {\n      if (isThis && !first) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, {\n          at: node\n        });\n      }\n\n      name = this.parseIdentifier(isThis);\n\n      if (this.eat(17)) {\n        optional = true;\n\n        if (isThis) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, {\n            at: node\n          });\n        }\n      }\n\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.start, type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n    let _this = null;\n\n    if (this.match(78)) {\n      _this = this.flowParseFunctionTypeParam(true);\n      _this.name = null;\n\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n\n    while (!this.match(11) && !this.match(21)) {\n      params.push(this.flowParseFunctionTypeParam(false));\n\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n\n    if (this.eat(21)) {\n      rest = this.flowParseFunctionTypeParam(false);\n    }\n\n    return {\n      params,\n      rest,\n      _this\n    };\n  }\n\n  flowIdentToTypeAnnotation(startPos, startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startPos, startLoc, id);\n    }\n  }\n\n  flowParsePrimaryType() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n    switch (this.state.type) {\n      case 5:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n\n      case 6:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n\n      case 0:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n\n      case 47:\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n        this.expect(10);\n        tmp = this.flowParseFunctionTypeParams();\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n      case 10:\n        this.next();\n\n        if (!this.match(11) && !this.match(21)) {\n          if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n            const token = this.lookahead().type;\n            isGroupedType = token !== 17 && token !== 14;\n          } else {\n            isGroupedType = true;\n          }\n        }\n\n        if (isGroupedType) {\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\n            this.expect(11);\n            return type;\n          } else {\n            this.eat(12);\n          }\n        }\n\n        if (type) {\n          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n        } else {\n          tmp = this.flowParseFunctionTypeParams();\n        }\n\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        node.this = tmp._this;\n        this.expect(11);\n        this.expect(19);\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n      case 129:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n      case 85:\n      case 86:\n        node.value = this.match(85);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n      case 53:\n        if (this.state.value === \"-\") {\n          this.next();\n\n          if (this.match(130)) {\n            return this.parseLiteralAtNode(-this.state.value, \"NumberLiteralTypeAnnotation\", node);\n          }\n\n          if (this.match(131)) {\n            return this.parseLiteralAtNode(-this.state.value, \"BigIntLiteralTypeAnnotation\", node);\n          }\n\n          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {\n            at: this.state.startLoc\n          });\n        }\n\n        throw this.unexpected();\n\n      case 130:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n\n      case 131:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n\n      case 88:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n\n      case 84:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n      case 78:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n\n      case 55:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n      case 87:\n        return this.flowParseTypeofType();\n\n      default:\n        if (tokenIsKeyword(this.state.type)) {\n          const label = tokenLabelName(this.state.type);\n          this.next();\n          return super.createIdentifier(node, label);\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (this.isContextual(125)) {\n            return this.flowParseInterfaceType();\n          }\n\n          return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());\n        }\n\n    }\n\n    throw this.unexpected();\n  }\n\n  flowParsePostfixType() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n    let seenOptionalIndexedAccess = false;\n\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const optional = this.eat(18);\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n      this.expect(0);\n\n      if (!optional && this.match(3)) {\n        node.elementType = type;\n        this.next();\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      } else {\n        node.objectType = type;\n        node.indexType = this.flowParseType();\n        this.expect(3);\n\n        if (seenOptionalIndexedAccess) {\n          node.optional = optional;\n          type = this.finishNode(node, \"OptionalIndexedAccessType\");\n        } else {\n          type = this.finishNode(node, \"IndexedAccessType\");\n        }\n      }\n    }\n\n    return type;\n  }\n\n  flowParsePrefixType() {\n    const node = this.startNode();\n\n    if (this.eat(17)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\n      const node = this.startNodeAt(param.start, param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.this = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    return param;\n  }\n\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(45);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n\n    while (this.eat(45)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(43);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n\n    while (this.eat(43)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    return type;\n  }\n\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === 128 && this.state.value === \"_\") {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startPos, startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n\n    if (this.match(14)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n\n    return ident;\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  flowParseVariance() {\n    let variance = null;\n\n    if (this.match(53)) {\n      variance = this.startNode();\n\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n\n      this.next();\n      return this.finishNode(variance, \"Variance\");\n    }\n\n    return variance;\n  }\n\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n    }\n\n    return super.parseFunctionBody(node, false, isMethod);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.state.strict && this.isContextual(125)) {\n      const lookahead = this.lookahead();\n\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      }\n    } else if (this.shouldParseEnums() && this.isContextual(122)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n\n    const stmt = super.parseStatement(context, topLevel);\n\n    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n      this.flowPragma = null;\n    }\n\n    return stmt;\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (tokenIsIdentifier(this.state.type)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n\n    return super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {\n      return !this.state.containsEsc;\n    }\n\n    return super.shouldParseExportDeclaration();\n  }\n\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n\n    if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 122) {\n      return this.state.containsEsc;\n    }\n\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseExportDefaultExpression() {\n    if (this.shouldParseEnums() && this.isContextual(122)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseConditional(expr, startPos, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n\n    this.expect(17);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startPos, startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n\n      if (failed && valid.length > 1) {\n        this.raise(FlowErrors.AmbiguousConditionalArrow, {\n          at: state.startLoc\n        });\n      }\n\n      if (failed && valid.length === 1) {\n        this.state = state;\n        noArrowAt.push(valid[0].start);\n        this.state.noArrowAt = noArrowAt;\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(14);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssignAllowIn();\n    const failed = !this.match(14);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n\n    while (stack.length !== 0) {\n      const node = stack.pop();\n\n      if (node.type === \"ArrowFunctionExpression\") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n\n        stack.push(node.body);\n      } else if (node.type === \"ConditionalExpression\") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n\n  finishArrowValidation(node) {\n    var _node$extra;\n\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n\n    return result;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n\n    super.assertModuleNodeAllowed(node);\n  }\n\n  parseExport(node) {\n    const decl = super.parseExport(node);\n\n    if (decl.type === \"ExportNamedDeclaration\" || decl.type === \"ExportAllDeclaration\") {\n      decl.exportKind = decl.exportKind || \"value\";\n    }\n\n    return decl;\n  }\n\n  parseExportDeclaration(node) {\n    if (this.isContextual(126)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n\n      if (this.match(5)) {\n        node.specifiers = this.parseExportSpecifiers(true);\n        super.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(127)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(125)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.shouldParseEnums() && this.isContextual(122)) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n\n  eatExportStar(node) {\n    if (super.eatExportStar(node)) return true;\n\n    if (this.isContextual(126) && this.lookahead().type === 55) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    const {\n      startLoc\n    } = this.state;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(startLoc);\n    }\n\n    return hasNamespace;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n\n  parseClassMember(classBody, member, state) {\n    const {\n      startLoc\n    } = this.state;\n\n    if (this.isContextual(121)) {\n      if (super.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n\n      member.declare = true;\n    }\n\n    super.parseClassMember(classBody, member, state);\n\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\" && member.type !== \"PropertyDefinition\") {\n        this.raise(FlowErrors.DeclareClassElement, {\n          at: startLoc\n        });\n      } else if (member.value) {\n        this.raise(FlowErrors.DeclareClassFieldInitializer, {\n          at: member.value\n        });\n      }\n    }\n  }\n\n  isIterator(word) {\n    return word === \"iterator\" || word === \"asyncIterator\";\n  }\n\n  readIterator() {\n    const word = super.readWord1();\n    const fullWord = \"@@\" + word;\n\n    if (!this.isIterator(word) || !this.state.inType) {\n      this.raise(Errors.InvalidIdentifier, {\n        at: this.state.curPosition(),\n        identifierName: fullWord\n      });\n    }\n\n    this.finishToken(128, fullWord);\n  }\n\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 123 && next === 124) {\n      return this.finishOp(6, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(code === 62 ? 48 : 47, 1);\n    } else if (this.state.inType && code === 63) {\n      if (next === 46) {\n        return this.finishOp(18, 2);\n      }\n\n      return this.finishOp(17, 1);\n    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {\n      this.state.pos += 2;\n      return this.readIterator();\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n\n  isAssignable(node, isBinding) {\n    if (node.type === \"TypeCastExpression\") {\n      return this.isAssignable(node.expression, isBinding);\n    } else {\n      return super.isAssignable(node, isBinding);\n    }\n  }\n\n  toAssignable(node, isLHS = false) {\n    if (!isLHS && node.type === \"AssignmentExpression\" && node.left.type === \"TypeCastExpression\") {\n      node.left = this.typeCastToParameter(node.left);\n    }\n\n    super.toAssignable(node, isLHS);\n  }\n\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      var _expr$extra;\n\n      const expr = exprList[i];\n\n      if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(FlowErrors.TypeCastInPattern, {\n          at: expr.typeAnnotation\n        });\n      }\n    }\n\n    return exprList;\n  }\n\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n\n    if (canBePattern && !this.state.maybeInArrowParameters) {\n      this.toReferencedList(node.elements);\n    }\n\n    return node;\n  }\n\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"TypeCastExpression\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n\n  parseClassProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    return super.parseClassPrivateProperty(node);\n  }\n\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(14) || super.isClassProperty();\n  }\n\n  isNonstaticConstructor(method) {\n    return !this.match(14) && super.isNonstaticConstructor(method);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n\n    delete method.variance;\n\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n\n    if (method.params && isConstructor) {\n      const params = method.params;\n\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, {\n          at: method\n        });\n      }\n    } else if (method.type === \"MethodDefinition\" && isConstructor && method.value.params) {\n      const params = method.value.params;\n\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, {\n          at: method\n        });\n      }\n    }\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n\n    delete method.variance;\n\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && this.match(47)) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n    }\n\n    if (this.isContextual(110)) {\n      this.next();\n      const implemented = node.implements = [];\n\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n\n        if (this.match(47)) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n\n        implemented.push(this.finishNode(node, \"ClassImplements\"));\n      } while (this.eat(12));\n    }\n  }\n\n  checkGetterSetterParams(method) {\n    super.checkGetterSetterParams(method);\n    const params = this.getObjectOrClassMethodParams(method);\n\n    if (params.length > 0) {\n      const param = params[0];\n\n      if (this.isThisParam(param) && method.kind === \"get\") {\n        this.raise(FlowErrors.GetterMayNotHaveThisParam, {\n          at: param\n        });\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.SetterMayNotHaveThisParam, {\n          at: param\n        });\n      }\n    }\n  }\n\n  parsePropertyNamePrefixOperator(node) {\n    node.variance = this.flowParseVariance();\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.loc.start);\n    }\n\n    delete prop.variance;\n    let typeParameters;\n\n    if (this.match(47) && !isAccessor) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(10)) this.unexpected();\n    }\n\n    const result = super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n\n    if (typeParameters) {\n      (result.value || result).typeParameters = typeParameters;\n    }\n\n    return result;\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(FlowErrors.PatternIsOptional, {\n          at: param\n        });\n      }\n\n      if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamMayNotBeOptional, {\n          at: param\n        });\n      }\n\n      param.optional = true;\n    }\n\n    if (this.match(14)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    } else if (this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamAnnotationRequired, {\n        at: param\n      });\n    }\n\n    if (this.match(29) && this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamNoDefault, {\n        at: param\n      });\n    }\n\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(FlowErrors.TypeBeforeInitializer, {\n        at: node.typeAnnotation\n      });\n    }\n\n    return node;\n  }\n\n  shouldParseDefaultImport(node) {\n    if (!hasTypeImportKind(node)) {\n      return super.shouldParseDefaultImport(node);\n    }\n\n    return isMaybeDefaultImport(this.state.type);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    node.importKind = \"value\";\n    let kind = null;\n\n    if (this.match(87)) {\n      kind = \"typeof\";\n    } else if (this.isContextual(126)) {\n      kind = \"type\";\n    }\n\n    if (kind) {\n      const lh = this.lookahead();\n      const {\n        type\n      } = lh;\n\n      if (kind === \"type\" && type === 55) {\n        this.unexpected(null, lh.type);\n      }\n\n      if (isMaybeDefaultImport(type) || type === 5 || type === 55) {\n        this.next();\n        node.importKind = kind;\n      }\n    }\n\n    return super.maybeParseDefaultImportSpecifier(node);\n  }\n\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {\n    const firstIdent = specifier.imported;\n    let specifierTypeKind = null;\n\n    if (firstIdent.type === \"Identifier\") {\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n    }\n\n    let isBinding = false;\n\n    if (this.isContextual(93) && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = cloneIdentifier(as_ident);\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else {\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n      } else {\n        if (importedIsString) {\n          throw this.raise(Errors.ImportBindingIsString, {\n            at: specifier,\n            importName: firstIdent.value\n          });\n        }\n\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n      }\n\n      if (this.eatContextual(93)) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = cloneIdentifier(specifier.imported);\n      }\n    }\n\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n    if (isInTypeOnlyImport && specifierIsTypeImport) {\n      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {\n        at: specifier\n      });\n    }\n\n    if (isInTypeOnlyImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);\n    }\n\n    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);\n    }\n\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const kind = node.kind;\n\n    if (kind !== \"get\" && kind !== \"set\" && this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (this.match(14)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx;\n\n    let state = null;\n    let jsx;\n\n    if (this.hasPlugin(\"jsx\") && (this.match(138) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n\n    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {\n      var _jsx2, _jsx3;\n\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(abort => {\n        var _arrowExpression$extr;\n\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n          this.resetStartLocationFromNode(result, typeParameters);\n          return result;\n        });\n        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n        if (expr.type !== \"ArrowFunctionExpression\") abort();\n        expr.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(expr, typeParameters);\n        return arrowExpression;\n      }, state);\n      let arrowExpression = null;\n\n      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n        if (!arrow.error && !arrow.aborted) {\n          if (arrow.node.async) {\n            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {\n              at: typeParameters\n            });\n          }\n\n          return arrow.node;\n        }\n\n        arrowExpression = arrow.node;\n      }\n\n      if ((_jsx2 = jsx) != null && _jsx2.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n\n      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {\n        at: typeParameters\n      });\n    }\n\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n  }\n\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(19)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n      if (result.error) this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n\n    return super.parseArrow(node);\n  }\n\n  shouldParseArrow(params) {\n    return this.match(14) || super.shouldParseArrow(params);\n  }\n\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      return;\n    }\n\n    for (let i = 0; i < node.params.length; i++) {\n      if (this.isThisParam(node.params[i]) && i > 0) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, {\n          at: node.params[i]\n        });\n      }\n    }\n\n    return super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startPos) !== -1) {\n      this.next();\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.arguments = super.parseCallExpressionArguments(11, false);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.match(47)) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n\n      throw arrow.error || result.error;\n    }\n\n    return super.parseSubscripts(base, startPos, startLoc, noCalls);\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {\n    if (this.match(18) && this.isLookaheadToken_lt()) {\n      subscriptState.optionalChainMember = true;\n\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n\n      this.next();\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiation();\n      this.expect(10);\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(10);\n        node.arguments = super.parseCallExpressionArguments(11, false);\n\n        if (subscriptState.optionalChainMember) {\n          node.optional = false;\n        }\n\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);\n  }\n\n  parseNewCallee(node) {\n    super.parseNewCallee(node);\n    let targs = null;\n\n    if (this.shouldParseTypes() && this.match(47)) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n\n    node.typeArguments = targs;\n  }\n\n  parseAsyncArrowWithTypeParameters(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    this.parseFunctionParams(node);\n    if (!this.parseArrow(node)) return;\n    return super.parseArrowExpression(node, undefined, true);\n  }\n\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n\n    super.readToken_mult_modulo(code);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 124 && next === 125) {\n      this.finishOp(9, 2);\n      return;\n    }\n\n    super.readToken_pipe_amp(code);\n  }\n\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n\n    if (this.state.hasFlowComment) {\n      this.raise(FlowErrors.UnterminatedFlowComment, {\n        at: this.state.curPosition()\n      });\n    }\n\n    return fileNode;\n  }\n\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        throw this.raise(FlowErrors.NestedFlowComment, {\n          at: this.state.startLoc\n        });\n      }\n\n      this.hasFlowCommentCompletion();\n      const commentSkip = this.skipFlowComment();\n\n      if (commentSkip) {\n        this.state.pos += commentSkip;\n        this.state.hasFlowComment = true;\n      }\n\n      return;\n    }\n\n    if (this.state.hasFlowComment) {\n      const end = this.input.indexOf(\"*-/\", this.state.pos + 2);\n\n      if (end === -1) {\n        throw this.raise(Errors.UnterminatedComment, {\n          at: this.state.curPosition()\n        });\n      }\n\n      this.state.pos = end + 2 + 3;\n      return;\n    }\n\n    return super.skipBlockComment();\n  }\n\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n\n    return false;\n  }\n\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, {\n        at: this.state.curPosition()\n      });\n    }\n  }\n\n  flowEnumErrorBooleanMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {\n      at: loc,\n      memberName,\n      enumName\n    });\n  }\n\n  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {\n    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === \"symbol\" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, Object.assign({\n      at: loc\n    }, enumContext));\n  }\n\n  flowEnumErrorNumberMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumNumberMemberNotInitialized, {\n      at: loc,\n      enumName,\n      memberName\n    });\n  }\n\n  flowEnumErrorStringMemberInconsistentlyInitailized(node, {\n    enumName\n  }) {\n    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitailized, {\n      at: node,\n      enumName\n    });\n  }\n\n  flowEnumMemberInit() {\n    const startLoc = this.state.startLoc;\n\n    const endOfInit = () => this.match(12) || this.match(8);\n\n    switch (this.state.type) {\n      case 130:\n        {\n          const literal = this.parseNumericLiteral(this.state.value);\n\n          if (endOfInit()) {\n            return {\n              type: \"number\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n\n      case 129:\n        {\n          const literal = this.parseStringLiteral(this.state.value);\n\n          if (endOfInit()) {\n            return {\n              type: \"string\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n\n      case 85:\n      case 86:\n        {\n          const literal = this.parseBooleanLiteral(this.match(85));\n\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n\n      default:\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n    }\n  }\n\n  flowEnumMemberRaw() {\n    const loc = this.state.startLoc;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(29) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      loc\n    };\n    return {\n      id,\n      init\n    };\n  }\n\n  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n\n    if (explicitType === null) {\n      return;\n    }\n\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(loc, context);\n    }\n  }\n\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n    let hasUnknownMembers = false;\n\n    while (!this.match(8)) {\n      if (this.eat(21)) {\n        hasUnknownMembers = true;\n        break;\n      }\n\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n\n      if (memberName === \"\") {\n        continue;\n      }\n\n      if (/^[a-z]/.test(memberName)) {\n        this.raise(FlowErrors.EnumInvalidMemberName, {\n          at: id,\n          memberName,\n          suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n          enumName\n        });\n      }\n\n      if (seenNames.has(memberName)) {\n        this.raise(FlowErrors.EnumDuplicateMemberName, {\n          at: id,\n          memberName,\n          enumName\n        });\n      }\n\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n\n      switch (init.type) {\n        case \"boolean\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"boolean\");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n            break;\n          }\n\n        case \"number\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n            break;\n          }\n\n        case \"string\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n            break;\n          }\n\n        case \"invalid\":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n\n        case \"none\":\n          {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);\n                break;\n\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n            }\n          }\n      }\n\n      if (!this.match(8)) {\n        this.expect(12);\n      }\n    }\n\n    return {\n      members,\n      hasUnknownMembers\n    };\n  }\n\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (const member of initializedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {\n          enumName\n        });\n      }\n\n      return defaultedMembers;\n    } else {\n      for (const member of defaultedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member, {\n          enumName\n        });\n      }\n\n      return initializedMembers;\n    }\n  }\n\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (!this.eatContextual(101)) return null;\n\n    if (!tokenIsIdentifier(this.state.type)) {\n      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {\n        at: this.state.startLoc,\n        enumName\n      });\n    }\n\n    const {\n      value\n    } = this.state;\n    this.next();\n\n    if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n      this.raise(FlowErrors.EnumInvalidExplicitType, {\n        at: this.state.startLoc,\n        enumName,\n        invalidEnumType: value\n      });\n    }\n\n    return value;\n  }\n\n  flowEnumBody(node, id) {\n    const enumName = id.name;\n    const nameLoc = id.loc.start;\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(5);\n    const {\n      members,\n      hasUnknownMembers\n    } = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n    node.hasUnknownMembers = hasUnknownMembers;\n\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumBooleanBody\");\n\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumNumberBody\");\n\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(8);\n        return this.finishNode(node, \"EnumStringBody\");\n\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumSymbolBody\");\n\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n\n            node.members = members.booleanMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n\n            node.members = members.numberMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, {\n              at: nameLoc,\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), id);\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n\n  isLookaheadToken_lt() {\n    const next = this.nextTokenStart();\n\n    if (this.input.charCodeAt(next) === 60) {\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== 60 && afterNext !== 61;\n    }\n\n    return false;\n  }\n\n  maybeUnwrapTypeCastExpression(node) {\n    return node.type === \"TypeCastExpression\" ? node.expression : node;\n  }\n\n});\n\nconst entities = {\n  __proto__: null,\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: ({\n    openingTagName\n  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity\n  }) => `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`,\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\n\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nvar jsx = (superClass => class JSXParserMixin extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(JsxErrors.UnterminatedJsxContent, {\n          at: this.state.startLoc\n        });\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.canStartJSXElement) {\n              ++this.state.pos;\n              return this.finishToken(138);\n            }\n\n            return super.getTokenFromCode(ch);\n          }\n\n          out += this.input.slice(chunkStart, this.state.pos);\n          return this.finishToken(137, out);\n\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n\n        case 62:\n        case 125:\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n\n      }\n    }\n  }\n\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedString, {\n          at: this.state.startLoc\n        });\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    return this.finishToken(129, out);\n  }\n\n  jsxReadEntity() {\n    const startPos = ++this.state.pos;\n\n    if (this.codePointAtPos(this.state.pos) === 35) {\n      ++this.state.pos;\n      let radix = 10;\n\n      if (this.codePointAtPos(this.state.pos) === 120) {\n        radix = 16;\n        ++this.state.pos;\n      }\n\n      const codePoint = this.readInt(radix, undefined, false, \"bail\");\n\n      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {\n        ++this.state.pos;\n        return String.fromCodePoint(codePoint);\n      }\n    } else {\n      let count = 0;\n      let semi = false;\n\n      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) == 59)) {\n        ++this.state.pos;\n      }\n\n      if (semi) {\n        const desc = this.input.slice(startPos, this.state.pos);\n        const entity = entities[desc];\n        ++this.state.pos;\n\n        if (entity) {\n          return entity;\n        }\n      }\n    }\n\n    this.state.pos = startPos;\n    return \"&\";\n  }\n\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n\n    return this.finishToken(136, this.input.slice(start, this.state.pos));\n  }\n\n  jsxParseIdentifier() {\n    const node = this.startNode();\n\n    if (this.match(136)) {\n      node.name = this.state.value;\n    } else if (tokenIsKeyword(this.state.type)) {\n      node.name = tokenLabelName(this.state.type);\n    } else {\n      this.unexpected();\n    }\n\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n\n  jsxParseNamespacedName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(14)) return name;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n\n  jsxParseElementName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n\n    while (this.eat(16)) {\n      const newNode = this.startNodeAt(startPos, startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n\n    return node;\n  }\n\n  jsxParseAttributeValue() {\n    let node;\n\n    switch (this.state.type) {\n      case 5:\n        node = this.startNode();\n        this.setContext(types.brace);\n        this.next();\n        node = this.jsxParseExpressionContainer(node, types.j_oTag);\n\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(JsxErrors.AttributeIsEmpty, {\n            at: node\n          });\n        }\n\n        return node;\n\n      case 138:\n      case 129:\n        return this.parseExprAtom();\n\n      default:\n        throw this.raise(JsxErrors.UnsupportedJsxValue, {\n          at: this.state.startLoc\n        });\n    }\n  }\n\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n  }\n\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.setContext(types.j_oTag);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n\n  jsxParseExpressionContainer(node, previousContext) {\n    if (this.match(8)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n\n    this.setContext(previousContext);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n\n  jsxParseAttribute() {\n    const node = this.startNode();\n\n    if (this.match(5)) {\n      this.setContext(types.brace);\n      this.next();\n      this.expect(21);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.setContext(types.j_oTag);\n      this.state.canStartJSXElement = true;\n      this.expect(8);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n\n  jsxParseOpeningElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.eat(139)) {\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n\n    while (!this.match(56) && !this.match(139)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n\n    node.attributes = attributes;\n    node.selfClosing = this.eat(56);\n    this.expect(139);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n\n  jsxParseClosingElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.eat(139)) {\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    this.expect(139);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n\n  jsxParseElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n    let closingElement = null;\n\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case 138:\n            startPos = this.state.start;\n            startLoc = this.state.startLoc;\n            this.next();\n\n            if (this.eat(56)) {\n              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n\n            children.push(this.jsxParseElementAt(startPos, startLoc));\n            break;\n\n          case 137:\n            children.push(this.parseExprAtom());\n            break;\n\n          case 5:\n            {\n              const node = this.startNode();\n              this.setContext(types.brace);\n              this.next();\n\n              if (this.match(21)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node, types.j_expr));\n              }\n\n              break;\n            }\n\n          default:\n            throw this.unexpected();\n        }\n      }\n\n      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {\n        this.raise(JsxErrors.MissingClosingTagFragment, {\n          at: closingElement\n        });\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(JsxErrors.MissingClosingTagElement, {\n          at: closingElement,\n          openingTagName: getQualifiedJSXName(openingElement.name)\n        });\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(JsxErrors.MissingClosingTagElement, {\n            at: closingElement,\n            openingTagName: getQualifiedJSXName(openingElement.name)\n          });\n        }\n      }\n    }\n\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n\n    node.children = children;\n\n    if (this.match(47)) {\n      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {\n        at: this.state.startLoc\n      });\n    }\n\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n\n  jsxParseElement() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startPos, startLoc);\n  }\n\n  setContext(newContext) {\n    const {\n      context\n    } = this.state;\n    context[context.length - 1] = newContext;\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(137)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(138)) {\n      return this.jsxParseElement();\n    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.replaceToken(138);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n\n  skipSpace() {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace) super.skipSpace();\n  }\n\n  getTokenFromCode(code) {\n    const context = this.curContext();\n\n    if (context === types.j_expr) {\n      return this.jsxReadToken();\n    }\n\n    if (context === types.j_oTag || context === types.j_cTag) {\n      if (isIdentifierStart(code)) {\n        return this.jsxReadWord();\n      }\n\n      if (code === 62) {\n        ++this.state.pos;\n        return this.finishToken(139);\n      }\n\n      if ((code === 34 || code === 39) && context === types.j_oTag) {\n        return this.jsxReadString(code);\n      }\n    }\n\n    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      return this.finishToken(138);\n    }\n\n    return super.getTokenFromCode(code);\n  }\n\n  updateContext(prevType) {\n    const {\n      context,\n      type\n    } = this.state;\n\n    if (type === 56 && prevType === 138) {\n      context.splice(-2, 2, types.j_cTag);\n      this.state.canStartJSXElement = false;\n    } else if (type === 138) {\n      context.push(types.j_oTag);\n    } else if (type === 139) {\n      const out = context[context.length - 1];\n\n      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {\n        context.pop();\n        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;\n      } else {\n        this.setContext(types.j_expr);\n        this.state.canStartJSXElement = true;\n      }\n    } else {\n      this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n    }\n  }\n\n});\n\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.types = new Set();\n    this.enums = new Set();\n    this.constEnums = new Set();\n    this.classes = new Set();\n    this.exportOnlyBindings = new Set();\n  }\n\n}\n\nclass TypeScriptScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new TypeScriptScope(flags);\n  }\n\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.add(name);\n      return;\n    }\n\n    super.declareName(name, bindingType, loc);\n\n    if (bindingType & BIND_KIND_TYPE) {\n      if (!(bindingType & BIND_KIND_VALUE)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n\n      scope.types.add(name);\n    }\n\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.add(name);\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.add(name);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (scope.enums.has(name)) {\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.has(name);\n        return isConst !== wasConst;\n      }\n\n      return true;\n    }\n\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {\n      if (scope.lexical.has(name)) {\n        return !!(bindingType & BIND_KIND_VALUE);\n      } else {\n        return false;\n      }\n    }\n\n    if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {\n      return true;\n    }\n\n    return super.isRedeclaredInScope(scope, name, bindingType);\n  }\n\n  checkLocalExport(id) {\n    const topLevelScope = this.scopeStack[0];\n    const {\n      name\n    } = id;\n\n    if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nconst getOwn$1 = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\n\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n\n  return x;\n}\n\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({\n    methodName\n  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName\n  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  AccesorCannotDeclareThisParameter: \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccesorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  CannotFindName: ({\n    name\n  }) => `Cannot find name '${name}'.`,\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({\n    kind\n  }) => `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier: ({\n    modifier\n  }) => `Accessibility modifier already seen.`,\n  DuplicateModifier: ({\n    modifier\n  }) => `Duplicate modifier: '${modifier}'.`,\n  EmptyHeritageClauseType: ({\n    token\n  }) => `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  IncompatibleModifiers: ({\n    modifiers\n  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({\n    modifier\n  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride: \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext: \"Initializers are not allowed in ambient contexts.\",\n  InvalidModifierOnTypeMember: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier\n  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers\n  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression: \"Invalid property access after an instantiation expression. \" + \"You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName: \"'interface' declarations must be followed by an identifier.\",\n  MixedLabeledAndUnlabeledElements: \"Tuple members must all have names or all not have names.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass: \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({\n    modifier\n  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam: \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion: \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  SetAccesorCannotHaveOptionalParameter: \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccesorCannotHaveRestParameter: \"A 'set' accessor cannot have rest parameter.\",\n  SetAccesorCannotHaveReturnType: \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName\n  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier: \"Static class blocks cannot have any modifier.\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed: \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports: \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports: \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({\n    type\n  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`\n});\n\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n\n    case \"never\":\n      return \"TSNeverKeyword\";\n\n    case \"number\":\n      return \"TSNumberKeyword\";\n\n    case \"object\":\n      return \"TSObjectKeyword\";\n\n    case \"string\":\n      return \"TSStringKeyword\";\n\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n\n    default:\n      return undefined;\n  }\n}\n\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\n\nfunction tsIsVarianceAnnotations(modifier) {\n  return modifier === \"in\" || modifier === \"out\";\n}\n\nvar typescript = (superClass => class TypeScriptParserMixin extends superClass {\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n\n  tsIsIdentifier() {\n    return tokenIsIdentifier(this.state.type);\n  }\n\n  tsTokenCanFollowModifier() {\n    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();\n  }\n\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return this.tsTokenCanFollowModifier();\n  }\n\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {\n    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58) {\n      return undefined;\n    }\n\n    const modifier = this.state.value;\n\n    if (allowedModifiers.indexOf(modifier) !== -1) {\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n        return undefined;\n      }\n\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n    }\n\n    return undefined;\n  }\n\n  tsParseModifiers({\n    modified,\n    allowedModifiers,\n    disallowedModifiers,\n    stopOnStartOfClassStaticBlock,\n    errorTemplate = TSErrors.InvalidModifierOnTypeMember\n  }) {\n    const enforceOrder = (loc, modifier, before, after) => {\n      if (modifier === before && modified[after]) {\n        this.raise(TSErrors.InvalidModifiersOrder, {\n          at: loc,\n          orderedModifiers: [before, after]\n        });\n      }\n    };\n\n    const incompatible = (loc, modifier, mod1, mod2) => {\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n        this.raise(TSErrors.IncompatibleModifiers, {\n          at: loc,\n          modifiers: [mod1, mod2]\n        });\n      }\n    };\n\n    for (;;) {\n      const {\n        startLoc\n      } = this.state;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);\n      if (!modifier) break;\n\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(TSErrors.DuplicateAccessibilityModifier, {\n            at: startLoc,\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, modifier, \"override\");\n          enforceOrder(startLoc, modifier, modifier, \"static\");\n          enforceOrder(startLoc, modifier, modifier, \"readonly\");\n          modified.accessibility = modifier;\n        }\n      } else if (tsIsVarianceAnnotations(modifier)) {\n        if (modified[modifier]) {\n          this.raise(TSErrors.DuplicateModifier, {\n            at: startLoc,\n            modifier\n          });\n        }\n\n        modified[modifier] = true;\n        enforceOrder(startLoc, modifier, \"in\", \"out\");\n      } else {\n        if (Object.hasOwnProperty.call(modified, modifier)) {\n          this.raise(TSErrors.DuplicateModifier, {\n            at: startLoc,\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"static\", \"override\");\n          enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n          incompatible(startLoc, modifier, \"declare\", \"override\");\n          incompatible(startLoc, modifier, \"static\", \"abstract\");\n        }\n\n        modified[modifier] = true;\n      }\n\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\n        this.raise(errorTemplate, {\n          at: startLoc,\n          modifier\n        });\n      }\n    }\n  }\n\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(8);\n\n      case \"HeritageClauseElement\":\n        return this.match(5);\n\n      case \"TupleElementTypes\":\n        return this.match(3);\n\n      case \"TypeParametersOrArguments\":\n        return this.match(48);\n    }\n\n    throw new Error(\"Unreachable\");\n  }\n\n  tsParseList(kind, parseElement) {\n    const result = [];\n\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n\n    return result;\n  }\n\n  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));\n  }\n\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\n    const result = [];\n    let trailingCommaPos = -1;\n\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      trailingCommaPos = -1;\n      const element = parseElement();\n\n      if (element == null) {\n        return undefined;\n      }\n\n      result.push(element);\n\n      if (this.eat(12)) {\n        trailingCommaPos = this.state.lastTokStart;\n        continue;\n      }\n\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      if (expectSuccess) {\n        this.expect(12);\n      }\n\n      return undefined;\n    }\n\n    if (refTrailingCommaPos) {\n      refTrailingCommaPos.value = trailingCommaPos;\n    }\n\n    return result;\n  }\n\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(0);\n      } else {\n        this.expect(47);\n      }\n    }\n\n    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\n\n    if (bracket) {\n      this.expect(3);\n    } else {\n      this.expect(48);\n    }\n\n    return result;\n  }\n\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(83);\n    this.expect(10);\n\n    if (!this.match(129)) {\n      this.raise(TSErrors.UnsupportedImportTypeArgument, {\n        at: this.state.startLoc\n      });\n    }\n\n    node.argument = super.parseExprAtom();\n    this.expect(11);\n\n    if (this.eat(16)) {\n      node.qualifier = this.tsParseEntityName();\n    }\n\n    if (this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSImportType\");\n  }\n\n  tsParseEntityName(allowReservedWords = true) {\n    let entity = this.parseIdentifier(allowReservedWords);\n\n    while (this.eat(16)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n\n    return entity;\n  }\n\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName();\n\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(87);\n\n    if (this.match(83)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName();\n    }\n\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n\n  tsParseInOutModifiers(node) {\n    this.tsParseModifiers({\n      modified: node,\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n  }\n\n  tsParseNoneModifiers(node) {\n    this.tsParseModifiers({\n      modified: node,\n      allowedModifiers: [],\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n  }\n\n  tsParseTypeParameter(parseModifiers = this.tsParseNoneModifiers.bind(this)) {\n    const node = this.startNode();\n    parseModifiers(node);\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsEatThenParseType(81);\n    node.default = this.tsEatThenParseType(29);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsTryParseTypeParameters(parseModifiers) {\n    if (this.match(47)) {\n      return this.tsParseTypeParameters(parseModifiers);\n    }\n  }\n\n  tsParseTypeParameters(parseModifiers) {\n    const node = this.startNode();\n\n    if (this.match(47) || this.match(138)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    const refTrailingCommaPos = {\n      value: -1\n    };\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);\n\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeParameters, {\n        at: node\n      });\n    }\n\n    if (refTrailingCommaPos.value !== -1) {\n      this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n    }\n\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n\n  tsTryNextParseConstantContext() {\n    if (this.lookahead().type !== 75) return null;\n    this.next();\n    const typeReference = this.tsParseTypeReference();\n\n    if (typeReference.typeParameters) {\n      this.raise(TSErrors.CannotFindName, {\n        at: typeReference.typeName,\n        name: \"const\"\n      });\n    }\n\n    return typeReference;\n  }\n\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === 19;\n    const paramsKey = \"parameters\";\n    const returnTypeKey = \"typeAnnotation\";\n    signature.typeParameters = this.tsTryParseTypeParameters();\n    this.expect(10);\n    signature[paramsKey] = this.tsParseBindingListForSignature();\n\n    if (returnTokenRequired) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n\n  tsParseBindingListForSignature() {\n    return super.parseBindingList(11, 41).map(pattern => {\n      if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\" && pattern.type !== \"ObjectPattern\" && pattern.type !== \"ArrayPattern\") {\n        this.raise(TSErrors.UnsupportedSignatureParameterKind, {\n          at: pattern,\n          type: pattern.type\n        });\n      }\n\n      return pattern;\n    });\n  }\n\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(12) && !this.isLineTerminator()) {\n      this.expect(13);\n    }\n  }\n\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(14, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n\n    if (tokenIsIdentifier(this.state.type)) {\n      this.next();\n      return this.match(14);\n    }\n\n    return false;\n  }\n\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return undefined;\n    }\n\n    this.expect(0);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(3);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(17)) node.optional = true;\n    const nodeAny = node;\n\n    if (this.match(10) || this.match(47)) {\n      if (readonly) {\n        this.raise(TSErrors.ReadonlyForMethodSignature, {\n          at: node\n        });\n      }\n\n      const method = nodeAny;\n\n      if (method.kind && this.match(47)) {\n        this.raise(TSErrors.AccesorCannotHaveTypeParameters, {\n          at: this.state.curPosition()\n        });\n      }\n\n      this.tsFillSignature(14, method);\n      this.tsParseTypeMemberSemicolon();\n      const paramsKey = \"parameters\";\n      const returnTypeKey = \"typeAnnotation\";\n\n      if (method.kind === \"get\") {\n        if (method[paramsKey].length > 0) {\n          this.raise(Errors.BadGetterArity, {\n            at: this.state.curPosition()\n          });\n\n          if (this.isThisParam(method[paramsKey][0])) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n              at: this.state.curPosition()\n            });\n          }\n        }\n      } else if (method.kind === \"set\") {\n        if (method[paramsKey].length !== 1) {\n          this.raise(Errors.BadSetterArity, {\n            at: this.state.curPosition()\n          });\n        } else {\n          const firstParameter = method[paramsKey][0];\n\n          if (this.isThisParam(firstParameter)) {\n            this.raise(TSErrors.AccesorCannotDeclareThisParameter, {\n              at: this.state.curPosition()\n            });\n          }\n\n          if (firstParameter.type === \"Identifier\" && firstParameter.optional) {\n            this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {\n              at: this.state.curPosition()\n            });\n          }\n\n          if (firstParameter.type === \"RestElement\") {\n            this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {\n              at: this.state.curPosition()\n            });\n          }\n        }\n\n        if (method[returnTypeKey]) {\n          this.raise(TSErrors.SetAccesorCannotHaveReturnType, {\n            at: method[returnTypeKey]\n          });\n        }\n      } else {\n        method.kind = \"method\";\n      }\n\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n\n  tsParseTypeMember() {\n    const node = this.startNode();\n\n    if (this.match(10) || this.match(47)) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n\n    if (this.match(77)) {\n      const id = this.startNode();\n      this.next();\n\n      if (this.match(10) || this.match(47)) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n\n    this.tsParseModifiers({\n      modified: node,\n      allowedModifiers: [\"readonly\"],\n      disallowedModifiers: [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\", \"override\"]\n    });\n    const idx = this.tsTryParseIndexSignature(node);\n\n    if (idx) {\n      return idx;\n    }\n\n    super.parsePropertyName(node);\n\n    if (!node.computed && node.key.type === \"Identifier\" && (node.key.name === \"get\" || node.key.name === \"set\") && this.tsTokenCanFollowModifier()) {\n      node.kind = node.key.name;\n      super.parsePropertyName(node);\n    }\n\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n\n  tsParseObjectTypeMembers() {\n    this.expect(5);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(8);\n    return members;\n  }\n\n  tsIsStartOfMappedType() {\n    this.next();\n\n    if (this.eat(53)) {\n      return this.isContextual(118);\n    }\n\n    if (this.isContextual(118)) {\n      this.next();\n    }\n\n    if (!this.match(0)) {\n      return false;\n    }\n\n    this.next();\n\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n\n    this.next();\n    return this.match(58);\n  }\n\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsExpectThenParseType(58);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(5);\n\n    if (this.match(53)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(118);\n    } else if (this.eatContextual(118)) {\n      node.readonly = true;\n    }\n\n    this.expect(0);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;\n    this.expect(3);\n\n    if (this.match(53)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(17);\n    } else if (this.eat(17)) {\n      node.optional = true;\n    }\n\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(8);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    let labeledElements = null;\n    node.elementTypes.forEach(elementNode => {\n      var _labeledElements;\n\n      const {\n        type\n      } = elementNode;\n\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(TSErrors.OptionalTypeBeforeRequired, {\n          at: elementNode\n        });\n      }\n\n      seenOptionalElement || (seenOptionalElement = type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\");\n      let checkType = type;\n\n      if (type === \"TSRestType\") {\n        elementNode = elementNode.typeAnnotation;\n        checkType = elementNode.type;\n      }\n\n      const isLabeled = checkType === \"TSNamedTupleMember\";\n      (_labeledElements = labeledElements) != null ? _labeledElements : labeledElements = isLabeled;\n\n      if (labeledElements !== isLabeled) {\n        this.raise(TSErrors.MixedLabeledAndUnlabeledElements, {\n          at: elementNode\n        });\n      }\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n\n  tsParseTupleElementType() {\n    const {\n      start: startPos,\n      startLoc\n    } = this.state;\n    const rest = this.eat(21);\n    let type = this.tsParseType();\n    const optional = this.eat(17);\n    const labeled = this.eat(14);\n\n    if (labeled) {\n      const labeledNode = this.startNodeAtNode(type);\n      labeledNode.optional = optional;\n\n      if (type.type === \"TSTypeReference\" && !type.typeParameters && type.typeName.type === \"Identifier\") {\n        labeledNode.label = type.typeName;\n      } else {\n        this.raise(TSErrors.InvalidTupleMemberLabel, {\n          at: type\n        });\n        labeledNode.label = type;\n      }\n\n      labeledNode.elementType = this.tsParseType();\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n\n    if (rest) {\n      const restNode = this.startNodeAt(startPos, startLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n\n    return type;\n  }\n\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(10);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(11);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n\n  tsParseFunctionOrConstructorType(type, abstract) {\n    const node = this.startNode();\n\n    if (type === \"TSConstructorType\") {\n      node.abstract = !!abstract;\n      if (abstract) this.next();\n      this.next();\n    }\n\n    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));\n    return this.finishNode(node, type);\n  }\n\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n\n    node.literal = (() => {\n      switch (this.state.type) {\n        case 130:\n        case 131:\n        case 129:\n        case 85:\n        case 86:\n          return super.parseExprAtom();\n\n        default:\n          throw this.unexpected();\n      }\n    })();\n\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = super.parseTemplate(false);\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n\n    if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case 129:\n      case 130:\n      case 131:\n      case 85:\n      case 86:\n        return this.tsParseLiteralTypeNode();\n\n      case 53:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n\n          if (nextToken.type !== 130 && nextToken.type !== 131) {\n            throw this.unexpected();\n          }\n\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n\n        break;\n\n      case 78:\n        return this.tsParseThisTypeOrThisTypePredicate();\n\n      case 87:\n        return this.tsParseTypeQuery();\n\n      case 83:\n        return this.tsParseImportType();\n\n      case 5:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n\n      case 0:\n        return this.tsParseTupleType();\n\n      case 10:\n        return this.tsParseParenthesizedType();\n\n      case 25:\n      case 24:\n        return this.tsParseTemplateLiteralType();\n\n      default:\n        {\n          const {\n            type\n          } = this.state;\n\n          if (tokenIsIdentifier(type) || type === 88 || type === 84) {\n            const nodeType = type === 88 ? \"TSVoidKeyword\" : type === 84 ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n\n            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {\n              const node = this.startNode();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n\n            return this.tsParseTypeReference();\n          }\n        }\n    }\n\n    throw this.unexpected();\n  }\n\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\n      if (this.match(3)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(3);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(3);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n\n    return type;\n  }\n\n  tsParseTypeOperator() {\n    const node = this.startNode();\n    const operator = this.state.value;\n    this.next();\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n\n      default:\n        this.raise(TSErrors.UnexpectedReadonly, {\n          at: node\n        });\n    }\n  }\n\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(112);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n\n  tsParseConstraintForInferType() {\n    if (this.eat(81)) {\n      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\n\n      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {\n        return constraint;\n      }\n    }\n  }\n\n  tsParseTypeOperatorOrHigher() {\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\n  }\n\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types = [];\n\n    do {\n      types.push(parseConstituentType());\n    } while (this.eat(operator));\n\n    if (types.length === 1 && !hasLeadingOperator) {\n      return types[0];\n    }\n\n    node.types = types;\n    return this.finishNode(node, kind);\n  }\n\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), 45);\n  }\n\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), 43);\n  }\n\n  tsIsStartOfFunctionType() {\n    if (this.match(47)) {\n      return true;\n    }\n\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n\n  tsSkipParameterStart() {\n    if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n      this.next();\n      return true;\n    }\n\n    if (this.match(5)) {\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n\n      try {\n        this.parseObjectLike(8, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused) {\n        return false;\n      }\n    }\n\n    if (this.match(0)) {\n      this.next();\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n\n      try {\n        super.parseBindingList(3, 93, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused2) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n\n    if (this.match(11) || this.match(21)) {\n      return true;\n    }\n\n    if (this.tsSkipParameterStart()) {\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {\n        return true;\n      }\n\n      if (this.match(11)) {\n        this.next();\n\n        if (this.match(19)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n\n      if (asserts && this.match(78)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          node.typeAnnotation = null;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        node.typeAnnotation = null;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : undefined;\n  }\n\n  tsTryParseTypeAnnotation() {\n    return this.match(14) ? this.tsParseTypeAnnotation() : undefined;\n  }\n\n  tsTryParseType() {\n    return this.tsEatThenParseType(14);\n  }\n\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n\n    if (this.isContextual(113) && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n\n  tsParseTypePredicateAsserts() {\n    if (this.state.type !== 106) {\n      return false;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    this.next();\n\n    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {\n      return false;\n    }\n\n    if (containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, {\n        at: this.state.lastTokStartLoc,\n        reservedWord: \"asserts\"\n      });\n    }\n\n    return true;\n  }\n\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(14);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n\n    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {\n      return type;\n    }\n\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());\n    this.expect(17);\n    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    this.expect(14);\n    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n\n  isAbstractConstructorSignature() {\n    return this.isContextual(120) && this.lookahead().type === 77;\n  }\n\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n\n    if (this.match(77)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    } else if (this.isAbstractConstructorSignature()) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\", true);\n    }\n\n    return this.tsParseUnionTypeOrHigher();\n  }\n\n  tsParseTypeAssertion() {\n    if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedTypeAssertion, {\n        at: this.state.startLoc\n      });\n    }\n\n    const node = this.startNode();\n\n    const _const = this.tsTryNextParseConstantContext();\n\n    node.typeAnnotation = _const || this.tsNextThenParseType();\n    this.expect(48);\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n\n  tsParseHeritageClause(token) {\n    const originalStartLoc = this.state.startLoc;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", () => {\n      const node = this.startNode();\n      node.expression = this.tsParseEntityName();\n\n      if (this.match(47)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n\n      return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n    });\n\n    if (!delimitedList.length) {\n      this.raise(TSErrors.EmptyHeritageClauseType, {\n        at: originalStartLoc,\n        token\n      });\n    }\n\n    return delimitedList;\n  }\n\n  tsParseInterfaceDeclaration(node, properties = {}) {\n    if (this.hasFollowingLineBreak()) return null;\n    this.expectContextual(125);\n    if (properties.declare) node.declare = true;\n\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, BIND_TS_INTERFACE);\n    } else {\n      node.id = null;\n      this.raise(TSErrors.MissingInterfaceName, {\n        at: this.state.startLoc\n      });\n    }\n\n    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n\n    if (this.eat(81)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, BIND_TS_TYPE);\n    node.typeAnnotation = this.tsInType(() => {\n      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n      this.expect(29);\n\n      if (this.isContextual(111) && this.lookahead().type !== 16) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSIntrinsicKeyword\");\n      }\n\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n\n  tsInDisallowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n\n  tsInAllowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = false;\n\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n\n  tsEatThenParseType(token) {\n    return !this.match(token) ? undefined : this.tsNextThenParseType();\n  }\n\n  tsExpectThenParseType(token) {\n    return this.tsDoThenParseType(() => this.expect(token));\n  }\n\n  tsNextThenParseType() {\n    return this.tsDoThenParseType(() => this.next());\n  }\n\n  tsDoThenParseType(cb) {\n    return this.tsInType(() => {\n      cb();\n      return this.tsParseType();\n    });\n  }\n\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(129) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);\n\n    if (this.eat(29)) {\n      node.initializer = super.parseMaybeAssignAllowIn();\n    }\n\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n\n  tsParseEnumDeclaration(node, properties = {}) {\n    if (properties.const) node.const = true;\n    if (properties.declare) node.declare = true;\n    this.expectContextual(122);\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, node.const ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(5);\n    super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n\n    if (!nested) {\n      this.checkIdentifier(node.id, BIND_TS_NAMESPACE);\n    }\n\n    if (this.eat(16)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(109)) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(129)) {\n      node.id = super.parseStringLiteral(this.state.value);\n    } else {\n      this.unexpected();\n    }\n\n    if (this.match(5)) {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseImportEqualsDeclaration(node, isExport) {\n    node.isExport = isExport || false;\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, BIND_LEXICAL);\n    this.expect(29);\n    const moduleReference = this.tsParseModuleReference();\n\n    if (node.importKind === \"type\" && moduleReference.type !== \"TSExternalModuleReference\") {\n      this.raise(TSErrors.ImportAliasHasImportType, {\n        at: moduleReference\n      });\n    }\n\n    node.moduleReference = moduleReference;\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n\n  tsIsExternalModuleReference() {\n    return this.isContextual(116) && this.lookaheadCharCode() === 40;\n  }\n\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(116);\n    this.expect(10);\n\n    if (!this.match(129)) {\n      throw this.unexpected();\n    }\n\n    node.expression = super.parseExprAtom();\n    this.expect(11);\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return undefined;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n\n    if (result !== undefined && result !== false) {\n      return result;\n    } else {\n      this.state = state;\n      return undefined;\n    }\n  }\n\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n\n    let starttype = this.state.type;\n    let kind;\n\n    if (this.isContextual(99)) {\n      starttype = 74;\n      kind = \"let\";\n    }\n\n    return this.tsInAmbientContext(() => {\n      if (starttype === 68) {\n        nany.declare = true;\n        return super.parseFunctionStatement(nany, false, true);\n      }\n\n      if (starttype === 80) {\n        nany.declare = true;\n        return this.parseClass(nany, true, false);\n      }\n\n      if (starttype === 122) {\n        return this.tsParseEnumDeclaration(nany, {\n          declare: true\n        });\n      }\n\n      if (starttype === 109) {\n        return this.tsParseAmbientExternalModuleDeclaration(nany);\n      }\n\n      if (starttype === 75 || starttype === 74) {\n        if (!this.match(75) || !this.isLookaheadContextual(\"enum\")) {\n          nany.declare = true;\n          return this.parseVarStatement(nany, kind || this.state.value, true);\n        }\n\n        this.expect(75);\n        return this.tsParseEnumDeclaration(nany, {\n          const: true,\n          declare: true\n        });\n      }\n\n      if (starttype === 125) {\n        const result = this.tsParseInterfaceDeclaration(nany, {\n          declare: true\n        });\n        if (result) return result;\n      }\n\n      if (tokenIsIdentifier(starttype)) {\n        return this.tsParseDeclaration(nany, this.state.value, true);\n      }\n    });\n  }\n\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true);\n  }\n\n  tsParseExpressionStatement(node, expr) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n\n          break;\n        }\n\n      case \"global\":\n        if (this.match(5)) {\n          this.scope.enter(SCOPE_TS_MODULE);\n          this.prodParam.enter(PARAM);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n\n        break;\n\n      default:\n        return this.tsParseDeclaration(node, expr.name, false);\n    }\n  }\n\n  tsParseDeclaration(node, value, next) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {\n          return this.tsParseAbstractDeclaration(node);\n        }\n\n        break;\n\n      case \"module\":\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(129)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n\n        break;\n\n      case \"namespace\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n\n        break;\n\n      case \"type\":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n\n        break;\n    }\n  }\n\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak()) return false;\n      this.next();\n      return true;\n    }\n\n    return !this.isLineTerminator();\n  }\n\n  tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {\n    if (!this.match(47)) {\n      return undefined;\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.typeParameters = this.tsParseTypeParameters();\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(19);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    if (!res) {\n      return undefined;\n    }\n\n    return super.parseArrowExpression(res, null, true);\n  }\n\n  tsParseTypeArgumentsInExpression() {\n    if (this.reScan_lt() !== 47) {\n      return undefined;\n    }\n\n    return this.tsParseTypeArguments();\n  }\n\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expect(47);\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeArguments, {\n        at: node\n      });\n    }\n\n    this.expect(48);\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n\n  tsIsDeclarationStart() {\n    return tokenIsTSDeclarationStart(this.state.type);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let accessibility;\n    let readonly = false;\n    let override = false;\n\n    if (allowModifiers !== undefined) {\n      const modified = {};\n      this.tsParseModifiers({\n        modified,\n        allowedModifiers: [\"public\", \"private\", \"protected\", \"override\", \"readonly\"]\n      });\n      accessibility = modified.accessibility;\n      override = modified.override;\n      readonly = modified.readonly;\n\n      if (allowModifiers === false && (accessibility || readonly || override)) {\n        this.raise(TSErrors.UnexpectedParameterModifier, {\n          at: startLoc\n        });\n      }\n    }\n\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (accessibility || readonly || override) {\n      const pp = this.startNodeAt(startPos, startLoc);\n\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n      if (override) pp.override = override;\n\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(TSErrors.UnsupportedParameterPropertyKind, {\n          at: pp\n        });\n      }\n\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  isSimpleParameter(node) {\n    return node.type === \"TSParameterProperty\" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" || type === \"ClassPrivateMethod\" ? \"TSDeclareMethod\" : undefined;\n\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\n      return this.finishNode(node, bodilessType);\n    }\n\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n      this.raise(TSErrors.DeclareFunctionHasImplementation, {\n        at: node\n      });\n\n      if (node.declare) {\n        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n      }\n    }\n\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkIdentifier(node.id, BIND_TS_AMBIENT);\n    } else {\n      super.registerFunctionStatementId(node);\n    }\n  }\n\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(TSErrors.UnexpectedTypeAnnotation, {\n          at: node.typeAnnotation\n        });\n      }\n    });\n  }\n\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n\n    return node;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(35)) {\n      this.state.canStartJSXElement = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startPos, startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n\n    let isOptionalCall = false;\n\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\n      if (noCalls) {\n        state.stop = true;\n        return base;\n      }\n\n      state.optionalChainMember = isOptionalCall = true;\n      this.next();\n    }\n\n    if (this.match(47) || this.match(51)) {\n      let missingParenErrorLoc;\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);\n\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n        if (!typeArguments) return;\n\n        if (isOptionalCall && !this.match(10)) {\n          missingParenErrorLoc = this.state.curPosition();\n          return;\n        }\n\n        if (tokenIsTemplate(this.state.type)) {\n          const result = super.parseTaggedTemplateExpression(base, startPos, startLoc, state);\n          result.typeParameters = typeArguments;\n          return result;\n        }\n\n        if (!noCalls && this.eat(10)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.callee = base;\n          node.arguments = this.parseCallExpressionArguments(11, false);\n          this.tsCheckForInvalidTypeCasts(node.arguments);\n          node.typeParameters = typeArguments;\n\n          if (state.optionalChainMember) {\n            node.optional = isOptionalCall;\n          }\n\n          return this.finishCallExpression(node, state.optionalChainMember);\n        }\n\n        const tokenType = this.state.type;\n\n        if (tokenType === 48 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {\n          return;\n        }\n\n        const node = this.startNodeAt(startPos, startLoc);\n        node.expression = base;\n        node.typeParameters = typeArguments;\n        return this.finishNode(node, \"TSInstantiationExpression\");\n      });\n\n      if (missingParenErrorLoc) {\n        this.unexpected(missingParenErrorLoc, 10);\n      }\n\n      if (result) {\n        if (result.type === \"TSInstantiationExpression\" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {\n          this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {\n            at: this.state.startLoc\n          });\n        }\n\n        return result;\n      }\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, state);\n  }\n\n  parseNewCallee(node) {\n    var _callee$extra;\n\n    super.parseNewCallee(node);\n    const {\n      callee\n    } = node;\n\n    if (callee.type === \"TSInstantiationExpression\" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {\n      node.typeParameters = callee.typeParameters;\n      node.callee = callee.expression;\n    }\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {\n    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(93)) {\n      const node = this.startNodeAt(leftStartPos, leftStartLoc);\n      node.expression = left;\n\n      const _const = this.tsTryNextParseConstantContext();\n\n      if (_const) {\n        node.typeAnnotation = _const;\n      } else {\n        node.typeAnnotation = this.tsNextThenParseType();\n      }\n\n      this.finishNode(node, \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n    }\n\n    return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (!this.state.isAmbientContext) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n\n  checkDuplicateExports() {}\n\n  parseImport(node) {\n    node.importKind = \"value\";\n\n    if (tokenIsIdentifier(this.state.type) || this.match(55) || this.match(5)) {\n      let ahead = this.lookahead();\n\n      if (this.isContextual(126) && ahead.type !== 12 && ahead.type !== 97 && ahead.type !== 29) {\n        node.importKind = \"type\";\n        this.next();\n        ahead = this.lookahead();\n      }\n\n      if (tokenIsIdentifier(this.state.type) && ahead.type === 29) {\n        return this.tsParseImportEqualsDeclaration(node);\n      }\n    }\n\n    const importNode = super.parseImport(node);\n\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {\n        at: importNode\n      });\n    }\n\n    return importNode;\n  }\n\n  parseExport(node) {\n    if (this.match(83)) {\n      this.next();\n\n      if (this.isContextual(126) && this.lookaheadCharCode() !== 61) {\n        node.importKind = \"type\";\n        this.next();\n      } else {\n        node.importKind = \"value\";\n      }\n\n      return this.tsParseImportEqualsDeclaration(node, true);\n    } else if (this.eat(29)) {\n      const assign = node;\n      assign.expression = super.parseExpression();\n      this.semicolon();\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(93)) {\n      const decl = node;\n      this.expectContextual(124);\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      if (this.isContextual(126) && this.lookahead().type === 5) {\n        this.next();\n        node.exportKind = \"type\";\n      } else {\n        node.exportKind = \"value\";\n      }\n\n      return super.parseExport(node);\n    }\n  }\n\n  isAbstractClass() {\n    return this.isContextual(120) && this.lookahead().type === 80;\n  }\n\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      return this.parseClass(cls, true, true);\n    }\n\n    if (this.match(125)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    const {\n      isAmbientContext\n    } = this.state;\n    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);\n    if (!isAmbientContext) return declaration;\n\n    for (const {\n      id,\n      init\n    } of declaration.declarations) {\n      if (!init) continue;\n\n      if (kind !== \"const\" || !!id.typeAnnotation) {\n        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {\n          at: init\n        });\n      } else if (init.type !== \"StringLiteral\" && init.type !== \"BooleanLiteral\" && init.type !== \"NumericLiteral\" && init.type !== \"BigIntLiteral\" && (init.type !== \"TemplateLiteral\" || init.expressions.length > 0) && !isPossiblyLiteralEnum(init)) {\n        this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {\n          at: init\n        });\n      }\n    }\n\n    return declaration;\n  }\n\n  parseStatementContent(context, topLevel) {\n    if (this.match(75) && this.isLookaheadContextual(\"enum\")) {\n      const node = this.startNode();\n      this.expect(75);\n      return this.tsParseEnumDeclaration(node, {\n        const: true\n      });\n    }\n\n    if (this.isContextual(122)) {\n      return this.tsParseEnumDeclaration(this.startNode());\n    }\n\n    if (this.isContextual(125)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n\n    return super.parseStatementContent(context, topLevel);\n  }\n\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n\n  tsHasSomeModifiers(member, modifiers) {\n    return modifiers.some(modifier => {\n      if (tsIsAccessModifier(modifier)) {\n        return member.accessibility === modifier;\n      }\n\n      return !!member[modifier];\n    });\n  }\n\n  tsIsStartOfStaticBlocks() {\n    return this.isContextual(104) && this.lookaheadCharCode() === 123;\n  }\n\n  parseClassMember(classBody, member, state) {\n    const modifiers = [\"declare\", \"private\", \"public\", \"protected\", \"override\", \"abstract\", \"readonly\", \"static\"];\n    this.tsParseModifiers({\n      modified: member,\n      allowedModifiers: modifiers,\n      disallowedModifiers: [\"in\", \"out\"],\n      stopOnStartOfClassStaticBlock: true,\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n\n    const callParseClassMemberWithIsStatic = () => {\n      if (this.tsIsStartOfStaticBlocks()) {\n        this.next();\n        this.next();\n\n        if (this.tsHasSomeModifiers(member, modifiers)) {\n          this.raise(TSErrors.StaticBlockCannotHaveModifier, {\n            at: this.state.curPosition()\n          });\n        }\n\n        super.parseClassStaticBlock(classBody, member);\n      } else {\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\n      }\n    };\n\n    if (member.declare) {\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n    } else {\n      callParseClassMemberWithIsStatic();\n    }\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const idx = this.tsTryParseIndexSignature(member);\n\n    if (idx) {\n      classBody.body.push(idx);\n\n      if (member.abstract) {\n        this.raise(TSErrors.IndexSignatureHasAbstract, {\n          at: member\n        });\n      }\n\n      if (member.accessibility) {\n        this.raise(TSErrors.IndexSignatureHasAccessibility, {\n          at: member,\n          modifier: member.accessibility\n        });\n      }\n\n      if (member.declare) {\n        this.raise(TSErrors.IndexSignatureHasDeclare, {\n          at: member\n        });\n      }\n\n      if (member.override) {\n        this.raise(TSErrors.IndexSignatureHasOverride, {\n          at: member\n        });\n      }\n\n      return;\n    }\n\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {\n        at: member\n      });\n    }\n\n    if (member.override) {\n      if (!state.hadSuperClass) {\n        this.raise(TSErrors.OverrideNotInSubClass, {\n          at: member\n        });\n      }\n    }\n\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(17);\n    if (optional) methodOrProp.optional = true;\n\n    if (methodOrProp.readonly && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasReadonly, {\n        at: methodOrProp\n      });\n    }\n\n    if (methodOrProp.declare && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasDeclare, {\n        at: methodOrProp\n      });\n    }\n  }\n\n  parseExpressionStatement(node, expr) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr) : undefined;\n    return decl || super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n\n  parseConditional(expr, startPos, startLoc, refExpressionErrors) {\n    if (!this.state.maybeInArrowParameters || !this.match(17)) {\n      return super.parseConditional(expr, startPos, startLoc, refExpressionErrors);\n    }\n\n    const result = this.tryParse(() => super.parseConditional(expr, startPos, startLoc));\n\n    if (!result.node) {\n      if (result.error) {\n        super.setOptionalParametersError(refExpressionErrors, result.error);\n      }\n\n      return expr;\n    }\n\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(17)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  parseExportDeclaration(node) {\n    if (!this.state.isAmbientContext && this.isContextual(121)) {\n      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(121);\n\n    if (isDeclare && (this.isContextual(121) || !this.shouldParseExportDeclaration())) {\n      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {\n        at: this.state.startLoc\n      });\n    }\n\n    const isIdentifier = tokenIsIdentifier(this.state.type);\n    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);\n    if (!declaration) return null;\n\n    if (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare) {\n      node.exportKind = \"type\";\n    }\n\n    if (isDeclare) {\n      this.resetStartLocation(declaration, startPos, startLoc);\n      declaration.declare = true;\n    }\n\n    return declaration;\n  }\n\n  parseClassId(node, isStatement, optionalId, bindingType) {\n    if ((!isStatement || optionalId) && this.isContextual(110)) {\n      return;\n    }\n\n    super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional && this.eat(35)) {\n      node.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n\n    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {\n      this.raise(TSErrors.DeclareClassFieldHasInitializer, {\n        at: this.state.startLoc\n      });\n    }\n\n    if (node.abstract && this.match(29)) {\n      const {\n        key\n      } = node;\n      this.raise(TSErrors.AbstractPropertyHasInitializer, {\n        at: this.state.startLoc,\n        propertyName: key.type === \"Identifier\" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n      });\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(TSErrors.PrivateElementHasAbstract, {\n        at: node\n      });\n    }\n\n    if (node.accessibility) {\n      this.raise(TSErrors.PrivateElementHasAccessibility, {\n        at: node,\n        modifier: node.accessibility\n      });\n    }\n\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters();\n\n    if (typeParameters && isConstructor) {\n      this.raise(TSErrors.ConstructorHasTypeParameters, {\n        at: typeParameters\n      });\n    }\n\n    const {\n      declare = false,\n      kind\n    } = method;\n\n    if (declare && (kind === \"get\" || kind === \"set\")) {\n      this.raise(TSErrors.DeclareAccessor, {\n        at: method,\n        kind\n      });\n    }\n\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  declareClassPrivateMethodInScope(node, kind) {\n    if (node.type === \"TSDeclareMethod\") return;\n    if (node.type === \"MethodDefinition\" && !node.value.body) return;\n    super.declareClassPrivateMethodInScope(node, kind);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n    }\n\n    if (this.eatContextual(110)) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) prop.typeParameters = typeParameters;\n    return super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (decl.id.type === \"Identifier\" && !this.hasPrecedingLineBreak() && this.eat(35)) {\n      decl.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2, _jsx4, _typeCast3;\n\n    let state;\n    let jsx;\n    let typeCast;\n\n    if (this.hasPlugin(\"jsx\") && (this.match(138) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n\n    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n\n    if (!state || state === this.state) state = this.state.clone();\n    let typeParameters;\n    const arrow = this.tryParse(abort => {\n      var _expr$extra, _typeParameters;\n\n      typeParameters = this.tsParseTypeParameters();\n      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n\n      if (expr.type !== \"ArrowFunctionExpression\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n        abort();\n      }\n\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n\n    if (!arrow.error && !arrow.aborted) {\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n\n    if ((_jsx2 = jsx) != null && _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n\n    if (arrow.node) {\n      this.state = arrow.failState;\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n\n    if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n    if (arrow.thrown) throw arrow.error;\n    if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error;\n    throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);\n  }\n\n  reportReservedArrowTypeParam(node) {\n    var _node$extra;\n\n    if (node.params.length === 1 && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedArrowTypeParam, {\n        at: node\n      });\n    }\n  }\n\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    if (!this.hasPlugin(\"jsx\") && this.match(47)) {\n      return this.tsParseTypeAssertion();\n    } else {\n      return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n    }\n  }\n\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n        if (this.canInsertSemicolon() || !this.match(19)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n\n    return super.parseArrow(node);\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\" && !this.state.isAmbientContext && !this.state.inType) {\n        this.raise(TSErrors.PatternIsOptional, {\n          at: param\n        });\n      }\n\n      param.optional = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return this.isAssignable(node.expression, isBinding);\n\n      case \"TSParameterProperty\":\n        return true;\n\n      default:\n        return super.isAssignable(node, isBinding);\n    }\n  }\n\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.toAssignableParenthesizedExpression(node, isLHS);\n        break;\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        if (isLHS) {\n          this.expressionScope.recordArrowParemeterBindingError(TSErrors.UnexpectedTypeCastInParameter, {\n            at: node\n          });\n        } else {\n          this.raise(TSErrors.UnexpectedTypeCastInParameter, {\n            at: node\n          });\n        }\n\n        this.toAssignable(node.expression, isLHS);\n        break;\n\n      case \"AssignmentExpression\":\n        if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n          node.left = this.typeCastToParameter(node.left);\n        }\n\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n\n  toAssignableParenthesizedExpression(node, isLHS) {\n    switch (node.expression.type) {\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isLHS);\n        break;\n\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"TSAsExpression\":\n      case \"TSTypeAssertion\":\n      case \"TSNonNullExpression\":\n        this.checkToRestConversion(node.expression, false);\n        break;\n\n      default:\n        super.checkToRestConversion(node, allowPattern);\n    }\n  }\n\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return getOwn$1({\n      TSTypeCastExpression: true,\n      TSParameterProperty: \"parameter\",\n      TSNonNullExpression: \"expression\",\n      TSAsExpression: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && [\"expression\", true],\n      TSTypeAssertion: (binding !== BIND_NONE || !isUnparenthesizedInAssign) && [\"expression\", true]\n    }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsParseTypeArgumentsInExpression();\n\n      if (this.match(10)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n\n      this.unexpected(null, 10);\n    }\n\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n\n  checkCommaAfterRest(close) {\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\n      this.next();\n      return false;\n    } else {\n      return super.checkCommaAfterRest(close);\n    }\n  }\n\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(35) || this.match(14) || super.isClassProperty();\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(TSErrors.TypeAnnotationAfterAssign, {\n        at: node.typeAnnotation\n      });\n    }\n\n    return node;\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inType) {\n      if (code === 62) {\n        return this.finishOp(48, 1);\n      }\n\n      if (code === 60) {\n        return this.finishOp(47, 1);\n      }\n    }\n\n    return super.getTokenFromCode(code);\n  }\n\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n\n    return type;\n  }\n\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if ((expr == null ? void 0 : expr.type) === \"TSTypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  shouldParseArrow(params) {\n    if (this.match(14)) {\n      return params.every(expr => this.isAssignable(expr, true));\n    }\n\n    return super.shouldParseArrow(params);\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());\n      if (typeArguments) node.typeParameters = typeArguments;\n    }\n\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n\n    return param;\n  }\n\n  tsInAmbientContext(cb) {\n    const oldIsAmbientContext = this.state.isAmbientContext;\n    this.state.isAmbientContext = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.isAmbientContext = oldIsAmbientContext;\n    }\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n\n    try {\n      return super.parseClass(node, isStatement, optionalId);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n\n  tsParseAbstractDeclaration(node) {\n    if (this.match(80)) {\n      node.abstract = true;\n      return this.parseClass(node, true, false);\n    } else if (this.isContextual(125)) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {\n          at: node\n        });\n        return this.tsParseInterfaceDeclaration(node);\n      }\n    } else {\n      this.unexpected(null, 80);\n    }\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {\n    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n\n    if (method.abstract) {\n      const hasBody = this.hasPlugin(\"estree\") ? !!method.value.body : !!method.body;\n\n      if (hasBody) {\n        const {\n          key\n        } = method;\n        this.raise(TSErrors.AbstractMethodHasImplementation, {\n          at: method,\n          methodName: key.type === \"Identifier\" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`\n        });\n      }\n    }\n\n    return method;\n  }\n\n  tsParseTypeParameterName() {\n    const typeName = this.parseIdentifier();\n    return typeName.name;\n  }\n\n  shouldParseAsAmbientContext() {\n    return !!this.getPluginOption(\"typescript\", \"dts\");\n  }\n\n  parse() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n\n    return super.parse();\n  }\n\n  getExpression() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n\n    return super.getExpression();\n  }\n\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (!isString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);\n      return this.finishNode(node, \"ExportSpecifier\");\n    }\n\n    node.exportKind = \"value\";\n    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);\n  }\n\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {\n    if (!importedIsString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);\n      return this.finishNode(specifier, \"ImportSpecifier\");\n    }\n\n    specifier.importKind = \"value\";\n    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly);\n  }\n\n  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\n    const leftOfAsKey = isImport ? \"imported\" : \"local\";\n    const rightOfAsKey = isImport ? \"local\" : \"exported\";\n    let leftOfAs = node[leftOfAsKey];\n    let rightOfAs;\n    let hasTypeSpecifier = false;\n    let canParseAsKeyword = true;\n    const loc = leftOfAs.loc.start;\n\n    if (this.isContextual(93)) {\n      const firstAs = this.parseIdentifier();\n\n      if (this.isContextual(93)) {\n        const secondAs = this.parseIdentifier();\n\n        if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n          canParseAsKeyword = false;\n        } else {\n          rightOfAs = secondAs;\n          canParseAsKeyword = false;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        canParseAsKeyword = false;\n        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n      } else {\n        hasTypeSpecifier = true;\n        leftOfAs = firstAs;\n      }\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      hasTypeSpecifier = true;\n\n      if (isImport) {\n        leftOfAs = this.parseIdentifier(true);\n\n        if (!this.isContextual(93)) {\n          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);\n        }\n      } else {\n        leftOfAs = this.parseModuleExportName();\n      }\n    }\n\n    if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {\n        at: loc\n      });\n    }\n\n    node[leftOfAsKey] = leftOfAs;\n    node[rightOfAsKey] = rightOfAs;\n    const kindKey = isImport ? \"importKind\" : \"exportKind\";\n    node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n\n    if (canParseAsKeyword && this.eatContextual(93)) {\n      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n    }\n\n    if (!node[rightOfAsKey]) {\n      node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n    }\n\n    if (isImport) {\n      this.checkIdentifier(node[rightOfAsKey], BIND_LEXICAL);\n    }\n  }\n\n});\n\nfunction isPossiblyLiteralEnum(expression) {\n  if (expression.type !== \"MemberExpression\") return false;\n  const {\n    computed,\n    property\n  } = expression;\n\n  if (computed && property.type !== \"StringLiteral\" && (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)) {\n    return false;\n  }\n\n  return isUncomputedMemberExpressionChain(expression.object);\n}\n\nfunction isUncomputedMemberExpressionChain(expression) {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\") return false;\n  if (expression.computed) return false;\n  return isUncomputedMemberExpressionChain(expression.object);\n}\n\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\"\n});\nvar placeholders = (superClass => class PlaceholdersParserMixin extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(140)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace();\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace();\n      this.expect(140);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      return this.finishOp(140, 2);\n    }\n\n    return super.getTokenFromCode(code);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(refExpressionErrors);\n  }\n\n  parseIdentifier(liberal) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal);\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word !== undefined) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n  }\n\n  isValidLVal(type, isParenthesized, binding) {\n    return type === \"Placeholder\" || super.isValidLVal(type, isParenthesized, binding);\n  }\n\n  toAssignable(node, isLHS) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n\n  isLet(context) {\n    if (super.isLet(context)) {\n      return true;\n    }\n\n    if (!this.isContextual(99)) {\n      return false;\n    }\n\n    if (context) return false;\n    const nextToken = this.lookahead();\n\n    if (nextToken.type === 140) {\n      return true;\n    }\n\n    return false;\n  }\n\n  verifyBreakContinue(node, isBreak) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(node, isBreak);\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type !== \"Placeholder\" || expr.extra && expr.extra.parenthesized) {\n      return super.parseExpressionStatement(node, expr);\n    }\n\n    if (this.match(14)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = super.parseStatement(\"label\");\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n\n  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);\n  }\n\n  parseFunctionId(requireId) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n\n    if (placeholder) {\n      if (this.match(81) || this.match(140) || this.match(5)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        throw this.raise(PlaceholderErrors.ClassNameIsRequired, {\n          at: this.state.startLoc\n        });\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n\n    super.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || super.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n\n  parseExport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(node);\n\n    if (!this.isContextual(97) && !this.match(12)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(65)) {\n      const next = this.nextTokenStart();\n\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(tokenLabelName(140), this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n\n    return super.isExportDefaultSpecifier();\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n      return true;\n    }\n\n    return super.maybeParseExportDefaultSpecifier(node);\n  }\n\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n\n    if (specifiers != null && specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(node);\n    node.specifiers = [];\n\n    if (!this.isContextual(97) && !this.match(12)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    node.specifiers.push(this.finishNode(specifier, \"ImportDefaultSpecifier\"));\n\n    if (this.eat(12)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n\n    this.expectContextual(97);\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource();\n  }\n\n  assertNoSpace() {\n    if (this.state.start > this.state.lastTokEndLoc.index) {\n      this.raise(PlaceholderErrors.UnexpectedSpace, {\n        at: this.state.lastTokEndLoc\n      });\n    }\n  }\n\n});\n\nvar v8intrinsic = (superClass => class V8IntrinsicMixin extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(54)) {\n      const v8IntrinsicStartLoc = this.state.startLoc;\n      const node = this.startNode();\n      this.next();\n\n      if (tokenIsIdentifier(this.state.type)) {\n        const name = this.parseIdentifierName(this.state.start);\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n\n        if (this.match(10)) {\n          return identifier;\n        }\n      }\n\n      this.unexpected(v8IntrinsicStartLoc);\n    }\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);\n  }\n\n});\n\nfunction hasPlugin(plugins, expectedConfig) {\n  const [expectedName, expectedOptions] = typeof expectedConfig === \"string\" ? [expectedConfig, {}] : expectedConfig;\n  const expectedKeys = Object.keys(expectedOptions);\n  const expectedOptionsIsEmpty = expectedKeys.length === 0;\n  return plugins.some(p => {\n    if (typeof p === \"string\") {\n      return expectedOptionsIsEmpty && p === expectedName;\n    } else {\n      const [pluginName, pluginOptions] = p;\n\n      if (pluginName !== expectedName) {\n        return false;\n      }\n\n      for (const key of expectedKeys) {\n        if (pluginOptions[key] !== expectedOptions[key]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n\n  if (plugin && Array.isArray(plugin)) {\n    return plugin[1][option];\n  }\n\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^^\", \"@@\", \"^\", \"%\", \"#\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n\n    if (decoratorsBeforeExport == null) {\n      throw new Error(\"The 'decorators' plugin requires a 'decoratorsBeforeExport' option,\" + \" whose value must be a boolean. If you are migrating from\" + \" Babylon/Babel 6 or want to use the old decorators proposal, you\" + \" should use the 'decorators-legacy' plugin instead of 'decorators'.\");\n    } else if (typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"pipelineOperator\")) {\n    const proposal = getPluginOption(plugins, \"pipelineOperator\", \"proposal\");\n\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\"${p}\"`).join(\", \");\n      throw new Error(`\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`);\n    }\n\n    const tupleSyntaxIsHash = hasPlugin(plugins, [\"recordAndTuple\", {\n      syntaxType: \"hash\"\n    }]);\n\n    if (proposal === \"hack\") {\n      if (hasPlugin(plugins, \"placeholders\")) {\n        throw new Error(\"Cannot combine placeholders plugin and Hack-style pipes.\");\n      }\n\n      if (hasPlugin(plugins, \"v8intrinsic\")) {\n        throw new Error(\"Cannot combine v8intrinsic plugin and Hack-style pipes.\");\n      }\n\n      const topicToken = getPluginOption(plugins, \"pipelineOperator\", \"topicToken\");\n\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `\"${t}\"`).join(\", \");\n        throw new Error(`\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`);\n      }\n\n      if (topicToken === \"#\" && tupleSyntaxIsHash) {\n        throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n      }\n    } else if (proposal === \"smart\" && tupleSyntaxIsHash) {\n      throw new Error('Plugin conflict between `[\"pipelineOperator\", { proposal: \"smart\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.');\n    }\n  }\n\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    {\n      if (hasPlugin(plugins, \"importAssertions\")) {\n        throw new Error(\"Cannot combine importAssertions and moduleAttributes plugins.\");\n      }\n\n      const moduleAttributesVersionPluginOption = getPluginOption(plugins, \"moduleAttributes\", \"version\");\n\n      if (moduleAttributesVersionPluginOption !== \"may-2020\") {\n        throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is 'may-2020'.\");\n      }\n    }\n  }\n\n  if (hasPlugin(plugins, \"recordAndTuple\") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"))) {\n    throw new Error(\"'recordAndTuple' requires 'syntaxType' option whose value should be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n  }\n\n  if (hasPlugin(plugins, \"asyncDoExpressions\") && !hasPlugin(plugins, \"doExpressions\")) {\n    const error = new Error(\"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\");\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\n\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: undefined,\n  startColumn: 0,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false,\n  attachComment: true\n};\nfunction getOptions(opts) {\n  const options = {};\n\n  for (const key of Object.keys(defaultOptions)) {\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n\n  return options;\n}\n\nconst getOwn = (object, key) => Object.hasOwnProperty.call(object, key) && object[key];\n\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\n\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n\n    let parenthesized = undefined;\n\n    if (node.type === \"ParenthesizedExpression\" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParemeterBindingError(Errors.InvalidParenthesizedAssignment, {\n            at: node\n          });\n        } else if (parenthesized.type !== \"MemberExpression\") {\n          this.raise(Errors.InvalidParenthesizedAssignment, {\n            at: node\n          });\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, {\n          at: node\n        });\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n\n          if (isLast && prop.type === \"RestElement\" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {\n            this.raise(Errors.RestTrailingComma, {\n              at: node.extra.trailingCommaLoc\n            });\n          }\n        }\n\n        break;\n\n      case \"ObjectProperty\":\n        {\n          const {\n            key,\n            value\n          } = node;\n\n          if (this.isPrivateName(key)) {\n            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n          }\n\n          this.toAssignable(value, isLHS);\n          break;\n        }\n\n      case \"SpreadElement\":\n        {\n          throw new Error(\"Internal @babel/parser error (this is a bug, please report it).\" + \" SpreadElement should be converted by .toAssignable's caller.\");\n        }\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, {\n            at: node.left.loc.end\n          });\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n  }\n\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(prop.kind === \"get\" || prop.kind === \"set\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {\n        at: prop.key\n      });\n    } else if (prop.type === \"SpreadElement\") {\n      prop.type = \"RestElement\";\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, false);\n      this.toAssignable(arg, isLHS);\n\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, {\n          at: prop\n        });\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    const end = exprList.length - 1;\n\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n\n      if (elt.type === \"SpreadElement\") {\n        elt.type = \"RestElement\";\n        const arg = elt.argument;\n        this.checkToRestConversion(arg, true);\n        this.toAssignable(arg, isLHS);\n      } else {\n        this.toAssignable(elt, isLHS);\n      }\n\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, {\n            at: elt\n          });\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, {\n            at: trailingCommaLoc\n          });\n        }\n      }\n    }\n  }\n\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n\n      case \"ObjectExpression\":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== \"ObjectMethod\" && (i === last || prop.type !== \"SpreadElement\") && this.isAssignable(prop);\n          });\n        }\n\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n\n      case \"ArrayExpression\":\n        return node.elements.every(element => element === null || this.isAssignable(element));\n\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n\n      default:\n        return false;\n    }\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (const expr of exprList) {\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  parseSpread(refExpressionErrors) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 0:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(3, 93, true);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n\n      case 5:\n        return this.parseObjectLike(8, true);\n    }\n\n    return this.parseIdentifier();\n  }\n\n  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n      }\n\n      if (allowEmpty && this.match(12)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(21)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n\n        if (this.match(26) && this.hasPlugin(\"decorators\")) {\n          this.raise(Errors.UnsupportedParameterDecorator, {\n            at: this.state.startLoc\n          });\n        }\n\n        while (this.match(26)) {\n          decorators.push(this.parseDecorator());\n        }\n\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n\n    return elts;\n  }\n\n  parseBindingRestProperty(prop) {\n    this.next();\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(125);\n    return this.finishNode(prop, \"RestElement\");\n  }\n\n  parseBindingProperty() {\n    const prop = this.startNode();\n    const {\n      type,\n      start: startPos,\n      startLoc\n    } = this.state;\n\n    if (type === 21) {\n      return this.parseBindingRestProperty(prop);\n    } else if (type === 134) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      prop.key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop);\n    }\n\n    prop.method = false;\n    return this.parseObjPropValue(prop, startPos, startLoc, false, false, true, false);\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseAssignableListItemTypes(param) {\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    var _startLoc, _startPos, _left;\n\n    startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;\n    startPos = (_startPos = startPos) != null ? _startPos : this.state.start;\n    left = (_left = left) != null ? _left : this.parseBindingAtom();\n    if (!this.eat(29)) return left;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return getOwn({\n      AssignmentPattern: \"left\",\n      RestElement: \"argument\",\n      ObjectProperty: \"value\",\n      ParenthesizedExpression: \"expression\",\n      ArrayPattern: \"elements\",\n      ObjectPattern: \"properties\"\n    }, type);\n  }\n\n  checkLVal(expression, {\n    in: ancestor,\n    binding = BIND_NONE,\n    checkClashes = false,\n    strictModeChanged = false,\n    allowingSloppyLetBinding = !(binding & BIND_SCOPE_LEXICAL),\n    hasParenthesizedAncestor = false\n  }) {\n    var _expression$extra;\n\n    const type = expression.type;\n    if (this.isObjectMethod(expression)) return;\n\n    if (type === \"MemberExpression\") {\n      if (binding !== BIND_NONE) {\n        this.raise(Errors.InvalidPropertyBindingPattern, {\n          at: expression\n        });\n      }\n\n      return;\n    }\n\n    if (expression.type === \"Identifier\") {\n      this.checkIdentifier(expression, binding, strictModeChanged, allowingSloppyLetBinding);\n      const {\n        name\n      } = expression;\n\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, {\n            at: expression\n          });\n        } else {\n          checkClashes.add(name);\n        }\n      }\n\n      return;\n    }\n\n    const validity = this.isValidLVal(expression.type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === \"AssignmentExpression\", binding);\n    if (validity === true) return;\n\n    if (validity === false) {\n      const ParseErrorClass = binding === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n      this.raise(ParseErrorClass, {\n        at: expression,\n        ancestor: ancestor.type === \"UpdateExpression\" ? {\n          type: \"UpdateExpression\",\n          prefix: ancestor.prefix\n        } : {\n          type: ancestor.type\n        }\n      });\n      return;\n    }\n\n    const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === \"ParenthesizedExpression\"];\n    const nextAncestor = expression.type === \"ArrayPattern\" || expression.type === \"ObjectPattern\" || expression.type === \"ParenthesizedExpression\" ? expression : ancestor;\n\n    for (const child of [].concat(expression[key])) {\n      if (child) {\n        this.checkLVal(child, {\n          in: nextAncestor,\n          binding,\n          checkClashes,\n          allowingSloppyLetBinding,\n          strictModeChanged,\n          hasParenthesizedAncestor: isParenthesizedExpression\n        });\n      }\n    }\n  }\n\n  checkIdentifier(at, bindingType, strictModeChanged = false, allowLetBinding = !(bindingType & BIND_SCOPE_LEXICAL)) {\n    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {\n      if (bindingType === BIND_NONE) {\n        this.raise(Errors.StrictEvalArguments, {\n          at,\n          referenceName: at.name\n        });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, {\n          at,\n          bindingName: at.name\n        });\n      }\n    }\n\n    if (!allowLetBinding && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, {\n        at\n      });\n    }\n\n    if (!(bindingType & BIND_NONE)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n\n  declareNameFromIdentifier(identifier, binding) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern) break;\n\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, {\n          at: node\n        });\n    }\n  }\n\n  checkCommaAfterRest(close) {\n    if (!this.match(12)) {\n      return false;\n    }\n\n    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, {\n      at: this.state.startLoc\n    });\n    return true;\n  }\n\n}\n\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return;\n    }\n\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, {\n          at: key\n        });\n        return;\n      }\n\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, {\n            at: key\n          });\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt;\n  }\n\n  getExpression() {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n\n    if (!this.match(135)) {\n      this.unexpected();\n    }\n\n    this.finalizeRemainingComments();\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n\n    return expr;\n  }\n\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  parseExpressionBase(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n\n    if (this.match(12)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n\n      while (this.eat(12)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n\n    return expr;\n  }\n\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n\n  setOptionalParametersError(refExpressionErrors, resultError) {\n    var _resultError$loc;\n\n    refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;\n  }\n\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    if (this.isContextual(105)) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield();\n\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n\n        return left;\n      }\n    }\n\n    let ownExpressionErrors;\n\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n\n    const {\n      type\n    } = this.state;\n\n    if (type === 10 || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(refExpressionErrors);\n\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (this.match(29)) {\n        this.toAssignable(left, true);\n        node.left = left;\n\n        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startPos) {\n          refExpressionErrors.doubleProtoLoc = null;\n        }\n\n        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startPos) {\n          refExpressionErrors.shorthandAssignLoc = null;\n        }\n\n        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startPos) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null;\n        }\n      } else {\n        node.left = left;\n      }\n\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, {\n        in: this.finishNode(node, \"AssignmentExpression\")\n      });\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  parseMaybeConditional(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);\n  }\n\n  parseConditional(expr, startPos, startLoc, refExpressionErrors) {\n    if (this.eat(17)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(14);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    return expr;\n  }\n\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\n    return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\n  }\n\n  parseExprOps(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {\n    if (this.isPrivateName(left)) {\n      const value = this.getPrivateNameSV(left);\n\n      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {\n        this.raise(Errors.PrivateInExpectedIn, {\n          at: left,\n          identifierName: value\n        });\n      }\n\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n\n    const op = this.state.type;\n\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {\n      let prec = tokenOperatorPrecedence(op);\n\n      if (prec > minPrec) {\n        if (op === 39) {\n          this.expectPlugin(\"pipelineOperator\");\n\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n\n        const node = this.startNodeAt(leftStartPos, leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n        const logical = op === 41 || op === 42;\n        const coalesce = op === 40;\n\n        if (coalesce) {\n          prec = tokenOperatorPrecedence(42);\n        }\n\n        this.next();\n\n        if (op === 39 && this.hasPlugin([\"pipelineOperator\", {\n          proposal: \"minimal\"\n        }])) {\n          if (this.state.type === 96 && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {\n              at: this.state.startLoc\n            });\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n\n        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, {\n            at: this.state.startLoc\n          });\n        }\n\n        return this.parseExprOp(finishedNode, leftStartPos, leftStartLoc, minPrec);\n      }\n    }\n\n    return left;\n  }\n\n  parseExprOpRightExpr(op, prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    switch (op) {\n      case 39:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n\n          case \"smart\":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(105)) {\n                throw this.raise(Errors.PipeBodyIsTighter, {\n                  at: this.state.startLoc\n                });\n              }\n\n              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  parseExprOpBaseRightExpr(op, prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\n  }\n\n  parseHackPipeBody() {\n    var _body$extra;\n\n    const {\n      startLoc\n    } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);\n\n    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\n      this.raise(Errors.PipeUnparenthesizedBody, {\n        at: startLoc,\n        type: body.type\n      });\n    }\n\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipeTopicUnused, {\n        at: startLoc\n      });\n    }\n\n    return body;\n  }\n\n  checkExponentialAfterUnary(node) {\n    if (this.match(57)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, {\n        at: node.argument\n      });\n    }\n  }\n\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(96);\n\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startPos, startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n\n    const update = this.match(34);\n    const node = this.startNode();\n\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (this.match(72)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n\n      const isDelete = this.match(89);\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, {\n            at: node\n          });\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, {\n            at: node\n          });\n        }\n      }\n\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node);\n        }\n\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n\n    if (isAwait) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {\n          at: startLoc\n        });\n        return this.parseAwait(startPos, startLoc);\n      }\n    }\n\n    return expr;\n  }\n\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      const updateExpressionNode = node;\n      this.checkLVal(updateExpressionNode.argument, {\n        in: this.finishNode(updateExpressionNode, \"UpdateExpression\")\n      });\n      return node;\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, {\n        in: expr = this.finishNode(node, \"UpdateExpression\")\n      });\n    }\n\n    return expr;\n  }\n\n  parseExprSubscripts(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n\n    do {\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n\n    return base;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    const {\n      type\n    } = this.state;\n\n    if (!noCalls && type === 15) {\n      return this.parseBind(base, startPos, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);\n    }\n\n    let optional = false;\n\n    if (type === 18) {\n      if (noCalls && this.lookaheadCharCode() === 40) {\n        state.stop = true;\n        return base;\n      }\n\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n\n    if (!noCalls && this.match(10)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);\n    } else {\n      const computed = this.eat(0);\n\n      if (computed || optional || this.eat(16)) {\n        return this.parseMember(base, startPos, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n\n  parseMember(base, startPos, startLoc, state, computed, optional) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.computed = computed;\n\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(3);\n    } else if (this.match(134)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, {\n          at: startLoc\n        });\n      }\n\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  parseBind(base, startPos, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    this.next();\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startPos, startLoc, noCalls);\n  }\n\n  parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    const node = this.startNodeAt(startPos, startLoc);\n    node.callee = base;\n    const {\n      maybeAsyncArrow,\n      optionalChainMember\n    } = state;\n\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n\n    if (optionalChainMember) {\n      node.optional = optional;\n    }\n\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(11);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(11, base.type === \"Import\", base.type !== \"Super\", node, refExpressionErrors);\n    }\n\n    let finishedNode = this.finishCallExpression(node, optionalChainMember);\n\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), finishedNode);\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n\n      this.toReferencedArguments(finishedNode);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return finishedNode;\n  }\n\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  parseTaggedTemplateExpression(base, startPos, startLoc, state) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, {\n        at: startLoc\n      });\n    }\n\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\n  }\n\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        {\n          if (!this.hasPlugin(\"moduleAttributes\")) {\n            this.expectPlugin(\"importAssertions\");\n          }\n        }\n      }\n\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, {\n          at: node,\n          maxArgumentCount: this.hasPlugin(\"importAssertions\") || this.hasPlugin(\"moduleAttributes\") ? 2 : 1\n        });\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, {\n              at: arg\n            });\n          }\n        }\n      }\n    }\n\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n\n  parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n\n        if (this.match(close)) {\n          if (dynamicImport && !this.hasPlugin(\"importAssertions\") && !this.hasPlugin(\"moduleAttributes\")) {\n            this.raise(Errors.ImportCallArgumentTrailingComma, {\n              at: this.state.lastTokStartLoc\n            });\n          }\n\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(19) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(19);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);\n\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n\n    return node;\n  }\n\n  parseNoCallExpr() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    let node;\n    const {\n      type\n    } = this.state;\n\n    switch (type) {\n      case 79:\n        return this.parseSuper();\n\n      case 83:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(16)) {\n          return this.parseImportMetaProperty(node);\n        }\n\n        if (!this.match(10)) {\n          this.raise(Errors.UnsupportedImport, {\n            at: this.state.lastTokStartLoc\n          });\n        }\n\n        return this.finishNode(node, \"Import\");\n\n      case 78:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case 90:\n        {\n          return this.parseDo(this.startNode(), false);\n        }\n\n      case 56:\n      case 31:\n        {\n          this.readRegexp();\n          return this.parseRegExpLiteral(this.state.value);\n        }\n\n      case 130:\n        return this.parseNumericLiteral(this.state.value);\n\n      case 131:\n        return this.parseBigIntLiteral(this.state.value);\n\n      case 132:\n        return this.parseDecimalLiteral(this.state.value);\n\n      case 129:\n        return this.parseStringLiteral(this.state.value);\n\n      case 84:\n        return this.parseNullLiteral();\n\n      case 85:\n        return this.parseBooleanLiteral(true);\n\n      case 86:\n        return this.parseBooleanLiteral(false);\n\n      case 10:\n        {\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          return this.parseParenAndDistinguishExpression(canBeArrow);\n        }\n\n      case 2:\n      case 1:\n        {\n          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);\n        }\n\n      case 0:\n        {\n          return this.parseArrayLike(3, true, false, refExpressionErrors);\n        }\n\n      case 6:\n      case 7:\n        {\n          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);\n        }\n\n      case 5:\n        {\n          return this.parseObjectLike(8, false, false, refExpressionErrors);\n        }\n\n      case 68:\n        return this.parseFunctionOrFunctionSent();\n\n      case 26:\n        this.parseDecorators();\n\n      case 80:\n        node = this.startNode();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case 77:\n        return this.parseNewOrNewTarget();\n\n      case 25:\n      case 24:\n        return this.parseTemplate(false);\n\n      case 15:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(Errors.UnsupportedBind, {\n              at: callee\n            });\n          }\n        }\n\n      case 134:\n        {\n          this.raise(Errors.PrivateInExpectedIn, {\n            at: this.state.startLoc,\n            identifierName: this.state.value\n          });\n          return this.parsePrivateName();\n        }\n\n      case 33:\n        {\n          return this.parseTopicReferenceThenEqualsSign(54, \"%\");\n        }\n\n      case 32:\n        {\n          return this.parseTopicReferenceThenEqualsSign(44, \"^\");\n        }\n\n      case 37:\n      case 38:\n        {\n          return this.parseTopicReference(\"hack\");\n        }\n\n      case 44:\n      case 54:\n      case 27:\n        {\n          const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n\n          if (pipeProposal) {\n            return this.parseTopicReference(pipeProposal);\n          } else {\n            throw this.unexpected();\n          }\n        }\n\n      case 47:\n        {\n          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n\n          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n            this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n            break;\n          } else {\n            throw this.unexpected();\n          }\n        }\n\n      default:\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {\n            return this.parseModuleExpression();\n          }\n\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            const {\n              type\n            } = this.state;\n\n            if (type === 68) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseFunction(this.startNodeAtNode(id), undefined, true);\n            } else if (tokenIsIdentifier(type)) {\n              if (this.lookaheadCharCode() === 61) {\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\n              } else {\n                return id;\n              }\n            } else if (type === 90) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n\n          return id;\n        } else {\n          throw this.unexpected();\n        }\n\n    }\n  }\n\n  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n\n    if (pipeProposal) {\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      this.state.pos--;\n      this.state.end--;\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      throw this.unexpected();\n    }\n  }\n\n  parseTopicReference(pipeProposal) {\n    const node = this.startNode();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n    this.next();\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n\n  finishTopicReference(node, startLoc, pipeProposal, tokenType) {\n    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {\n      const nodeType = pipeProposal === \"smart\" ? \"PipelinePrimaryTopicReference\" : \"TopicReference\";\n\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        this.raise(pipeProposal === \"smart\" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {\n          at: startLoc\n        });\n      }\n\n      this.registerTopicReference();\n      return this.finishNode(node, nodeType);\n    } else {\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, {\n        at: startLoc,\n        token: tokenLabelName(tokenType)\n      });\n    }\n  }\n\n  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {\n    switch (pipeProposal) {\n      case \"hack\":\n        {\n          return this.hasPlugin([\"pipelineOperator\", {\n            topicToken: tokenLabelName(tokenType)\n          }]);\n        }\n\n      case \"smart\":\n        return tokenType === 27;\n\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, {\n          at: startLoc\n        });\n    }\n  }\n\n  parseAsyncArrowUnaryFunction(node) {\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, {\n        at: this.state.curPosition()\n      });\n    }\n\n    this.expect(19);\n    return this.parseArrowExpression(node, params, true);\n  }\n\n  parseDo(node, isAsync) {\n    this.expectPlugin(\"doExpressions\");\n\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n\n    node.async = isAsync;\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n\n    if (isAsync) {\n      this.prodParam.enter(PARAM_AWAIT);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.SuperNotAllowed, {\n        at: node\n      });\n    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.UnexpectedSuper, {\n        at: node\n      });\n    }\n\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\n      this.raise(Errors.UnsupportedSuper, {\n        at: node\n      });\n    }\n\n    return this.finishNode(node, \"Super\");\n  }\n\n  parsePrivateName() {\n    const node = this.startNode();\n    const id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1));\n    const name = this.state.value;\n    this.next();\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.prodParam.hasYield && this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n\n      if (this.match(102)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n\n    return this.parseFunction(node);\n  }\n\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, {\n        at: node.property,\n        target: meta.name,\n        onlyValidPropertyName: propertyName\n      });\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next();\n\n    if (this.isContextual(100)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, {\n          at: id\n        });\n      }\n\n      this.sawUnambiguousESM = true;\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n\n  parseLiteralAtNode(value, type, node) {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(node.start, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n\n  parseLiteral(value, type) {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n\n  parseStringLiteral(value) {\n    return this.parseLiteral(value, \"StringLiteral\");\n  }\n\n  parseNumericLiteral(value) {\n    return this.parseLiteral(value, \"NumericLiteral\");\n  }\n\n  parseBigIntLiteral(value) {\n    return this.parseLiteral(value, \"BigIntLiteral\");\n  }\n\n  parseDecimalLiteral(value) {\n    return this.parseLiteral(value, \"DecimalLiteral\");\n  }\n\n  parseRegExpLiteral(value) {\n    const node = this.parseLiteral(value.value, \"RegExpLiteral\");\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    return node;\n  }\n\n  parseBooleanLiteral(value) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartPos = this.state.start;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n\n    while (!this.match(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);\n\n        if (this.match(11)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n\n      if (this.match(21)) {\n        const spreadNodeStartPos = this.state.start;\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));\n\n        if (!this.checkCommaAfterRest(41)) {\n          break;\n        }\n      } else {\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));\n      }\n    }\n\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(11);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startPos, startLoc);\n\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n\n    this.expressionScope.exit();\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    this.toReferencedListDeep(exprList, true);\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    return this.wrapParenthesis(startPos, startLoc, val);\n  }\n\n  wrapParenthesis(startPos, startLoc, expression) {\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startPos);\n      this.takeSurroundingComments(expression, startPos, this.state.lastTokEndLoc.index);\n      return expression;\n    }\n\n    const parenExpression = this.startNodeAt(startPos, startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n\n  shouldParseArrow(params) {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(node) {\n    if (this.eat(19)) {\n      return node;\n    }\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    return node;\n  }\n\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n        this.raise(Errors.UnexpectedNewTarget, {\n          at: metaProp\n        });\n      }\n\n      return metaProp;\n    }\n\n    return this.parseNew(node);\n  }\n\n  parseNew(node) {\n    this.parseNewCallee(node);\n\n    if (this.eat(10)) {\n      const args = this.parseExprList(11);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewCallee(node) {\n    node.callee = this.parseNoCallExpr();\n\n    if (node.callee.type === \"Import\") {\n      this.raise(Errors.ImportCallNotNewExpression, {\n        at: node.callee\n      });\n    } else if (this.isOptionalChain(node.callee)) {\n      this.raise(Errors.OptionalChainingNoNew, {\n        at: this.state.lastTokEndLoc\n      });\n    } else if (this.eat(18)) {\n      this.raise(Errors.OptionalChainingNoNew, {\n        at: this.state.startLoc\n      });\n    }\n  }\n\n  parseTemplateElement(isTagged) {\n    const {\n      start,\n      startLoc,\n      end,\n      value\n    } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt(elemStart, createPositionWithColumnOffset(startLoc, 1));\n\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, {\n          at: createPositionWithColumnOffset(startLoc, 2)\n        });\n      }\n    }\n\n    const isTail = this.match(24);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset)\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));\n    return finishedNode;\n  }\n\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(node);\n          break;\n        }\n      }\n\n      let prop;\n\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(Errors.InvalidRecordProperty, {\n          at: prop\n        });\n      }\n\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n\n    return this.finishNode(node, type);\n  }\n\n  addTrailingCommaExtraToNode(node) {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));\n  }\n\n  parsePropertyDefinition(refExpressionErrors) {\n    let decorators = [];\n\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, {\n          at: this.state.startLoc\n        });\n      }\n\n      while (this.match(26)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode();\n    let isAsync = false;\n    let isAccessor = false;\n    let startPos;\n    let startLoc;\n\n    if (this.match(21)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (refExpressionErrors) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    let isGenerator = this.eat(55);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, refExpressionErrors);\n\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(55);\n        this.parsePropertyName(prop);\n      }\n\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n\n        if (this.match(55)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, {\n            at: this.state.curPosition(),\n            kind: keyName\n          });\n          this.next();\n        }\n\n        this.parsePropertyName(prop);\n      }\n    }\n\n    return this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n\n  checkGetterSetterParams(method) {\n    var _params;\n\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n\n    if (params.length !== paramCount) {\n      this.raise(method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, {\n        at: method\n      });\n    }\n\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(Errors.BadSetterRestParameter, {\n        at: method\n      });\n    }\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n\n    if (isAsync || isGenerator || this.match(10)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n\n    if (this.eat(14)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));\n      } else if (this.match(29)) {\n        const shorthandAssignLoc = this.state.startLoc;\n\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, {\n            at: shorthandAssignLoc\n          });\n        }\n\n        prop.value = this.parseMaybeDefault(startPos, startLoc, cloneIdentifier(prop.key));\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n\n  parsePropertyName(prop, refExpressionErrors) {\n    if (this.eat(0)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(3);\n    } else {\n      const {\n        type,\n        value\n      } = this.state;\n      let key;\n\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case 130:\n            key = this.parseNumericLiteral(value);\n            break;\n\n          case 129:\n            key = this.parseStringLiteral(value);\n            break;\n\n          case 131:\n            key = this.parseBigIntLiteral(value);\n            break;\n\n          case 132:\n            key = this.parseDecimalLiteral(value);\n            break;\n\n          case 134:\n            {\n              const privateKeyLoc = this.state.startLoc;\n\n              if (refExpressionErrors != null) {\n                if (refExpressionErrors.privateKeyLoc === null) {\n                  refExpressionErrors.privateKeyLoc = privateKeyLoc;\n                }\n              } else {\n                this.raise(Errors.UnexpectedPrivateField, {\n                  at: privateKeyLoc\n                });\n              }\n\n              key = this.parsePrivateName();\n              break;\n            }\n\n          default:\n            throw this.unexpected();\n        }\n      }\n\n      prop.key = key;\n\n      if (type !== 134) {\n        prop.computed = false;\n      }\n    }\n\n    return prop.key;\n  }\n\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor;\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, allowModifiers);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return finishedNode;\n  }\n\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n\n  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    let flags = functionFlags(isAsync, false);\n\n    if (!this.match(5) && this.prodParam.hasIn) {\n      flags |= PARAM_IN;\n    }\n\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params;\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(5);\n    this.expressionScope.enter(newExpressionScope());\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n\n        if (hasStrictModeDirective && nonSimple) {\n          this.raise(Errors.IllegalLanguageModeDirective, {\n            at: (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.loc.end : node\n          });\n        }\n\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n\n        if (this.state.strict && node.id) {\n          this.checkIdentifier(node.id, BIND_OUTSIDE, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n\n    this.expressionScope.exit();\n  }\n\n  isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n  }\n\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n\n    return true;\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = !allowDuplicates && new Set();\n    const formalParameters = {\n      type: \"FormalParameters\"\n    };\n\n    for (const param of node.params) {\n      this.checkLVal(param, {\n        in: formalParameters,\n        binding: BIND_VAR,\n        checkClashes,\n        strictModeChanged\n      });\n    }\n  }\n\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n\n    return elts;\n  }\n\n  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {\n    let elt;\n\n    if (this.match(12)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, {\n          at: this.state.curPosition(),\n          unexpected: \",\"\n        });\n      }\n\n      elt = null;\n    } else if (this.match(21)) {\n      const spreadNodeStartPos = this.state.start;\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);\n    } else if (this.match(17)) {\n      this.expectPlugin(\"partialApplication\");\n\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, {\n          at: this.state.startLoc\n        });\n      }\n\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);\n    }\n\n    return elt;\n  }\n\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(node.start, liberal);\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(pos, liberal) {\n    let name;\n    const {\n      startLoc,\n      type\n    } = this.state;\n\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      throw this.unexpected();\n    }\n\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n\n    if (liberal) {\n      if (tokenIsKeyword) {\n        this.replaceToken(128);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n\n    this.next();\n    return name;\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word.length > 10) {\n      return;\n    }\n\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n\n    if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, {\n          at: startLoc\n        });\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, {\n          at: startLoc\n        });\n        return;\n      }\n\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {\n          at: startLoc\n        });\n        return;\n      }\n\n      this.expressionScope.recordAsyncArrowParametersError({\n        at: startLoc\n      });\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, {\n          at: startLoc\n        });\n        return;\n      }\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, {\n        at: startLoc,\n        keyword: word\n      });\n      return;\n    }\n\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, {\n        at: startLoc,\n        reservedWord: word\n      });\n    }\n  }\n\n  isAwaitAllowed() {\n    if (this.prodParam.hasAwait) return true;\n\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n\n    return false;\n  }\n\n  parseAwait(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {\n      at: node\n    });\n\n    if (this.eat(55)) {\n      this.raise(Errors.ObsoleteAwaitStar, {\n        at: node\n      });\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  isAmbiguousAwait() {\n    if (this.hasPrecedingLineBreak()) return true;\n    const {\n      type\n    } = this.state;\n    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 133 || type === 56 || this.hasPlugin(\"v8intrinsic\") && type === 54;\n  }\n\n  parseYield() {\n    const node = this.startNode();\n    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {\n      at: node\n    });\n    this.next();\n    let delegating = false;\n    let argument = null;\n\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(55);\n\n      switch (this.state.type) {\n        case 13:\n        case 135:\n        case 8:\n        case 11:\n        case 3:\n        case 9:\n        case 14:\n        case 12:\n          if (!delegating) break;\n\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  checkPipelineAtInfixOperator(left, leftStartLoc) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(Errors.PipelineHeadSequenceExpression, {\n          at: leftStartLoc\n        });\n      }\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(childExpr, startPos, startLoc) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt(startPos, startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt(startPos, startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n\n      case \"Identifier\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  checkSmartPipeTopicBodyEarlyErrors(startLoc) {\n    if (this.match(19)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, {\n        at: this.state.startLoc\n      });\n    }\n\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, {\n        at: startLoc\n      });\n    }\n  }\n\n  withTopicBindingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withSmartMixTopicForbiddingContext(callback) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        maxNumOfResolvableTopics: 0,\n        maxTopicIndex: null\n      };\n\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      return callback();\n    }\n  }\n\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = PARAM_IN & ~flags;\n\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | PARAM_IN);\n\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n\n    return callback();\n  }\n\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = PARAM_IN & flags;\n\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~PARAM_IN);\n\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n\n    return callback();\n  }\n\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  topicReferenceIsAllowedInCurrentContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n\n  parseFSharpPipelineBody(prec) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startPos, startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n\n  parseModuleExpression() {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode();\n    this.next();\n    this.eat(5);\n    const revertScopes = this.initializeScopes(true);\n    this.enterInitialScopes();\n    const program = this.startNode();\n\n    try {\n      node.body = this.parseProgram(program, 8, \"module\");\n    } finally {\n      revertScopes();\n    }\n\n    this.eat(8);\n    return this.finishNode(node, \"ModuleExpression\");\n  }\n\n  parsePropertyNamePrefixOperator(prop) {}\n\n}\n\nconst loopLabel = {\n  kind: \"loop\"\n},\n      switchLabel = {\n  kind: \"switch\"\n};\nconst FUNC_NO_FLAGS = 0b000,\n      FUNC_STATEMENT = 0b001,\n      FUNC_HANGING_STATEMENT = 0b010,\n      FUNC_NULLABLE_ID = 0b100;\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\n\nfunction babel7CompatTokens(tokens, input) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const {\n      type\n    } = token;\n\n    if (typeof type === \"number\") {\n      {\n        if (type === 134) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(i, 1, new Token({\n            type: getExportedToken(27),\n            value: \"#\",\n            start: start,\n            end: hashEndPos,\n            startLoc: loc.start,\n            endLoc: hashEndLoc\n          }), new Token({\n            type: getExportedToken(128),\n            value: value,\n            start: hashEndPos,\n            end: end,\n            startLoc: hashEndLoc,\n            endLoc: loc.end\n          }));\n          i++;\n          continue;\n        }\n\n        if (tokenIsTemplate(type)) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n\n          if (input.charCodeAt(start) === 96) {\n            startToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          } else {\n            startToken = new Token({\n              type: getExportedToken(8),\n              value: \"}\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          }\n\n          let templateValue, templateElementEnd, templateElementEndLoc, endToken;\n\n          if (type === 24) {\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              type: getExportedToken(22),\n              value: \"`\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          } else {\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              type: getExportedToken(23),\n              value: \"${\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          }\n\n          tokens.splice(i, 1, startToken, new Token({\n            type: getExportedToken(20),\n            value: templateValue,\n            start: backquoteEnd,\n            end: templateElementEnd,\n            startLoc: backquoteEndLoc,\n            endLoc: templateElementEndLoc\n          }), endToken);\n          i += 2;\n          continue;\n        }\n      }\n      token.type = getExportedToken(type);\n    }\n  }\n\n  return tokens;\n}\n\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    file.program = this.parseProgram(program);\n    file.comments = this.state.comments;\n\n    if (this.options.tokens) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input);\n    }\n\n    return this.finishNode(file, \"File\");\n  }\n\n  parseProgram(program, end = 135, sourceType = this.options.sourceType) {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n        this.raise(Errors.ModuleExportUndefined, {\n          at,\n          localName\n        });\n      }\n    }\n\n    return this.finishNode(program, \"Program\");\n  }\n\n  stmtToDirective(stmt) {\n    const directive = stmt;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n    directiveLiteral.type = \"DirectiveLiteral\";\n    return directive;\n  }\n\n  parseInterpreterDirective() {\n    if (!this.match(28)) {\n      return null;\n    }\n\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(context) {\n    if (!this.isContextual(99)) {\n      return false;\n    }\n\n    return this.isLetKeyword(context);\n  }\n\n  isLetKeyword(context) {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n\n    if (nextCh === 92 || nextCh === 91) {\n      return true;\n    }\n\n    if (context) return false;\n    if (nextCh === 123) return true;\n\n    if (isIdentifierStart(nextCh)) {\n      keywordRelationalOperator.lastIndex = next;\n\n      if (keywordRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.match(26)) {\n      this.parseDecorators(true);\n    }\n\n    return this.parseStatementContent(context, topLevel);\n  }\n\n  parseStatementContent(context, topLevel) {\n    let starttype = this.state.type;\n    const node = this.startNode();\n    let kind;\n\n    if (this.isLet(context)) {\n      starttype = 74;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n      case 60:\n        return this.parseBreakContinueStatement(node, true);\n\n      case 63:\n        return this.parseBreakContinueStatement(node, false);\n\n      case 64:\n        return this.parseDebuggerStatement(node);\n\n      case 90:\n        return this.parseDoStatement(node);\n\n      case 91:\n        return this.parseForStatement(node);\n\n      case 68:\n        if (this.lookaheadCharCode() === 46) break;\n\n        if (context) {\n          if (this.state.strict) {\n            this.raise(Errors.StrictFunction, {\n              at: this.state.startLoc\n            });\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(Errors.SloppyFunction, {\n              at: this.state.startLoc\n            });\n          }\n        }\n\n        return this.parseFunctionStatement(node, false, !context);\n\n      case 80:\n        if (context) this.unexpected();\n        return this.parseClass(node, true);\n\n      case 69:\n        return this.parseIfStatement(node);\n\n      case 70:\n        return this.parseReturnStatement(node);\n\n      case 71:\n        return this.parseSwitchStatement(node);\n\n      case 72:\n        return this.parseThrowStatement(node);\n\n      case 73:\n        return this.parseTryStatement(node);\n\n      case 75:\n      case 74:\n        kind = kind || this.state.value;\n\n        if (context && kind !== \"var\") {\n          this.raise(Errors.UnexpectedLexicalDeclaration, {\n            at: this.state.startLoc\n          });\n        }\n\n        return this.parseVarStatement(node, kind);\n\n      case 92:\n        return this.parseWhileStatement(node);\n\n      case 76:\n        return this.parseWithStatement(node);\n\n      case 5:\n        return this.parseBlock();\n\n      case 13:\n        return this.parseEmptyStatement(node);\n\n      case 83:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n            break;\n          }\n        }\n\n      case 82:\n        {\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(Errors.UnexpectedImportExport, {\n              at: this.state.startLoc\n            });\n          }\n\n          this.next();\n          let result;\n\n          if (starttype === 83) {\n            result = this.parseImport(node);\n\n            if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node);\n\n            if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n\n          this.assertModuleNodeAllowed(result);\n          return result;\n        }\n\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (context) {\n              this.raise(Errors.AsyncFunctionInSingleStatementContext, {\n                at: this.state.startLoc\n              });\n            }\n\n            this.next();\n            return this.parseFunctionStatement(node, true, !context);\n          }\n        }\n    }\n\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (tokenIsIdentifier(starttype) && expr.type === \"Identifier\" && this.eat(14)) {\n      return this.parseLabeledStatement(node, maybeName, expr, context);\n    } else {\n      return this.parseExpressionStatement(node, expr);\n    }\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, {\n        at: node\n      });\n    }\n  }\n\n  takeDecorators(node) {\n    const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  }\n\n  canHaveLeadingDecorator() {\n    return this.match(80);\n  }\n\n  parseDecorators(allowExport) {\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    while (this.match(26)) {\n      const decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(82)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (this.hasPlugin(\"decorators\") && !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(Errors.DecoratorExportClass, {\n          at: this.state.startLoc\n        });\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, {\n        at: this.state.startLoc\n      });\n    }\n  }\n\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n    const node = this.startNode();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      this.state.decoratorStack.push([]);\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let expr;\n\n      if (this.match(10)) {\n        const startPos = this.state.start;\n        const startLoc = this.state.startLoc;\n        this.next();\n        expr = this.parseExpression();\n        this.expect(11);\n        expr = this.wrapParenthesis(startPos, startLoc, expr);\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(16)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.object = expr;\n          node.property = this.parseIdentifier(true);\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n      }\n\n      node.expression = this.parseMaybeDecoratorArguments(expr);\n      this.state.decoratorStack.pop();\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(10)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(11, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(node, isBreak) {\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, isBreak);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n\n  verifyBreakContinue(node, isBreak) {\n    let i;\n\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, {\n        at: node,\n        type\n      });\n    }\n  }\n\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression() {\n    this.expect(10);\n    const val = this.parseExpression();\n    this.expect(11);\n    return val;\n  }\n\n  parseDoStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"do\"));\n    this.state.labels.pop();\n    this.expect(92);\n    node.test = this.parseHeaderExpression();\n    this.eat(13);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = null;\n\n    if (this.isAwaitAllowed() && this.eatContextual(96)) {\n      awaitAt = this.state.lastTokStartLoc;\n    }\n\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(10);\n\n    if (this.match(13)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, null);\n    }\n\n    const startsWithLet = this.isContextual(99);\n    const isLet = startsWithLet && this.isLetKeyword();\n\n    if (this.match(74) || this.match(75) || isLet) {\n      const initNode = this.startNode();\n      const kind = isLet ? \"let\" : this.state.value;\n      this.next();\n      this.parseVar(initNode, true, kind);\n      const init = this.finishNode(initNode, \"VariableDeclaration\");\n\n      if ((this.match(58) || this.isContextual(101)) && init.declarations.length === 1) {\n        return this.parseForIn(node, init, awaitAt);\n      }\n\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, init);\n    }\n\n    const startsWithAsync = this.isContextual(95);\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(101);\n\n    if (isForOf) {\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, {\n          at: init\n        });\n      }\n\n      if (awaitAt === null && startsWithAsync && init.type === \"Identifier\") {\n        this.raise(Errors.ForOfAsync, {\n          at: init\n        });\n      }\n    }\n\n    if (isForOf || this.match(58)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, {\n        in: {\n          type\n        }\n      });\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, init);\n  }\n\n  parseFunctionStatement(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);\n  }\n\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(66) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(Errors.IllegalReturn, {\n        at: this.state.startLoc\n      });\n    }\n\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(5);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n    let cur;\n\n    for (let sawDefault; !this.match(8);) {\n      if (this.match(61) || this.match(65)) {\n        const isCase = this.match(61);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, {\n              at: this.state.lastTokStartLoc\n            });\n          }\n\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this.expect(14);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(node) {\n    this.next();\n\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, {\n        at: this.state.lastTokEndLoc\n      });\n    }\n\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    const simple = param.type === \"Identifier\";\n    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLVal(param, {\n      in: {\n        type: \"CatchClause\"\n      },\n      binding: BIND_LEXICAL,\n      allowingSloppyLetBinding: true\n    });\n    return param;\n  }\n\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(62)) {\n      const clause = this.startNode();\n      this.next();\n\n      if (this.match(10)) {\n        this.expect(10);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(11);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(67) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, {\n        at: node\n      });\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"while\"));\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, {\n        at: this.state.startLoc\n      });\n    }\n\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"with\"));\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  parseLabeledStatement(node, maybeName, expr, context) {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, {\n          at: expr,\n          labelName: maybeName\n        });\n      }\n    }\n\n    const kind = tokenIsLoop(this.state.type) ? \"loop\" : this.match(71) ? \"switch\" : null;\n\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n\n    this.expect(5);\n\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\n\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      const stmt = this.parseStatement(null, topLevel);\n\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n\n          continue;\n        }\n\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n\n      body.push(stmt);\n    }\n\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(13) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(11) ? null : this.parseExpression();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(58);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(Errors.ForInOfLoopInitializer, {\n        at: init,\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\"\n      });\n    }\n\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, {\n        at: init,\n        ancestor: {\n          type: \"ForStatement\"\n        }\n      });\n    }\n\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  parseVar(node, isFor, kind, allowMissingInitializer = false) {\n    const declarations = node.declarations = [];\n    node.kind = kind;\n\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n\n      if (decl.init === null && !allowMissingInitializer) {\n        if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(58) || this.isContextual(101)))) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"destructuring\"\n          });\n        } else if (kind === \"const\" && !(this.match(58) || this.isContextual(101))) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"const\"\n          });\n        }\n      }\n\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(12)) break;\n    }\n\n    return node;\n  }\n\n  parseVarId(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, {\n      in: {\n        type: \"VariableDeclarator\"\n      },\n      binding: kind === \"var\" ? BIND_VAR : BIND_LEXICAL\n    });\n  }\n\n  parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n    this.initFunction(node, isAsync);\n\n    if (this.match(55) && isHangingStatement) {\n      this.raise(Errors.GeneratorInSingleStatementContext, {\n        at: this.state.startLoc\n      });\n    }\n\n    node.generator = this.eat(55);\n\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node, false);\n    this.withSmartMixTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isStatement && !isHangingStatement) {\n      this.registerFunctionStatementId(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n\n  parseFunctionId(requireId) {\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    this.expect(10);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(11, 41, false, allowModifiers);\n    this.expressionScope.exit();\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.loc.start);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n\n  isClassProperty() {\n    return this.match(29) || this.match(13) || this.match(8);\n  }\n\n  isClassMethod() {\n    return this.match(10);\n  }\n\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  }\n\n  parseClassBody(hadSuperClass, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false,\n      hadSuperClass\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(5);\n    this.withSmartMixTopicForbiddingContext(() => {\n      while (!this.match(8)) {\n        if (this.eat(13)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, {\n              at: this.state.lastTokEndLoc\n            });\n          }\n\n          continue;\n        }\n\n        if (this.match(26)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode();\n\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state);\n\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(Errors.DecoratorConstructor, {\n            at: member\n          });\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, {\n        at: this.state.startLoc\n      });\n    }\n\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(104);\n\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n\n      if (this.eat(5)) {\n        this.parseClassStaticBlock(classBody, member);\n        return;\n      }\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const accessorProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n\n    if (this.eat(55)) {\n      method.kind = \"method\";\n      const isPrivateName = this.match(134);\n      this.parseClassElementName(method);\n\n      if (isPrivateName) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, {\n          at: publicMethod.key\n        });\n      }\n\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n\n    const isContextual = tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\n    const isPrivate = this.match(134);\n    const key = this.parseClassElementName(member);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, {\n            at: key\n          });\n        }\n\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, {\n            at: key\n          });\n        }\n\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isContextual && key.name === \"async\" && !this.isLineTerminator()) {\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(55);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n\n      method.kind = \"method\";\n      const isPrivate = this.match(134);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, {\n            at: publicMethod.key\n          });\n        }\n\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isContextual && (key.name === \"get\" || key.name === \"set\") && !(this.match(55) && this.isLineTerminator())) {\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = key.name;\n      const isPrivate = this.match(134);\n      this.parseClassElementName(publicMethod);\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, {\n            at: publicMethod.key\n          });\n        }\n\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (isContextual && key.name === \"accessor\" && !this.isLineTerminator()) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n      const isPrivate = this.match(134);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  parseClassElementName(member) {\n    const {\n      type,\n      value\n    } = this.state;\n\n    if ((type === 128 || type === 129) && member.static && value === \"prototype\") {\n      this.raise(Errors.StaticPrototype, {\n        at: this.state.startLoc\n      });\n    }\n\n    if (type === 134) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, {\n          at: this.state.startLoc\n        });\n      }\n\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n\n    return this.parsePropertyName(member);\n  }\n\n  parseClassStaticBlock(classBody, member) {\n    var _member$decorators;\n\n    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(PARAM);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\n      this.raise(Errors.DecoratorStaticBlock, {\n        at: member\n      });\n    }\n  }\n\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(Errors.ConstructorClassField, {\n        at: prop.key\n      });\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(classBody, prop) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);\n  }\n\n  pushClassAccessorProperty(classBody, prop, isPrivate) {\n    if (!isPrivate && !prop.computed) {\n      const key = prop.key;\n\n      if (key.name === \"constructor\" || key.value === \"constructor\") {\n        this.raise(Errors.ConstructorClassField, {\n          at: key\n        });\n      }\n    }\n\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n\n    if (isPrivate) {\n      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.loc.start);\n    }\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === \"set\" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n\n  declareClassPrivateMethodInScope(node, kind) {\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {}\n\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  parseClassProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseClassAccessorProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n\n  parseInitializer(node) {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n\n  parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, {\n          at: this.state.startLoc\n        });\n      }\n    }\n  }\n\n  parseClassSuper(node) {\n    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;\n  }\n\n  parseExport(node) {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node);\n    const parseAfterDefault = !hasDefault || this.eat(12);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {\n      throw this.unexpected(null, 5);\n    }\n\n    let hasDeclaration;\n\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      this.checkExport(node, true, false, !!node.source);\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(65)) {\n      node.declaration = this.parseExportDefaultExpression();\n      this.checkExport(node, true, true);\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n\n    throw this.unexpected(null, 5);\n  }\n\n  eatExportStar(node) {\n    return this.eat(55);\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(93)) {\n      if (!node.specifiers) node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(5)) {\n      if (!node.specifiers) node.specifiers = [];\n      const isTypeExport = node.exportKind === \"type\";\n      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n      node.source = null;\n      node.declaration = null;\n\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n\n    return false;\n  }\n\n  isAsyncFunction() {\n    if (!this.isContextual(95)) return false;\n    const next = this.nextTokenStart();\n    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, \"function\");\n  }\n\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    const isAsync = this.isAsyncFunction();\n\n    if (this.match(68) || isAsync) {\n      this.next();\n\n      if (isAsync) {\n        this.next();\n      }\n\n      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);\n    }\n\n    if (this.match(80)) {\n      return this.parseClass(expr, true, true);\n    }\n\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(Errors.DecoratorBeforeExport, {\n          at: this.state.startLoc\n        });\n      }\n\n      this.parseDecorators(false);\n      return this.parseClass(expr, true, true);\n    }\n\n    if (this.match(75) || this.match(74) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, {\n        at: this.state.startLoc\n      });\n    }\n\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n\n  parseExportDeclaration(node) {\n    return this.parseStatement(null);\n  }\n\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n\n    if (tokenIsIdentifier(type)) {\n      if (type === 95 && !this.state.containsEsc || type === 99) {\n        return false;\n      }\n\n      if ((type === 126 || type === 125) && !this.state.containsEsc) {\n        const {\n          type: nextType\n        } = this.lookahead();\n\n        if (tokenIsIdentifier(nextType) && nextType !== 97 || nextType === 5) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(65)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\n      return true;\n    }\n\n    if (this.match(65) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n\n    return false;\n  }\n\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(97)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      const assertions = this.maybeParseImportAssertions();\n\n      if (assertions) {\n        node.assertions = assertions;\n        this.checkJSONModuleImport(node);\n      }\n    } else if (expect) {\n      this.unexpected();\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n\n    if (type === 26) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          throw this.raise(Errors.DecoratorBeforeExport, {\n            at: this.state.startLoc\n          });\n        }\n\n        return true;\n      }\n    }\n\n    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();\n  }\n\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n\n          const declaration = node.declaration;\n\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, {\n              at: declaration\n            });\n          }\n        }\n      } else if (node.specifiers && node.specifiers.length) {\n        for (const specifier of node.specifiers) {\n          const {\n            exported\n          } = specifier;\n          const exportName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, {\n                at: specifier,\n                localName: local.value,\n                exportName\n              });\n            } else {\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (currentContextDecorators.length) {\n      throw this.raise(Errors.UnsupportedDecoratorExport, {\n        at: node\n      });\n    }\n  }\n\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(node, exportName) {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, {\n          at: node\n        });\n      } else {\n        this.raise(Errors.DuplicateExport, {\n          at: node,\n          exportName\n        });\n      }\n    }\n\n    this.exportedIdentifiers.add(exportName);\n  }\n\n  parseExportSpecifiers(isInTypeExport) {\n    const nodes = [];\n    let first = true;\n    this.expect(5);\n\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n\n      const isMaybeTypeOnly = this.isContextual(126);\n      const isString = this.match(129);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));\n    }\n\n    return nodes;\n  }\n\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (this.eatContextual(93)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n\n    return this.finishNode(node, \"ExportSpecifier\");\n  }\n\n  parseModuleExportName() {\n    if (this.match(129)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = result.value.match(loneSurrogate);\n\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, {\n          at: result,\n          surrogateCharCode: surrogate[0].charCodeAt(0)\n        });\n      }\n\n      return result;\n    }\n\n    return this.parseIdentifier(true);\n  }\n\n  isJSONModuleImport(node) {\n    if (node.assertions != null) {\n      return node.assertions.some(({\n        key,\n        value\n      }) => {\n        return value.value === \"json\" && (key.type === \"Identifier\" ? key.name === \"type\" : key.value === \"type\");\n      });\n    }\n\n    return false;\n  }\n\n  checkJSONModuleImport(node) {\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      const {\n        specifiers\n      } = node;\n\n      if (node.specifiers != null) {\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n\n          if (imported !== undefined) {\n            return imported.type === \"Identifier\" ? imported.name !== \"default\" : imported.value !== \"default\";\n          }\n        });\n\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(Errors.ImportJSONBindingNotDefault, {\n            at: nonDefaultNamedSpecifier.loc.start\n          });\n        }\n      }\n    }\n  }\n\n  parseImport(node) {\n    node.specifiers = [];\n\n    if (!this.match(129)) {\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      const parseNext = !hasDefault || this.eat(12);\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(97);\n    }\n\n    node.source = this.parseImportSource();\n    const assertions = this.maybeParseImportAssertions();\n\n    if (assertions) {\n      node.assertions = assertions;\n    } else {\n      const attributes = this.maybeParseModuleAttributes();\n\n      if (attributes) {\n        node.attributes = attributes;\n      }\n    }\n\n    this.checkJSONModuleImport(node);\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    if (!this.match(129)) this.unexpected();\n    return this.parseExprAtom();\n  }\n\n  shouldParseDefaultImport(node) {\n    return tokenIsIdentifier(this.state.type);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n\n  finishImportSpecifier(specifier, type) {\n    this.checkLVal(specifier.local, {\n      in: specifier,\n      binding: BIND_LEXICAL\n    });\n    return this.finishNode(specifier, type);\n  }\n\n  parseAssertEntries() {\n    const attrs = [];\n    const attrNames = new Set();\n\n    do {\n      if (this.match(8)) {\n        break;\n      }\n\n      const node = this.startNode();\n      const keyName = this.state.value;\n\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: this.state.startLoc,\n          key: keyName\n        });\n      }\n\n      attrNames.add(keyName);\n\n      if (this.match(129)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n\n      this.expect(14);\n\n      if (!this.match(129)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc\n        });\n      }\n\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n\n    return attrs;\n  }\n\n  maybeParseModuleAttributes() {\n    if (this.match(76) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"moduleAttributes\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) return [];\n      return null;\n    }\n\n    const attrs = [];\n    const attributes = new Set();\n\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, {\n          at: node.key\n        });\n      }\n\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: node.key,\n          key: node.key.name\n        });\n      }\n\n      attributes.add(node.key.name);\n      this.expect(14);\n\n      if (!this.match(129)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc\n        });\n      }\n\n      node.value = this.parseStringLiteral(this.state.value);\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(12));\n\n    return attrs;\n  }\n\n  maybeParseImportAssertions() {\n    if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"importAssertions\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"importAssertions\")) return [];\n      return null;\n    }\n\n    this.eat(5);\n    const attrs = this.parseAssertEntries();\n    this.eat(8);\n    return attrs;\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    if (this.shouldParseDefaultImport(node)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(55)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(93);\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(5);\n\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(14)) {\n          throw this.raise(Errors.DestructureNamedImport, {\n            at: this.state.startLoc\n          });\n        }\n\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n\n      const specifier = this.startNode();\n      const importedIsString = this.match(129);\n      const isMaybeTypeOnly = this.isContextual(126);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === \"type\" || node.importKind === \"typeof\", isMaybeTypeOnly);\n      node.specifiers.push(importSpecifier);\n    }\n  }\n\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly) {\n    if (this.eatContextual(93)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, {\n          at: specifier,\n          importName: imported.value\n        });\n      }\n\n      this.checkReservedWord(imported.name, specifier.loc.start, true, true);\n\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n  }\n\n  isThisParam(param) {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n\n}\n\nclass Parser extends StatementParser {\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n\n  parse() {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n\n}\n\nfunction pluginsMap(plugins) {\n  const pluginMap = new Map();\n\n  for (const plugin of plugins) {\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n\n  return pluginMap;\n}\n\nfunction parse(input, options) {\n  var _options;\n\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n\n  return parser.getExpression();\n}\n\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes = {};\n\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n\n  return tokenTypes;\n}\n\nconst tokTypes = generateExportedTokenTypes(tt);\n\nfunction getParser(options, input) {\n  let cls = Parser;\n\n  if (options != null && options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n\n  return new cls(options, input);\n}\n\nconst parserClassCache = {};\n\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n\n  if (!cls) {\n    cls = Parser;\n\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n\n    parserClassCache[key] = cls;\n  }\n\n  return cls;\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = tokTypes;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3BhcnNlci9saWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyREFBMkQ7QUFDN0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEdBQUcsVUFBVSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLCtCQUErQixNQUFNO0FBQ3hDLGtMQUFrTDtBQUNsTCxpR0FBaUcsS0FBSztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFVBQVUsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEdBQTBHLEdBQUcsVUFBVSxRQUFRLFdBQVcsSUFBSTtBQUNqSjtBQUNBO0FBQ0E7QUFDQSxHQUFHLFNBQVMsZ0RBQWdEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixpREFBaUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlGQUF5RixHQUFHLFdBQVcsVUFBVTtBQUNwSDtBQUNBO0FBQ0E7QUFDQSxHQUFHLHNDQUFzQyxpRUFBaUU7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlDQUFpQyxNQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxtQ0FBbUMsYUFBYTtBQUNuRDtBQUNBO0FBQ0EsR0FBRywyQkFBMkIsZUFBZTtBQUM3QztBQUNBO0FBQ0EsR0FBRyxrQ0FBa0MsNEJBQTRCO0FBQ2pFO0FBQ0E7QUFDQSxHQUFHLDBDQUEwQyw0QkFBNEI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDhCQUE4QixXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUcsc0JBQXNCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxlQUFlLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsc0VBQXNFLDJEQUEyRDtBQUNwSTtBQUNBO0FBQ0EsR0FBRywwRkFBMEYsMkRBQTJEO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUJBQXVCLElBQUk7QUFDOUI7QUFDQTtBQUNBLEdBQUcsa0VBQWtFLCtCQUErQjtBQUNwRztBQUNBO0FBQ0EsR0FBRyxnQkFBZ0IsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvRUFBb0UsZUFBZSxtQ0FBbUMsZ0JBQWdCO0FBQ3pJO0FBQ0E7QUFDQSxHQUFHLGdDQUFnQyxlQUFlO0FBQ2xELGdGQUFnRjtBQUNoRixtRkFBbUY7QUFDbkYscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDRCQUE0QixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrQ0FBa0MsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsd0JBQXdCLGtCQUFrQixXQUFXLFNBQVMsRUFBRSwwQkFBMEIsU0FBUyxRQUFRO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlDQUF5QyxRQUFRLEtBQUssT0FBTyxHQUFHLHNCQUFzQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzQkFBc0IsY0FBYztBQUN2QztBQUNBO0FBQ0EsR0FBRyxpQkFBaUIsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLEdBQUcsNEJBQTRCLE1BQU0sb0JBQW9CLE9BQU8sNEVBQTRFLHFDQUFxQyxNQUFNLEdBQUc7QUFDMUwsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQSxHQUFHLDBEQUEwRDtBQUM3RDtBQUNBLEdBQUcsSUFBSTtBQUNQLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG9EQUFvRDtBQUNwRDtBQUNBLEtBQUs7QUFDTCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QixHQUFHLGNBQWMsR0FBRyxnQkFBZ0I7QUFDakYsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNLElBQUk7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQjtBQUN0QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU4sV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTiwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4REFBOEQ7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsS0FBSztBQUNMLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLFFBQVE7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFlBQVk7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx1Q0FBdUMsYUFBYTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGtFQUFrRSxZQUFZLGlCQUFpQixZQUFZLHVCQUF1QixTQUFTO0FBQzlJO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNERBQTRELFdBQVcsNENBQTRDLFNBQVM7QUFDL0g7QUFDQTtBQUNBLEdBQUcsZUFBZSxTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0JBQW9CLGdCQUFnQiwyRkFBMkYsU0FBUztBQUMzSTtBQUNBO0FBQ0EsR0FBRyxpSEFBaUgsU0FBUztBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZUFBZSxTQUFTLGdCQUFnQixhQUFhLDhCQUE4QixXQUFXLG1CQUFtQixjQUFjO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBLEdBQUcseURBQXlELFdBQVcsZ0JBQWdCLFNBQVM7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsR0FBRywwQ0FBMEMsV0FBVywyRUFBMkUsU0FBUztBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMEZBQTBGLFdBQVcsdUJBQXVCLFdBQVcsZ0JBQWdCLFNBQVM7QUFDbks7QUFDQTtBQUNBO0FBQ0EsR0FBRywyREFBMkQsWUFBWSxrQkFBa0IsU0FBUztBQUNyRztBQUNBO0FBQ0EsR0FBRyxnSEFBZ0gsU0FBUztBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpQ0FBaUMsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQTBJLHlCQUF5QjtBQUNuSztBQUNBO0FBQ0E7QUFDQSxHQUFHLHlCQUF5QixzQkFBc0IsNkJBQTZCLFdBQVc7QUFDMUY7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0RBQW9ELGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMkJBQTJCLFdBQVcscUJBQXFCLFdBQVcsU0FBUyxHQUFHLFdBQVcsRUFBRTtBQUNsRztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxHQUFHO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGdCQUFnQixXQUFXO0FBQzlCO0FBQ0E7QUFDQSxHQUFHLGtCQUFrQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywwQkFBMEIsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9DQUFvQyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLDZCQUE2QixTQUFTO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHLFNBQVMsTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFNBQVMsYUFBYSxrQ0FBa0MsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlFQUFpRSxTQUFTO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsU0FBUyxTQUFTO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHLFNBQVMsU0FBUztBQUNyQjtBQUNBO0FBQ0EsR0FBRyxTQUFTLFNBQVM7QUFDckI7QUFDQTtBQUNBLEdBQUcsU0FBUyxvQkFBb0IsMkJBQTJCLG9CQUFvQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlFQUFpRSxTQUFTO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDhCQUE4QixtQkFBbUIsZ0RBQWdELGtCQUFrQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOEZBQThGLEtBQUs7QUFDdEcsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsbUZBQW1GLHFDQUFxQztBQUN4SCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHFGQUFxRixxQ0FBcUM7QUFDMUgsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELEVBQUU7QUFDN0QsbUdBQW1HLGFBQWE7QUFDaEg7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQseUlBQXlJLFVBQVU7QUFDbko7O0FBRUE7QUFDQSx5RUFBeUUsbUNBQW1DLDZCQUE2QixtQkFBbUI7QUFDNUo7QUFDQSxNQUFNO0FBQ04sdUVBQXVFLG1CQUFtQiw2QkFBNkIsbUJBQW1CO0FBQzFJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0pBQWdKLEVBQUU7QUFDbEo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRFQUE0RSxZQUFZO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsOEJBQThCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBLCtDQUErQyxRQUFRO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3RUFBd0U7QUFDeEUsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL0VwanMvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3BhcnNlci9saWIvaW5kZXguanM/ODZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5jbGFzcyBQb3NpdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGxpbmUsIGNvbCwgaW5kZXgpIHtcbiAgICB0aGlzLmxpbmUgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2x1bW4gPSB2b2lkIDA7XG4gICAgdGhpcy5pbmRleCA9IHZvaWQgMDtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgfVxuXG59XG5jbGFzcyBTb3VyY2VMb2NhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gdm9pZCAwO1xuICAgIHRoaXMuZW5kID0gdm9pZCAwO1xuICAgIHRoaXMuZmlsZW5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5pZGVudGlmaWVyTmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gIH1cblxufVxuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHBvc2l0aW9uLCBjb2x1bW5PZmZzZXQpIHtcbiAgY29uc3Qge1xuICAgIGxpbmUsXG4gICAgY29sdW1uLFxuICAgIGluZGV4XG4gIH0gPSBwb3NpdGlvbjtcbiAgcmV0dXJuIG5ldyBQb3NpdGlvbihsaW5lLCBjb2x1bW4gKyBjb2x1bW5PZmZzZXQsIGluZGV4ICsgY29sdW1uT2Zmc2V0KTtcbn1cblxudmFyIFBhcnNlRXJyb3JDb2RlID0ge1xuICBTeW50YXhFcnJvcjogXCJCQUJFTF9QQVJTRVJfU1lOVEFYX0VSUk9SXCIsXG4gIFNvdXJjZVR5cGVNb2R1bGVFcnJvcjogXCJCQUJFTF9QQVJTRVJfU09VUkNFVFlQRV9NT0RVTEVfUkVRVUlSRURcIlxufTtcblxuY29uc3QgcmVmbGVjdCA9IChrZXlzLCBsYXN0ID0ga2V5cy5sZW5ndGggLSAxKSA9PiAoe1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIGtleXMucmVkdWNlKChvYmplY3QsIGtleSkgPT4gb2JqZWN0W2tleV0sIHRoaXMpO1xuICB9LFxuXG4gIHNldCh2YWx1ZSkge1xuICAgIGtleXMucmVkdWNlKChpdGVtLCBrZXksIGkpID0+IGkgPT09IGxhc3QgPyBpdGVtW2tleV0gPSB2YWx1ZSA6IGl0ZW1ba2V5XSwgdGhpcyk7XG4gIH1cblxufSk7XG5cbmNvbnN0IGluc3RhbnRpYXRlID0gKGNvbnN0cnVjdG9yLCBwcm9wZXJ0aWVzLCBkZXNjcmlwdG9ycykgPT4gT2JqZWN0LmtleXMoZGVzY3JpcHRvcnMpLm1hcChrZXkgPT4gW2tleSwgZGVzY3JpcHRvcnNba2V5XV0pLmZpbHRlcigoWywgZGVzY3JpcHRvcl0pID0+ICEhZGVzY3JpcHRvcikubWFwKChba2V5LCBkZXNjcmlwdG9yXSkgPT4gW2tleSwgdHlwZW9mIGRlc2NyaXB0b3IgPT09IFwiZnVuY3Rpb25cIiA/IHtcbiAgdmFsdWU6IGRlc2NyaXB0b3IsXG4gIGVudW1lcmFibGU6IGZhbHNlXG59IDogdHlwZW9mIGRlc2NyaXB0b3IucmVmbGVjdCA9PT0gXCJzdHJpbmdcIiA/IE9iamVjdC5hc3NpZ24oe30sIGRlc2NyaXB0b3IsIHJlZmxlY3QoZGVzY3JpcHRvci5yZWZsZWN0LnNwbGl0KFwiLlwiKSkpIDogZGVzY3JpcHRvcl0pLnJlZHVjZSgoaW5zdGFuY2UsIFtrZXksIGRlc2NyaXB0b3JdKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsIGtleSwgT2JqZWN0LmFzc2lnbih7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSwgZGVzY3JpcHRvcikpLCBPYmplY3QuYXNzaWduKG5ldyBjb25zdHJ1Y3RvcigpLCBwcm9wZXJ0aWVzKSk7XG5cbnZhciBNb2R1bGVFcnJvcnMgPSB7XG4gIEltcG9ydE1ldGFPdXRzaWRlTW9kdWxlOiB7XG4gICAgbWVzc2FnZTogYGltcG9ydC5tZXRhIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBcIm1vZHVsZVwiJ2AsXG4gICAgY29kZTogUGFyc2VFcnJvckNvZGUuU291cmNlVHlwZU1vZHVsZUVycm9yXG4gIH0sXG4gIEltcG9ydE91dHNpZGVNb2R1bGU6IHtcbiAgICBtZXNzYWdlOiBgJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBcIm1vZHVsZVwiJ2AsXG4gICAgY29kZTogUGFyc2VFcnJvckNvZGUuU291cmNlVHlwZU1vZHVsZUVycm9yXG4gIH1cbn07XG5cbmNvbnN0IE5vZGVEZXNjcmlwdGlvbnMgPSB7XG4gIEFycmF5UGF0dGVybjogXCJhcnJheSBkZXN0cnVjdHVyaW5nIHBhdHRlcm5cIixcbiAgQXNzaWdubWVudEV4cHJlc3Npb246IFwiYXNzaWdubWVudCBleHByZXNzaW9uXCIsXG4gIEFzc2lnbm1lbnRQYXR0ZXJuOiBcImFzc2lnbm1lbnQgZXhwcmVzc2lvblwiLFxuICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogXCJhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uXCIsXG4gIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogXCJjb25kaXRpb25hbCBleHByZXNzaW9uXCIsXG4gIENhdGNoQ2xhdXNlOiBcImNhdGNoIGNsYXVzZVwiLFxuICBGb3JPZlN0YXRlbWVudDogXCJmb3Itb2Ygc3RhdGVtZW50XCIsXG4gIEZvckluU3RhdGVtZW50OiBcImZvci1pbiBzdGF0ZW1lbnRcIixcbiAgRm9yU3RhdGVtZW50OiBcImZvci1sb29wXCIsXG4gIEZvcm1hbFBhcmFtZXRlcnM6IFwiZnVuY3Rpb24gcGFyYW1ldGVyIGxpc3RcIixcbiAgSWRlbnRpZmllcjogXCJpZGVudGlmaWVyXCIsXG4gIEltcG9ydFNwZWNpZmllcjogXCJpbXBvcnQgc3BlY2lmaWVyXCIsXG4gIEltcG9ydERlZmF1bHRTcGVjaWZpZXI6IFwiaW1wb3J0IGRlZmF1bHQgc3BlY2lmaWVyXCIsXG4gIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogXCJpbXBvcnQgbmFtZXNwYWNlIHNwZWNpZmllclwiLFxuICBPYmplY3RQYXR0ZXJuOiBcIm9iamVjdCBkZXN0cnVjdHVyaW5nIHBhdHRlcm5cIixcbiAgUGFyZW50aGVzaXplZEV4cHJlc3Npb246IFwicGFyZW50aGVzaXplZCBleHByZXNzaW9uXCIsXG4gIFJlc3RFbGVtZW50OiBcInJlc3QgZWxlbWVudFwiLFxuICBVcGRhdGVFeHByZXNzaW9uOiB7XG4gICAgdHJ1ZTogXCJwcmVmaXggb3BlcmF0aW9uXCIsXG4gICAgZmFsc2U6IFwicG9zdGZpeCBvcGVyYXRpb25cIlxuICB9LFxuICBWYXJpYWJsZURlY2xhcmF0b3I6IFwidmFyaWFibGUgZGVjbGFyYXRpb25cIixcbiAgWWllbGRFeHByZXNzaW9uOiBcInlpZWxkIGV4cHJlc3Npb25cIlxufTtcblxuY29uc3QgdG9Ob2RlRGVzY3JpcHRpb24gPSAoe1xuICB0eXBlLFxuICBwcmVmaXhcbn0pID0+IHR5cGUgPT09IFwiVXBkYXRlRXhwcmVzc2lvblwiID8gTm9kZURlc2NyaXB0aW9ucy5VcGRhdGVFeHByZXNzaW9uW1N0cmluZyhwcmVmaXgpXSA6IE5vZGVEZXNjcmlwdGlvbnNbdHlwZV07XG5cbnZhciBTdGFuZGFyZEVycm9ycyA9IHtcbiAgQWNjZXNzb3JJc0dlbmVyYXRvcjogKHtcbiAgICBraW5kXG4gIH0pID0+IGBBICR7a2luZH10ZXIgY2Fubm90IGJlIGEgZ2VuZXJhdG9yLmAsXG4gIEFyZ3VtZW50c0luQ2xhc3M6IFwiJ2FyZ3VtZW50cycgaXMgb25seSBhbGxvd2VkIGluIGZ1bmN0aW9ucyBhbmQgY2xhc3MgbWV0aG9kcy5cIixcbiAgQXN5bmNGdW5jdGlvbkluU2luZ2xlU3RhdGVtZW50Q29udGV4dDogXCJBc3luYyBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdGhlIHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9jay5cIixcbiAgQXdhaXRCaW5kaW5nSWRlbnRpZmllcjogXCJDYW4gbm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uLlwiLFxuICBBd2FpdEJpbmRpbmdJZGVudGlmaWVySW5TdGF0aWNCbG9jazogXCJDYW4gbm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgc3RhdGljIGJsb2NrLlwiLFxuICBBd2FpdEV4cHJlc3Npb25Gb3JtYWxQYXJhbWV0ZXI6IFwiJ2F3YWl0JyBpcyBub3QgYWxsb3dlZCBpbiBhc3luYyBmdW5jdGlvbiBwYXJhbWV0ZXJzLlwiLFxuICBBd2FpdE5vdEluQXN5bmNDb250ZXh0OiBcIidhd2FpdCcgaXMgb25seSBhbGxvd2VkIHdpdGhpbiBhc3luYyBmdW5jdGlvbnMgYW5kIGF0IHRoZSB0b3AgbGV2ZWxzIG9mIG1vZHVsZXMuXCIsXG4gIEF3YWl0Tm90SW5Bc3luY0Z1bmN0aW9uOiBcIidhd2FpdCcgaXMgb25seSBhbGxvd2VkIHdpdGhpbiBhc3luYyBmdW5jdGlvbnMuXCIsXG4gIEJhZEdldHRlckFyaXR5OiBcIkEgJ2dldCcgYWNjZXNvciBtdXN0IG5vdCBoYXZlIGFueSBmb3JtYWwgcGFyYW1ldGVycy5cIixcbiAgQmFkU2V0dGVyQXJpdHk6IFwiQSAnc2V0JyBhY2Nlc29yIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBmb3JtYWwgcGFyYW1ldGVyLlwiLFxuICBCYWRTZXR0ZXJSZXN0UGFyYW1ldGVyOiBcIkEgJ3NldCcgYWNjZXNvciBmdW5jdGlvbiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIHJlc3QgcGFyYW1ldGVyLlwiLFxuICBDb25zdHJ1Y3RvckNsYXNzRmllbGQ6IFwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgYSBmaWVsZCBuYW1lZCAnY29uc3RydWN0b3InLlwiLFxuICBDb25zdHJ1Y3RvckNsYXNzUHJpdmF0ZUZpZWxkOiBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIGEgcHJpdmF0ZSBmaWVsZCBuYW1lZCAnI2NvbnN0cnVjdG9yJy5cIixcbiAgQ29uc3RydWN0b3JJc0FjY2Vzc29yOiBcIkNsYXNzIGNvbnN0cnVjdG9yIG1heSBub3QgYmUgYW4gYWNjZXNzb3IuXCIsXG4gIENvbnN0cnVjdG9ySXNBc3luYzogXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhbiBhc3luYyBmdW5jdGlvbi5cIixcbiAgQ29uc3RydWN0b3JJc0dlbmVyYXRvcjogXCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvci5cIixcbiAgRGVjbGFyYXRpb25NaXNzaW5nSW5pdGlhbGl6ZXI6ICh7XG4gICAga2luZFxuICB9KSA9PiBgTWlzc2luZyBpbml0aWFsaXplciBpbiAke2tpbmR9IGRlY2xhcmF0aW9uLmAsXG4gIERlY29yYXRvckJlZm9yZUV4cG9ydDogXCJEZWNvcmF0b3JzIG11c3QgYmUgcGxhY2VkICpiZWZvcmUqIHRoZSAnZXhwb3J0JyBrZXl3b3JkLiBZb3UgY2FuIHNldCB0aGUgJ2RlY29yYXRvcnNCZWZvcmVFeHBvcnQnIG9wdGlvbiB0byBmYWxzZSB0byB1c2UgdGhlICdleHBvcnQgQGRlY29yYXRvciBjbGFzcyB7fScgc3ludGF4LlwiLFxuICBEZWNvcmF0b3JDb25zdHJ1Y3RvcjogXCJEZWNvcmF0b3JzIGNhbid0IGJlIHVzZWQgd2l0aCBhIGNvbnN0cnVjdG9yLiBEaWQgeW91IG1lYW4gJ0BkZWMgY2xhc3MgeyAuLi4gfSc/XCIsXG4gIERlY29yYXRvckV4cG9ydENsYXNzOiBcIlVzaW5nIHRoZSBleHBvcnQga2V5d29yZCBiZXR3ZWVuIGEgZGVjb3JhdG9yIGFuZCBhIGNsYXNzIGlzIG5vdCBhbGxvd2VkLiBQbGVhc2UgdXNlIGBleHBvcnQgQGRlYyBjbGFzc2AgaW5zdGVhZC5cIixcbiAgRGVjb3JhdG9yU2VtaWNvbG9uOiBcIkRlY29yYXRvcnMgbXVzdCBub3QgYmUgZm9sbG93ZWQgYnkgYSBzZW1pY29sb24uXCIsXG4gIERlY29yYXRvclN0YXRpY0Jsb2NrOiBcIkRlY29yYXRvcnMgY2FuJ3QgYmUgdXNlZCB3aXRoIGEgc3RhdGljIGJsb2NrLlwiLFxuICBEZWxldGVQcml2YXRlRmllbGQ6IFwiRGVsZXRpbmcgYSBwcml2YXRlIGZpZWxkIGlzIG5vdCBhbGxvd2VkLlwiLFxuICBEZXN0cnVjdHVyZU5hbWVkSW1wb3J0OiBcIkVTMjAxNSBuYW1lZCBpbXBvcnRzIGRvIG5vdCBkZXN0cnVjdHVyZS4gVXNlIGFub3RoZXIgc3RhdGVtZW50IGZvciBkZXN0cnVjdHVyaW5nIGFmdGVyIHRoZSBpbXBvcnQuXCIsXG4gIER1cGxpY2F0ZUNvbnN0cnVjdG9yOiBcIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBpbiB0aGUgc2FtZSBjbGFzcy5cIixcbiAgRHVwbGljYXRlRGVmYXVsdEV4cG9ydDogXCJPbmx5IG9uZSBkZWZhdWx0IGV4cG9ydCBhbGxvd2VkIHBlciBtb2R1bGUuXCIsXG4gIER1cGxpY2F0ZUV4cG9ydDogKHtcbiAgICBleHBvcnROYW1lXG4gIH0pID0+IGBcXGAke2V4cG9ydE5hbWV9XFxgIGhhcyBhbHJlYWR5IGJlZW4gZXhwb3J0ZWQuIEV4cG9ydGVkIGlkZW50aWZpZXJzIG11c3QgYmUgdW5pcXVlLmAsXG4gIER1cGxpY2F0ZVByb3RvOiBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHkuXCIsXG4gIER1cGxpY2F0ZVJlZ0V4cEZsYWdzOiBcIkR1cGxpY2F0ZSByZWd1bGFyIGV4cHJlc3Npb24gZmxhZy5cIixcbiAgRWxlbWVudEFmdGVyUmVzdDogXCJSZXN0IGVsZW1lbnQgbXVzdCBiZSBsYXN0IGVsZW1lbnQuXCIsXG4gIEVzY2FwZWRDaGFyTm90QW5JZGVudGlmaWVyOiBcIkludmFsaWQgVW5pY29kZSBlc2NhcGUuXCIsXG4gIEV4cG9ydEJpbmRpbmdJc1N0cmluZzogKHtcbiAgICBsb2NhbE5hbWUsXG4gICAgZXhwb3J0TmFtZVxuICB9KSA9PiBgQSBzdHJpbmcgbGl0ZXJhbCBjYW5ub3QgYmUgdXNlZCBhcyBhbiBleHBvcnRlZCBiaW5kaW5nIHdpdGhvdXQgXFxgZnJvbVxcYC5cXG4tIERpZCB5b3UgbWVhbiBcXGBleHBvcnQgeyAnJHtsb2NhbE5hbWV9JyBhcyAnJHtleHBvcnROYW1lfScgfSBmcm9tICdzb21lLW1vZHVsZSdcXGA/YCxcbiAgRXhwb3J0RGVmYXVsdEZyb21Bc0lkZW50aWZpZXI6IFwiJ2Zyb20nIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGlkZW50aWZpZXIgYWZ0ZXIgJ2V4cG9ydCBkZWZhdWx0Jy5cIixcbiAgRm9ySW5PZkxvb3BJbml0aWFsaXplcjogKHtcbiAgICB0eXBlXG4gIH0pID0+IGAnJHt0eXBlID09PSBcIkZvckluU3RhdGVtZW50XCIgPyBcImZvci1pblwiIDogXCJmb3Itb2ZcIn0nIGxvb3AgdmFyaWFibGUgZGVjbGFyYXRpb24gbWF5IG5vdCBoYXZlIGFuIGluaXRpYWxpemVyLmAsXG4gIEZvck9mQXN5bmM6IFwiVGhlIGxlZnQtaGFuZCBzaWRlIG9mIGEgZm9yLW9mIGxvb3AgbWF5IG5vdCBiZSAnYXN5bmMnLlwiLFxuICBGb3JPZkxldDogXCJUaGUgbGVmdC1oYW5kIHNpZGUgb2YgYSBmb3Itb2YgbG9vcCBtYXkgbm90IHN0YXJ0IHdpdGggJ2xldCcuXCIsXG4gIEdlbmVyYXRvckluU2luZ2xlU3RhdGVtZW50Q29udGV4dDogXCJHZW5lcmF0b3JzIGNhbiBvbmx5IGJlIGRlY2xhcmVkIGF0IHRoZSB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2suXCIsXG4gIElsbGVnYWxCcmVha0NvbnRpbnVlOiAoe1xuICAgIHR5cGVcbiAgfSkgPT4gYFVuc3ludGFjdGljICR7dHlwZSA9PT0gXCJCcmVha1N0YXRlbWVudFwiID8gXCJicmVha1wiIDogXCJjb250aW51ZVwifS5gLFxuICBJbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlOiBcIklsbGVnYWwgJ3VzZSBzdHJpY3QnIGRpcmVjdGl2ZSBpbiBmdW5jdGlvbiB3aXRoIG5vbi1zaW1wbGUgcGFyYW1ldGVyIGxpc3QuXCIsXG4gIElsbGVnYWxSZXR1cm46IFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvbi5cIixcbiAgSW1wb3J0QmluZGluZ0lzU3RyaW5nOiAoe1xuICAgIGltcG9ydE5hbWVcbiAgfSkgPT4gYEEgc3RyaW5nIGxpdGVyYWwgY2Fubm90IGJlIHVzZWQgYXMgYW4gaW1wb3J0ZWQgYmluZGluZy5cXG4tIERpZCB5b3UgbWVhbiBcXGBpbXBvcnQgeyBcIiR7aW1wb3J0TmFtZX1cIiBhcyBmb28gfVxcYD9gLFxuICBJbXBvcnRDYWxsQXJndW1lbnRUcmFpbGluZ0NvbW1hOiBcIlRyYWlsaW5nIGNvbW1hIGlzIGRpc2FsbG93ZWQgaW5zaWRlIGltcG9ydCguLi4pIGFyZ3VtZW50cy5cIixcbiAgSW1wb3J0Q2FsbEFyaXR5OiAoe1xuICAgIG1heEFyZ3VtZW50Q291bnRcbiAgfSkgPT4gYFxcYGltcG9ydCgpXFxgIHJlcXVpcmVzIGV4YWN0bHkgJHttYXhBcmd1bWVudENvdW50ID09PSAxID8gXCJvbmUgYXJndW1lbnRcIiA6IFwib25lIG9yIHR3byBhcmd1bWVudHNcIn0uYCxcbiAgSW1wb3J0Q2FsbE5vdE5ld0V4cHJlc3Npb246IFwiQ2Fubm90IHVzZSBuZXcgd2l0aCBpbXBvcnQoLi4uKS5cIixcbiAgSW1wb3J0Q2FsbFNwcmVhZEFyZ3VtZW50OiBcImAuLi5gIGlzIG5vdCBhbGxvd2VkIGluIGBpbXBvcnQoKWAuXCIsXG4gIEltcG9ydEpTT05CaW5kaW5nTm90RGVmYXVsdDogXCJBIEpTT04gbW9kdWxlIGNhbiBvbmx5IGJlIGltcG9ydGVkIHdpdGggYGRlZmF1bHRgLlwiLFxuICBJbmNvbXBhdGlibGVSZWdFeHBVVkZsYWdzOiBcIlRoZSAndScgYW5kICd2JyByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ3MgY2Fubm90IGJlIGVuYWJsZWQgYXQgdGhlIHNhbWUgdGltZS5cIixcbiAgSW52YWxpZEJpZ0ludExpdGVyYWw6IFwiSW52YWxpZCBCaWdJbnRMaXRlcmFsLlwiLFxuICBJbnZhbGlkQ29kZVBvaW50OiBcIkNvZGUgcG9pbnQgb3V0IG9mIGJvdW5kcy5cIixcbiAgSW52YWxpZENvdmVySW5pdGlhbGl6ZWROYW1lOiBcIkludmFsaWQgc2hvcnRoYW5kIHByb3BlcnR5IGluaXRpYWxpemVyLlwiLFxuICBJbnZhbGlkRGVjaW1hbDogXCJJbnZhbGlkIGRlY2ltYWwuXCIsXG4gIEludmFsaWREaWdpdDogKHtcbiAgICByYWRpeFxuICB9KSA9PiBgRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4ICR7cmFkaXh9LmAsXG4gIEludmFsaWRFc2NhcGVTZXF1ZW5jZTogXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZS5cIixcbiAgSW52YWxpZEVzY2FwZVNlcXVlbmNlVGVtcGxhdGU6IFwiSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgaW4gdGVtcGxhdGUuXCIsXG4gIEludmFsaWRFc2NhcGVkUmVzZXJ2ZWRXb3JkOiAoe1xuICAgIHJlc2VydmVkV29yZFxuICB9KSA9PiBgRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgJHtyZXNlcnZlZFdvcmR9LmAsXG4gIEludmFsaWRJZGVudGlmaWVyOiAoe1xuICAgIGlkZW50aWZpZXJOYW1lXG4gIH0pID0+IGBJbnZhbGlkIGlkZW50aWZpZXIgJHtpZGVudGlmaWVyTmFtZX0uYCxcbiAgSW52YWxpZExoczogKHtcbiAgICBhbmNlc3RvclxuICB9KSA9PiBgSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiAke3RvTm9kZURlc2NyaXB0aW9uKGFuY2VzdG9yKX0uYCxcbiAgSW52YWxpZExoc0JpbmRpbmc6ICh7XG4gICAgYW5jZXN0b3JcbiAgfSkgPT4gYEJpbmRpbmcgaW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiAke3RvTm9kZURlc2NyaXB0aW9uKGFuY2VzdG9yKX0uYCxcbiAgSW52YWxpZE51bWJlcjogXCJJbnZhbGlkIG51bWJlci5cIixcbiAgSW52YWxpZE9yTWlzc2luZ0V4cG9uZW50OiBcIkZsb2F0aW5nLXBvaW50IG51bWJlcnMgcmVxdWlyZSBhIHZhbGlkIGV4cG9uZW50IGFmdGVyIHRoZSAnZScuXCIsXG4gIEludmFsaWRPclVuZXhwZWN0ZWRUb2tlbjogKHtcbiAgICB1bmV4cGVjdGVkXG4gIH0pID0+IGBVbmV4cGVjdGVkIGNoYXJhY3RlciAnJHt1bmV4cGVjdGVkfScuYCxcbiAgSW52YWxpZFBhcmVudGhlc2l6ZWRBc3NpZ25tZW50OiBcIkludmFsaWQgcGFyZW50aGVzaXplZCBhc3NpZ25tZW50IHBhdHRlcm4uXCIsXG4gIEludmFsaWRQcml2YXRlRmllbGRSZXNvbHV0aW9uOiAoe1xuICAgIGlkZW50aWZpZXJOYW1lXG4gIH0pID0+IGBQcml2YXRlIG5hbWUgIyR7aWRlbnRpZmllck5hbWV9IGlzIG5vdCBkZWZpbmVkLmAsXG4gIEludmFsaWRQcm9wZXJ0eUJpbmRpbmdQYXR0ZXJuOiBcIkJpbmRpbmcgbWVtYmVyIGV4cHJlc3Npb24uXCIsXG4gIEludmFsaWRSZWNvcmRQcm9wZXJ0eTogXCJPbmx5IHByb3BlcnRpZXMgYW5kIHNwcmVhZCBlbGVtZW50cyBhcmUgYWxsb3dlZCBpbiByZWNvcmQgZGVmaW5pdGlvbnMuXCIsXG4gIEludmFsaWRSZXN0QXNzaWdubWVudFBhdHRlcm46IFwiSW52YWxpZCByZXN0IG9wZXJhdG9yJ3MgYXJndW1lbnQuXCIsXG4gIExhYmVsUmVkZWNsYXJhdGlvbjogKHtcbiAgICBsYWJlbE5hbWVcbiAgfSkgPT4gYExhYmVsICcke2xhYmVsTmFtZX0nIGlzIGFscmVhZHkgZGVjbGFyZWQuYCxcbiAgTGV0SW5MZXhpY2FsQmluZGluZzogXCInbGV0JyBpcyBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGFzIGEgbmFtZSBpbiAnbGV0JyBvciAnY29uc3QnIGRlY2xhcmF0aW9ucy5cIixcbiAgTGluZVRlcm1pbmF0b3JCZWZvcmVBcnJvdzogXCJObyBsaW5lIGJyZWFrIGlzIGFsbG93ZWQgYmVmb3JlICc9PicuXCIsXG4gIE1hbGZvcm1lZFJlZ0V4cEZsYWdzOiBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWcuXCIsXG4gIE1pc3NpbmdDbGFzc05hbWU6IFwiQSBjbGFzcyBuYW1lIGlzIHJlcXVpcmVkLlwiLFxuICBNaXNzaW5nRXFJbkFzc2lnbm1lbnQ6IFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIixcbiAgTWlzc2luZ1NlbWljb2xvbjogXCJNaXNzaW5nIHNlbWljb2xvbi5cIixcbiAgTWlzc2luZ1BsdWdpbjogKHtcbiAgICBtaXNzaW5nUGx1Z2luXG4gIH0pID0+IGBUaGlzIGV4cGVyaW1lbnRhbCBzeW50YXggcmVxdWlyZXMgZW5hYmxpbmcgdGhlIHBhcnNlciBwbHVnaW46ICR7bWlzc2luZ1BsdWdpbi5tYXAobmFtZSA9PiBKU09OLnN0cmluZ2lmeShuYW1lKSkuam9pbihcIiwgXCIpfS5gLFxuICBNaXNzaW5nT25lT2ZQbHVnaW5zOiAoe1xuICAgIG1pc3NpbmdQbHVnaW5cbiAgfSkgPT4gYFRoaXMgZXhwZXJpbWVudGFsIHN5bnRheCByZXF1aXJlcyBlbmFibGluZyBvbmUgb2YgdGhlIGZvbGxvd2luZyBwYXJzZXIgcGx1Z2luKHMpOiAke21pc3NpbmdQbHVnaW4ubWFwKG5hbWUgPT4gSlNPTi5zdHJpbmdpZnkobmFtZSkpLmpvaW4oXCIsIFwiKX0uYCxcbiAgTWlzc2luZ1VuaWNvZGVFc2NhcGU6IFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWC5cIixcbiAgTWl4aW5nQ29hbGVzY2VXaXRoTG9naWNhbDogXCJOdWxsaXNoIGNvYWxlc2Npbmcgb3BlcmF0b3IoPz8pIHJlcXVpcmVzIHBhcmVucyB3aGVuIG1peGluZyB3aXRoIGxvZ2ljYWwgb3BlcmF0b3JzLlwiLFxuICBNb2R1bGVBdHRyaWJ1dGVEaWZmZXJlbnRGcm9tVHlwZTogXCJUaGUgb25seSBhY2NlcHRlZCBtb2R1bGUgYXR0cmlidXRlIGlzIGB0eXBlYC5cIixcbiAgTW9kdWxlQXR0cmlidXRlSW52YWxpZFZhbHVlOiBcIk9ubHkgc3RyaW5nIGxpdGVyYWxzIGFyZSBhbGxvd2VkIGFzIG1vZHVsZSBhdHRyaWJ1dGUgdmFsdWVzLlwiLFxuICBNb2R1bGVBdHRyaWJ1dGVzV2l0aER1cGxpY2F0ZUtleXM6ICh7XG4gICAga2V5XG4gIH0pID0+IGBEdXBsaWNhdGUga2V5IFwiJHtrZXl9XCIgaXMgbm90IGFsbG93ZWQgaW4gbW9kdWxlIGF0dHJpYnV0ZXMuYCxcbiAgTW9kdWxlRXhwb3J0TmFtZUhhc0xvbmVTdXJyb2dhdGU6ICh7XG4gICAgc3Vycm9nYXRlQ2hhckNvZGVcbiAgfSkgPT4gYEFuIGV4cG9ydCBuYW1lIGNhbm5vdCBpbmNsdWRlIGEgbG9uZSBzdXJyb2dhdGUsIGZvdW5kICdcXFxcdSR7c3Vycm9nYXRlQ2hhckNvZGUudG9TdHJpbmcoMTYpfScuYCxcbiAgTW9kdWxlRXhwb3J0VW5kZWZpbmVkOiAoe1xuICAgIGxvY2FsTmFtZVxuICB9KSA9PiBgRXhwb3J0ICcke2xvY2FsTmFtZX0nIGlzIG5vdCBkZWZpbmVkLmAsXG4gIE11bHRpcGxlRGVmYXVsdHNJblN3aXRjaDogXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXMuXCIsXG4gIE5ld2xpbmVBZnRlclRocm93OiBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdy5cIixcbiAgTm9DYXRjaE9yRmluYWxseTogXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlLlwiLFxuICBOdW1iZXJJZGVudGlmaWVyOiBcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyLlwiLFxuICBOdW1lcmljU2VwYXJhdG9ySW5Fc2NhcGVTZXF1ZW5jZTogXCJOdW1lcmljIHNlcGFyYXRvcnMgYXJlIG5vdCBhbGxvd2VkIGluc2lkZSB1bmljb2RlIGVzY2FwZSBzZXF1ZW5jZXMgb3IgaGV4IGVzY2FwZSBzZXF1ZW5jZXMuXCIsXG4gIE9ic29sZXRlQXdhaXRTdGFyOiBcIidhd2FpdConIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgYXN5bmMgZnVuY3Rpb25zIHByb3Bvc2FsLiBVc2UgUHJvbWlzZS5hbGwoKSBpbnN0ZWFkLlwiLFxuICBPcHRpb25hbENoYWluaW5nTm9OZXc6IFwiQ29uc3RydWN0b3JzIGluL2FmdGVyIGFuIE9wdGlvbmFsIENoYWluIGFyZSBub3QgYWxsb3dlZC5cIixcbiAgT3B0aW9uYWxDaGFpbmluZ05vVGVtcGxhdGU6IFwiVGFnZ2VkIFRlbXBsYXRlIExpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBvcHRpb25hbENoYWluLlwiLFxuICBPdmVycmlkZU9uQ29uc3RydWN0b3I6IFwiJ292ZXJyaWRlJyBtb2RpZmllciBjYW5ub3QgYXBwZWFyIG9uIGEgY29uc3RydWN0b3IgZGVjbGFyYXRpb24uXCIsXG4gIFBhcmFtRHVwZTogXCJBcmd1bWVudCBuYW1lIGNsYXNoLlwiLFxuICBQYXR0ZXJuSGFzQWNjZXNzb3I6IFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyLlwiLFxuICBQYXR0ZXJuSGFzTWV0aG9kOiBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gbWV0aG9kcy5cIixcbiAgUHJpdmF0ZUluRXhwZWN0ZWRJbjogKHtcbiAgICBpZGVudGlmaWVyTmFtZVxuICB9KSA9PiBgUHJpdmF0ZSBuYW1lcyBhcmUgb25seSBhbGxvd2VkIGluIHByb3BlcnR5IGFjY2Vzc2VzIChcXGBvYmouIyR7aWRlbnRpZmllck5hbWV9XFxgKSBvciBpbiBcXGBpblxcYCBleHByZXNzaW9ucyAoXFxgIyR7aWRlbnRpZmllck5hbWV9IGluIG9ialxcYCkuYCxcbiAgUHJpdmF0ZU5hbWVSZWRlY2xhcmF0aW9uOiAoe1xuICAgIGlkZW50aWZpZXJOYW1lXG4gIH0pID0+IGBEdXBsaWNhdGUgcHJpdmF0ZSBuYW1lICMke2lkZW50aWZpZXJOYW1lfS5gLFxuICBSZWNvcmRFeHByZXNzaW9uQmFySW5jb3JyZWN0RW5kU3ludGF4VHlwZTogXCJSZWNvcmQgZXhwcmVzc2lvbnMgZW5kaW5nIHdpdGggJ3x9JyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnYmFyJy5cIixcbiAgUmVjb3JkRXhwcmVzc2lvbkJhckluY29ycmVjdFN0YXJ0U3ludGF4VHlwZTogXCJSZWNvcmQgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAne3wnIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdiYXInLlwiLFxuICBSZWNvcmRFeHByZXNzaW9uSGFzaEluY29ycmVjdFN0YXJ0U3ludGF4VHlwZTogXCJSZWNvcmQgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAnI3snIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdoYXNoJy5cIixcbiAgUmVjb3JkTm9Qcm90bzogXCInX19wcm90b19fJyBpcyBub3QgYWxsb3dlZCBpbiBSZWNvcmQgZXhwcmVzc2lvbnMuXCIsXG4gIFJlc3RUcmFpbGluZ0NvbW1hOiBcIlVuZXhwZWN0ZWQgdHJhaWxpbmcgY29tbWEgYWZ0ZXIgcmVzdCBlbGVtZW50LlwiLFxuICBTbG9wcHlGdW5jdGlvbjogXCJJbiBub24tc3RyaWN0IG1vZGUgY29kZSwgZnVuY3Rpb25zIGNhbiBvbmx5IGJlIGRlY2xhcmVkIGF0IHRvcCBsZXZlbCwgaW5zaWRlIGEgYmxvY2ssIG9yIGFzIHRoZSBib2R5IG9mIGFuIGlmIHN0YXRlbWVudC5cIixcbiAgU3RhdGljUHJvdG90eXBlOiBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGUuXCIsXG4gIFN1cGVyTm90QWxsb3dlZDogXCJgc3VwZXIoKWAgaXMgb25seSB2YWxpZCBpbnNpZGUgYSBjbGFzcyBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzLiBNYXliZSBhIHR5cG8gaW4gdGhlIG1ldGhvZCBuYW1lICgnY29uc3RydWN0b3InKSBvciBub3QgZXh0ZW5kaW5nIGFub3RoZXIgY2xhc3M/XCIsXG4gIFN1cGVyUHJpdmF0ZUZpZWxkOiBcIlByaXZhdGUgZmllbGRzIGNhbid0IGJlIGFjY2Vzc2VkIG9uIHN1cGVyLlwiLFxuICBUcmFpbGluZ0RlY29yYXRvcjogXCJEZWNvcmF0b3JzIG11c3QgYmUgYXR0YWNoZWQgdG8gYSBjbGFzcyBlbGVtZW50LlwiLFxuICBUdXBsZUV4cHJlc3Npb25CYXJJbmNvcnJlY3RFbmRTeW50YXhUeXBlOiBcIlR1cGxlIGV4cHJlc3Npb25zIGVuZGluZyB3aXRoICd8XScgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2JhcicuXCIsXG4gIFR1cGxlRXhwcmVzc2lvbkJhckluY29ycmVjdFN0YXJ0U3ludGF4VHlwZTogXCJUdXBsZSBleHByZXNzaW9ucyBzdGFydGluZyB3aXRoICdbfCcgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2JhcicuXCIsXG4gIFR1cGxlRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6IFwiVHVwbGUgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAnI1snIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdoYXNoJy5cIixcbiAgVW5leHBlY3RlZEFyZ3VtZW50UGxhY2Vob2xkZXI6IFwiVW5leHBlY3RlZCBhcmd1bWVudCBwbGFjZWhvbGRlci5cIixcbiAgVW5leHBlY3RlZEF3YWl0QWZ0ZXJQaXBlbGluZUJvZHk6ICdVbmV4cGVjdGVkIFwiYXdhaXRcIiBhZnRlciBwaXBlbGluZSBib2R5OyBhd2FpdCBtdXN0IGhhdmUgcGFyZW50aGVzZXMgaW4gbWluaW1hbCBwcm9wb3NhbC4nLFxuICBVbmV4cGVjdGVkRGlnaXRBZnRlckhhc2g6IFwiVW5leHBlY3RlZCBkaWdpdCBhZnRlciBoYXNoIHRva2VuLlwiLFxuICBVbmV4cGVjdGVkSW1wb3J0RXhwb3J0OiBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbC5cIixcbiAgVW5leHBlY3RlZEtleXdvcmQ6ICh7XG4gICAga2V5d29yZFxuICB9KSA9PiBgVW5leHBlY3RlZCBrZXl3b3JkICcke2tleXdvcmR9Jy5gLFxuICBVbmV4cGVjdGVkTGVhZGluZ0RlY29yYXRvcjogXCJMZWFkaW5nIGRlY29yYXRvcnMgbXVzdCBiZSBhdHRhY2hlZCB0byBhIGNsYXNzIGRlY2xhcmF0aW9uLlwiLFxuICBVbmV4cGVjdGVkTGV4aWNhbERlY2xhcmF0aW9uOiBcIkxleGljYWwgZGVjbGFyYXRpb24gY2Fubm90IGFwcGVhciBpbiBhIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dC5cIixcbiAgVW5leHBlY3RlZE5ld1RhcmdldDogXCJgbmV3LnRhcmdldGAgY2FuIG9ubHkgYmUgdXNlZCBpbiBmdW5jdGlvbnMgb3IgY2xhc3MgcHJvcGVydGllcy5cIixcbiAgVW5leHBlY3RlZE51bWVyaWNTZXBhcmF0b3I6IFwiQSBudW1lcmljIHNlcGFyYXRvciBpcyBvbmx5IGFsbG93ZWQgYmV0d2VlbiB0d28gZGlnaXRzLlwiLFxuICBVbmV4cGVjdGVkUHJpdmF0ZUZpZWxkOiBcIlVuZXhwZWN0ZWQgcHJpdmF0ZSBuYW1lLlwiLFxuICBVbmV4cGVjdGVkUmVzZXJ2ZWRXb3JkOiAoe1xuICAgIHJlc2VydmVkV29yZFxuICB9KSA9PiBgVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkICcke3Jlc2VydmVkV29yZH0nLmAsXG4gIFVuZXhwZWN0ZWRTdXBlcjogXCInc3VwZXInIGlzIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbWV0aG9kcyBhbmQgY2xhc3Nlcy5cIixcbiAgVW5leHBlY3RlZFRva2VuOiAoe1xuICAgIGV4cGVjdGVkLFxuICAgIHVuZXhwZWN0ZWRcbiAgfSkgPT4gYFVuZXhwZWN0ZWQgdG9rZW4ke3VuZXhwZWN0ZWQgPyBgICcke3VuZXhwZWN0ZWR9Jy5gIDogXCJcIn0ke2V4cGVjdGVkID8gYCwgZXhwZWN0ZWQgXCIke2V4cGVjdGVkfVwiYCA6IFwiXCJ9YCxcbiAgVW5leHBlY3RlZFRva2VuVW5hcnlFeHBvbmVudGlhdGlvbjogXCJJbGxlZ2FsIGV4cHJlc3Npb24uIFdyYXAgbGVmdCBoYW5kIHNpZGUgb3IgZW50aXJlIGV4cG9uZW50aWF0aW9uIGluIHBhcmVudGhlc2VzLlwiLFxuICBVbnN1cHBvcnRlZEJpbmQ6IFwiQmluZGluZyBzaG91bGQgYmUgcGVyZm9ybWVkIG9uIG9iamVjdCBwcm9wZXJ0eS5cIixcbiAgVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQ6IFwiQSBkZWNvcmF0ZWQgZXhwb3J0IG11c3QgZXhwb3J0IGEgY2xhc3MgZGVjbGFyYXRpb24uXCIsXG4gIFVuc3VwcG9ydGVkRGVmYXVsdEV4cG9ydDogXCJPbmx5IGV4cHJlc3Npb25zLCBmdW5jdGlvbnMgb3IgY2xhc3NlcyBhcmUgYWxsb3dlZCBhcyB0aGUgYGRlZmF1bHRgIGV4cG9ydC5cIixcbiAgVW5zdXBwb3J0ZWRJbXBvcnQ6IFwiYGltcG9ydGAgY2FuIG9ubHkgYmUgdXNlZCBpbiBgaW1wb3J0KClgIG9yIGBpbXBvcnQubWV0YWAuXCIsXG4gIFVuc3VwcG9ydGVkTWV0YVByb3BlcnR5OiAoe1xuICAgIHRhcmdldCxcbiAgICBvbmx5VmFsaWRQcm9wZXJ0eU5hbWVcbiAgfSkgPT4gYFRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yICR7dGFyZ2V0fSBpcyAke3RhcmdldH0uJHtvbmx5VmFsaWRQcm9wZXJ0eU5hbWV9LmAsXG4gIFVuc3VwcG9ydGVkUGFyYW1ldGVyRGVjb3JhdG9yOiBcIkRlY29yYXRvcnMgY2Fubm90IGJlIHVzZWQgdG8gZGVjb3JhdGUgcGFyYW1ldGVycy5cIixcbiAgVW5zdXBwb3J0ZWRQcm9wZXJ0eURlY29yYXRvcjogXCJEZWNvcmF0b3JzIGNhbm5vdCBiZSB1c2VkIHRvIGRlY29yYXRlIG9iamVjdCBsaXRlcmFsIHByb3BlcnRpZXMuXCIsXG4gIFVuc3VwcG9ydGVkU3VwZXI6IFwiJ3N1cGVyJyBjYW4gb25seSBiZSB1c2VkIHdpdGggZnVuY3Rpb24gY2FsbHMgKGkuZS4gc3VwZXIoKSkgb3IgaW4gcHJvcGVydHkgYWNjZXNzZXMgKGkuZS4gc3VwZXIucHJvcCBvciBzdXBlcltwcm9wXSkuXCIsXG4gIFVudGVybWluYXRlZENvbW1lbnQ6IFwiVW50ZXJtaW5hdGVkIGNvbW1lbnQuXCIsXG4gIFVudGVybWluYXRlZFJlZ0V4cDogXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uLlwiLFxuICBVbnRlcm1pbmF0ZWRTdHJpbmc6IFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudC5cIixcbiAgVW50ZXJtaW5hdGVkVGVtcGxhdGU6IFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlLlwiLFxuICBWYXJSZWRlY2xhcmF0aW9uOiAoe1xuICAgIGlkZW50aWZpZXJOYW1lXG4gIH0pID0+IGBJZGVudGlmaWVyICcke2lkZW50aWZpZXJOYW1lfScgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZC5gLFxuICBZaWVsZEJpbmRpbmdJZGVudGlmaWVyOiBcIkNhbiBub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3IuXCIsXG4gIFlpZWxkSW5QYXJhbWV0ZXI6IFwiWWllbGQgZXhwcmVzc2lvbiBpcyBub3QgYWxsb3dlZCBpbiBmb3JtYWwgcGFyYW1ldGVycy5cIixcbiAgWmVyb0RpZ2l0TnVtZXJpY1NlcGFyYXRvcjogXCJOdW1lcmljIHNlcGFyYXRvciBjYW4gbm90IGJlIHVzZWQgYWZ0ZXIgbGVhZGluZyAwLlwiXG59O1xuXG52YXIgU3RyaWN0TW9kZUVycm9ycyA9IHtcbiAgU3RyaWN0RGVsZXRlOiBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlLlwiLFxuICBTdHJpY3RFdmFsQXJndW1lbnRzOiAoe1xuICAgIHJlZmVyZW5jZU5hbWVcbiAgfSkgPT4gYEFzc2lnbmluZyB0byAnJHtyZWZlcmVuY2VOYW1lfScgaW4gc3RyaWN0IG1vZGUuYCxcbiAgU3RyaWN0RXZhbEFyZ3VtZW50c0JpbmRpbmc6ICh7XG4gICAgYmluZGluZ05hbWVcbiAgfSkgPT4gYEJpbmRpbmcgJyR7YmluZGluZ05hbWV9JyBpbiBzdHJpY3QgbW9kZS5gLFxuICBTdHJpY3RGdW5jdGlvbjogXCJJbiBzdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsIG9yIGluc2lkZSBhIGJsb2NrLlwiLFxuICBTdHJpY3ROdW1lcmljRXNjYXBlOiBcIlRoZSBvbmx5IHZhbGlkIG51bWVyaWMgZXNjYXBlIGluIHN0cmljdCBtb2RlIGlzICdcXFxcMCcuXCIsXG4gIFN0cmljdE9jdGFsTGl0ZXJhbDogXCJMZWdhY3kgb2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlLlwiLFxuICBTdHJpY3RXaXRoOiBcIid3aXRoJyBpbiBzdHJpY3QgbW9kZS5cIlxufTtcblxuY29uc3QgVW5wYXJlbnRoZXNpemVkUGlwZUJvZHlEZXNjcmlwdGlvbnMgPSBuZXcgU2V0KFtcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiwgXCJZaWVsZEV4cHJlc3Npb25cIl0pO1xudmFyIFBpcGVsaW5lT3BlcmF0b3JFcnJvcnMgPSB7XG4gIFBpcGVCb2R5SXNUaWdodGVyOiBcIlVuZXhwZWN0ZWQgeWllbGQgYWZ0ZXIgcGlwZWxpbmUgYm9keTsgYW55IHlpZWxkIGV4cHJlc3Npb24gYWN0aW5nIGFzIEhhY2stc3R5bGUgcGlwZSBib2R5IG11c3QgYmUgcGFyZW50aGVzaXplZCBkdWUgdG8gaXRzIGxvb3NlIG9wZXJhdG9yIHByZWNlZGVuY2UuXCIsXG4gIFBpcGVUb3BpY1JlcXVpcmVzSGFja1BpcGVzOiAnVG9waWMgcmVmZXJlbmNlIGlzIHVzZWQsIGJ1dCB0aGUgcGlwZWxpbmVPcGVyYXRvciBwbHVnaW4gd2FzIG5vdCBwYXNzZWQgYSBcInByb3Bvc2FsXCI6IFwiaGFja1wiIG9yIFwic21hcnRcIiBvcHRpb24uJyxcbiAgUGlwZVRvcGljVW5ib3VuZDogXCJUb3BpYyByZWZlcmVuY2UgaXMgdW5ib3VuZDsgaXQgbXVzdCBiZSBpbnNpZGUgYSBwaXBlIGJvZHkuXCIsXG4gIFBpcGVUb3BpY1VuY29uZmlndXJlZFRva2VuOiAoe1xuICAgIHRva2VuXG4gIH0pID0+IGBJbnZhbGlkIHRvcGljIHRva2VuICR7dG9rZW59LiBJbiBvcmRlciB0byB1c2UgJHt0b2tlbn0gYXMgYSB0b3BpYyByZWZlcmVuY2UsIHRoZSBwaXBlbGluZU9wZXJhdG9yIHBsdWdpbiBtdXN0IGJlIGNvbmZpZ3VyZWQgd2l0aCB7IFwicHJvcG9zYWxcIjogXCJoYWNrXCIsIFwidG9waWNUb2tlblwiOiBcIiR7dG9rZW59XCIgfS5gLFxuICBQaXBlVG9waWNVbnVzZWQ6IFwiSGFjay1zdHlsZSBwaXBlIGJvZHkgZG9lcyBub3QgY29udGFpbiBhIHRvcGljIHJlZmVyZW5jZTsgSGFjay1zdHlsZSBwaXBlcyBtdXN0IHVzZSB0b3BpYyBhdCBsZWFzdCBvbmNlLlwiLFxuICBQaXBlVW5wYXJlbnRoZXNpemVkQm9keTogKHtcbiAgICB0eXBlXG4gIH0pID0+IGBIYWNrLXN0eWxlIHBpcGUgYm9keSBjYW5ub3QgYmUgYW4gdW5wYXJlbnRoZXNpemVkICR7dG9Ob2RlRGVzY3JpcHRpb24oe1xuICAgIHR5cGVcbiAgfSl9OyBwbGVhc2Ugd3JhcCBpdCBpbiBwYXJlbnRoZXNlcy5gLFxuICBQaXBlbGluZUJvZHlOb0Fycm93OiAnVW5leHBlY3RlZCBhcnJvdyBcIj0+XCIgYWZ0ZXIgcGlwZWxpbmUgYm9keTsgYXJyb3cgZnVuY3Rpb24gaW4gcGlwZWxpbmUgYm9keSBtdXN0IGJlIHBhcmVudGhlc2l6ZWQuJyxcbiAgUGlwZWxpbmVCb2R5U2VxdWVuY2VFeHByZXNzaW9uOiBcIlBpcGVsaW5lIGJvZHkgbWF5IG5vdCBiZSBhIGNvbW1hLXNlcGFyYXRlZCBzZXF1ZW5jZSBleHByZXNzaW9uLlwiLFxuICBQaXBlbGluZUhlYWRTZXF1ZW5jZUV4cHJlc3Npb246IFwiUGlwZWxpbmUgaGVhZCBzaG91bGQgbm90IGJlIGEgY29tbWEtc2VwYXJhdGVkIHNlcXVlbmNlIGV4cHJlc3Npb24uXCIsXG4gIFBpcGVsaW5lVG9waWNVbnVzZWQ6IFwiUGlwZWxpbmUgaXMgaW4gdG9waWMgc3R5bGUgYnV0IGRvZXMgbm90IHVzZSB0b3BpYyByZWZlcmVuY2UuXCIsXG4gIFByaW1hcnlUb3BpY05vdEFsbG93ZWQ6IFwiVG9waWMgcmVmZXJlbmNlIHdhcyB1c2VkIGluIGEgbGV4aWNhbCBjb250ZXh0IHdpdGhvdXQgdG9waWMgYmluZGluZy5cIixcbiAgUHJpbWFyeVRvcGljUmVxdWlyZXNTbWFydFBpcGVsaW5lOiAnVG9waWMgcmVmZXJlbmNlIGlzIHVzZWQsIGJ1dCB0aGUgcGlwZWxpbmVPcGVyYXRvciBwbHVnaW4gd2FzIG5vdCBwYXNzZWQgYSBcInByb3Bvc2FsXCI6IFwiaGFja1wiIG9yIFwic21hcnRcIiBvcHRpb24uJ1xufTtcblxuY29uc3QgX2V4Y2x1ZGVkJDEgPSBbXCJ0b01lc3NhZ2VcIl0sXG4gICAgICBfZXhjbHVkZWQyJDEgPSBbXCJtZXNzYWdlXCJdO1xuXG5mdW5jdGlvbiB0b1BhcnNlRXJyb3JDb25zdHJ1Y3RvcihfcmVmKSB7XG4gIGxldCB7XG4gICAgdG9NZXNzYWdlXG4gIH0gPSBfcmVmLFxuICAgICAgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCQxKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0b3Ioe1xuICAgIGxvYyxcbiAgICBkZXRhaWxzXG4gIH0pIHtcbiAgICByZXR1cm4gaW5zdGFudGlhdGUoU3ludGF4RXJyb3IsIE9iamVjdC5hc3NpZ24oe30sIHByb3BlcnRpZXMsIHtcbiAgICAgIGxvY1xuICAgIH0pLCB7XG4gICAgICBjbG9uZShvdmVycmlkZXMgPSB7fSkge1xuICAgICAgICBjb25zdCBsb2MgPSBvdmVycmlkZXMubG9jIHx8IHt9O1xuICAgICAgICByZXR1cm4gY29uc3RydWN0b3Ioe1xuICAgICAgICAgIGxvYzogbmV3IFBvc2l0aW9uKFwibGluZVwiIGluIGxvYyA/IGxvYy5saW5lIDogdGhpcy5sb2MubGluZSwgXCJjb2x1bW5cIiBpbiBsb2MgPyBsb2MuY29sdW1uIDogdGhpcy5sb2MuY29sdW1uLCBcImluZGV4XCIgaW4gbG9jID8gbG9jLmluZGV4IDogdGhpcy5sb2MuaW5kZXgpLFxuICAgICAgICAgIGRldGFpbHM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGV0YWlscywgb3ZlcnJpZGVzLmRldGFpbHMpXG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgZGV0YWlsczoge1xuICAgICAgICB2YWx1ZTogZGV0YWlscyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gYCR7dG9NZXNzYWdlKHRoaXMuZGV0YWlscyl9ICgke3RoaXMubG9jLmxpbmV9OiR7dGhpcy5sb2MuY29sdW1ufSlgO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICB9LFxuICAgICAgcG9zOiB7XG4gICAgICAgIHJlZmxlY3Q6IFwibG9jLmluZGV4XCIsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBtaXNzaW5nUGx1Z2luOiBcIm1pc3NpbmdQbHVnaW5cIiBpbiBkZXRhaWxzICYmIHtcbiAgICAgICAgcmVmbGVjdDogXCJkZXRhaWxzLm1pc3NpbmdQbHVnaW5cIixcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQYXJzZUVycm9yRW51bShhcmd1bWVudCwgc3ludGF4UGx1Z2luKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50KSkge1xuICAgIHJldHVybiBwYXJzZUVycm9yVGVtcGxhdGVzID0+IFBhcnNlRXJyb3JFbnVtKHBhcnNlRXJyb3JUZW1wbGF0ZXMsIGFyZ3VtZW50WzBdKTtcbiAgfVxuXG4gIGNvbnN0IFBhcnNlRXJyb3JDb25zdHJ1Y3RvcnMgPSB7fTtcblxuICBmb3IgKGNvbnN0IHJlYXNvbkNvZGUgb2YgT2JqZWN0LmtleXMoYXJndW1lbnQpKSB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBhcmd1bWVudFtyZWFzb25Db2RlXTtcblxuICAgIGNvbnN0IF9yZWYyID0gdHlwZW9mIHRlbXBsYXRlID09PSBcInN0cmluZ1wiID8ge1xuICAgICAgbWVzc2FnZTogKCkgPT4gdGVtcGxhdGVcbiAgICB9IDogdHlwZW9mIHRlbXBsYXRlID09PSBcImZ1bmN0aW9uXCIgPyB7XG4gICAgICBtZXNzYWdlOiB0ZW1wbGF0ZVxuICAgIH0gOiB0ZW1wbGF0ZSxcbiAgICAgICAgICB7XG4gICAgICBtZXNzYWdlXG4gICAgfSA9IF9yZWYyLFxuICAgICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgX2V4Y2x1ZGVkMiQxKTtcblxuICAgIGNvbnN0IHRvTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gKCkgPT4gbWVzc2FnZSA6IG1lc3NhZ2U7XG4gICAgUGFyc2VFcnJvckNvbnN0cnVjdG9yc1tyZWFzb25Db2RlXSA9IHRvUGFyc2VFcnJvckNvbnN0cnVjdG9yKE9iamVjdC5hc3NpZ24oe1xuICAgICAgY29kZTogUGFyc2VFcnJvckNvZGUuU3ludGF4RXJyb3IsXG4gICAgICByZWFzb25Db2RlLFxuICAgICAgdG9NZXNzYWdlXG4gICAgfSwgc3ludGF4UGx1Z2luID8ge1xuICAgICAgc3ludGF4UGx1Z2luXG4gICAgfSA6IHt9LCByZXN0KSk7XG4gIH1cblxuICByZXR1cm4gUGFyc2VFcnJvckNvbnN0cnVjdG9ycztcbn1cbmNvbnN0IEVycm9ycyA9IE9iamVjdC5hc3NpZ24oe30sIFBhcnNlRXJyb3JFbnVtKE1vZHVsZUVycm9ycyksIFBhcnNlRXJyb3JFbnVtKFN0YW5kYXJkRXJyb3JzKSwgUGFyc2VFcnJvckVudW0oU3RyaWN0TW9kZUVycm9ycyksIFBhcnNlRXJyb3JFbnVtYHBpcGVsaW5lT3BlcmF0b3JgKFBpcGVsaW5lT3BlcmF0b3JFcnJvcnMpKTtcblxuY29uc3Qge1xuICBkZWZpbmVQcm9wZXJ0eVxufSA9IE9iamVjdDtcblxuY29uc3QgdG9VbmVudW1lcmFibGUgPSAob2JqZWN0LCBrZXkpID0+IGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB2YWx1ZTogb2JqZWN0W2tleV1cbn0pO1xuXG5mdW5jdGlvbiB0b0VTVHJlZUxvY2F0aW9uKG5vZGUpIHtcbiAgbm9kZS5sb2Muc3RhcnQgJiYgdG9VbmVudW1lcmFibGUobm9kZS5sb2Muc3RhcnQsIFwiaW5kZXhcIik7XG4gIG5vZGUubG9jLmVuZCAmJiB0b1VuZW51bWVyYWJsZShub2RlLmxvYy5lbmQsIFwiaW5kZXhcIik7XG4gIHJldHVybiBub2RlO1xufVxuXG52YXIgZXN0cmVlID0gKHN1cGVyQ2xhc3MgPT4gY2xhc3MgRVNUcmVlUGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgcGFyc2UoKSB7XG4gICAgY29uc3QgZmlsZSA9IHRvRVNUcmVlTG9jYXRpb24oc3VwZXIucGFyc2UoKSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRva2Vucykge1xuICAgICAgZmlsZS50b2tlbnMgPSBmaWxlLnRva2Vucy5tYXAodG9FU1RyZWVMb2NhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cblxuICBwYXJzZVJlZ0V4cExpdGVyYWwoe1xuICAgIHBhdHRlcm4sXG4gICAgZmxhZ3NcbiAgfSkge1xuICAgIGxldCByZWdleCA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHJlZ2V4KTtcbiAgICBub2RlLnJlZ2V4ID0ge1xuICAgICAgcGF0dGVybixcbiAgICAgIGZsYWdzXG4gICAgfTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlQmlnSW50TGl0ZXJhbCh2YWx1ZSkge1xuICAgIGxldCBiaWdJbnQ7XG5cbiAgICB0cnkge1xuICAgICAgYmlnSW50ID0gQmlnSW50KHZhbHVlKTtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICBiaWdJbnQgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbChiaWdJbnQpO1xuICAgIG5vZGUuYmlnaW50ID0gU3RyaW5nKG5vZGUudmFsdWUgfHwgdmFsdWUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VEZWNpbWFsTGl0ZXJhbCh2YWx1ZSkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSBudWxsO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbChkZWNpbWFsKTtcbiAgICBub2RlLmRlY2ltYWwgPSBTdHJpbmcobm9kZS52YWx1ZSB8fCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBlc3RyZWVQYXJzZUxpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiTGl0ZXJhbFwiKTtcbiAgfVxuXG4gIHBhcnNlU3RyaW5nTGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbCh2YWx1ZSk7XG4gIH1cblxuICBwYXJzZU51bWVyaWNMaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHZhbHVlKTtcbiAgfVxuXG4gIHBhcnNlTnVsbExpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKG51bGwpO1xuICB9XG5cbiAgcGFyc2VCb29sZWFuTGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbCh2YWx1ZSk7XG4gIH1cblxuICBkaXJlY3RpdmVUb1N0bXQoZGlyZWN0aXZlKSB7XG4gICAgY29uc3QgZGlyZWN0aXZlTGl0ZXJhbCA9IGRpcmVjdGl2ZS52YWx1ZTtcbiAgICBjb25zdCBzdG10ID0gdGhpcy5zdGFydE5vZGVBdChkaXJlY3RpdmUuc3RhcnQsIGRpcmVjdGl2ZS5sb2Muc3RhcnQpO1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLnN0YXJ0Tm9kZUF0KGRpcmVjdGl2ZUxpdGVyYWwuc3RhcnQsIGRpcmVjdGl2ZUxpdGVyYWwubG9jLnN0YXJ0KTtcbiAgICBleHByZXNzaW9uLnZhbHVlID0gZGlyZWN0aXZlTGl0ZXJhbC5leHRyYS5leHByZXNzaW9uVmFsdWU7XG4gICAgZXhwcmVzc2lvbi5yYXcgPSBkaXJlY3RpdmVMaXRlcmFsLmV4dHJhLnJhdztcbiAgICBzdG10LmV4cHJlc3Npb24gPSB0aGlzLmZpbmlzaE5vZGVBdChleHByZXNzaW9uLCBcIkxpdGVyYWxcIiwgZGlyZWN0aXZlTGl0ZXJhbC5sb2MuZW5kKTtcbiAgICBzdG10LmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZUxpdGVyYWwuZXh0cmEucmF3LnNsaWNlKDEsIC0xKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlQXQoc3RtdCwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIGRpcmVjdGl2ZS5sb2MuZW5kKTtcbiAgfVxuXG4gIGluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKSB7XG4gICAgc3VwZXIuaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICB9XG5cbiAgY2hlY2tEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgIT0gbnVsbCAmJiB0aGlzLmlzT2JqZWN0UHJvcGVydHkobm9kZSkpIHtcbiAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuY2hlY2tEZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gIH1cblxuICBnZXRPYmplY3RPckNsYXNzTWV0aG9kUGFyYW1zKG1ldGhvZCkge1xuICAgIHJldHVybiBtZXRob2QudmFsdWUucGFyYW1zO1xuICB9XG5cbiAgaXNWYWxpZERpcmVjdGl2ZShzdG10KSB7XG4gICAgdmFyIF9zdG10JGV4cHJlc3Npb24kZXh0cjtcblxuICAgIHJldHVybiBzdG10LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmIHN0bXQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJiB0eXBlb2Ygc3RtdC5leHByZXNzaW9uLnZhbHVlID09PSBcInN0cmluZ1wiICYmICEoKF9zdG10JGV4cHJlc3Npb24kZXh0ciA9IHN0bXQuZXhwcmVzc2lvbi5leHRyYSkgIT0gbnVsbCAmJiBfc3RtdCRleHByZXNzaW9uJGV4dHIucGFyZW50aGVzaXplZCk7XG4gIH1cblxuICBwYXJzZUJsb2NrQm9keShub2RlLCBhbGxvd0RpcmVjdGl2ZXMsIHRvcExldmVsLCBlbmQsIGFmdGVyQmxvY2tQYXJzZSkge1xuICAgIHN1cGVyLnBhcnNlQmxvY2tCb2R5KG5vZGUsIGFsbG93RGlyZWN0aXZlcywgdG9wTGV2ZWwsIGVuZCwgYWZ0ZXJCbG9ja1BhcnNlKTtcbiAgICBjb25zdCBkaXJlY3RpdmVTdGF0ZW1lbnRzID0gbm9kZS5kaXJlY3RpdmVzLm1hcChkID0+IHRoaXMuZGlyZWN0aXZlVG9TdG10KGQpKTtcbiAgICBub2RlLmJvZHkgPSBkaXJlY3RpdmVTdGF0ZW1lbnRzLmNvbmNhdChub2RlLmJvZHkpO1xuICAgIGRlbGV0ZSBub2RlLmRpcmVjdGl2ZXM7XG4gIH1cblxuICBwdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIHRoaXMucGFyc2VNZXRob2QobWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIsIFwiQ2xhc3NNZXRob2RcIiwgdHJ1ZSk7XG5cbiAgICBpZiAobWV0aG9kLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICBtZXRob2QudmFsdWUudHlwZVBhcmFtZXRlcnMgPSBtZXRob2QudHlwZVBhcmFtZXRlcnM7XG4gICAgICBkZWxldGUgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzO1xuICAgIH1cblxuICAgIGNsYXNzQm9keS5ib2R5LnB1c2gobWV0aG9kKTtcbiAgfVxuXG4gIHBhcnNlUHJpdmF0ZU5hbWUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICB7XG4gICAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udmVydFByaXZhdGVOYW1lVG9Qcml2YXRlSWRlbnRpZmllcihub2RlKTtcbiAgfVxuXG4gIGNvbnZlcnRQcml2YXRlTmFtZVRvUHJpdmF0ZUlkZW50aWZpZXIobm9kZSkge1xuICAgIGNvbnN0IG5hbWUgPSBzdXBlci5nZXRQcml2YXRlTmFtZVNWKG5vZGUpO1xuICAgIG5vZGUgPSBub2RlO1xuICAgIGRlbGV0ZSBub2RlLmlkO1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgbm9kZS50eXBlID0gXCJQcml2YXRlSWRlbnRpZmllclwiO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgaXNQcml2YXRlTmFtZShub2RlKSB7XG4gICAge1xuICAgICAgaWYgKCF0aGlzLmdldFBsdWdpbk9wdGlvbihcImVzdHJlZVwiLCBcImNsYXNzRmVhdHVyZXNcIikpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmlzUHJpdmF0ZU5hbWUobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIjtcbiAgfVxuXG4gIGdldFByaXZhdGVOYW1lU1Yobm9kZSkge1xuICAgIHtcbiAgICAgIGlmICghdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJlc3RyZWVcIiwgXCJjbGFzc0ZlYXR1cmVzXCIpKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRQcml2YXRlTmFtZVNWKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG5cbiAgcGFyc2VMaXRlcmFsKHZhbHVlLCB0eXBlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlTGl0ZXJhbCh2YWx1ZSwgdHlwZSk7XG4gICAgbm9kZS5yYXcgPSBub2RlLmV4dHJhLnJhdztcbiAgICBkZWxldGUgbm9kZS5leHRyYTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbiwgaXNNZXRob2QgPSBmYWxzZSkge1xuICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbiwgaXNNZXRob2QpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IG5vZGUuYm9keS50eXBlICE9PSBcIkJsb2NrU3RhdGVtZW50XCI7XG4gIH1cblxuICBwYXJzZU1ldGhvZChub2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dEaXJlY3RTdXBlciwgdHlwZSwgaW5DbGFzc1Njb3BlID0gZmFsc2UpIHtcbiAgICBsZXQgZnVuY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGZ1bmNOb2RlLmtpbmQgPSBub2RlLmtpbmQ7XG4gICAgZnVuY05vZGUgPSBzdXBlci5wYXJzZU1ldGhvZChmdW5jTm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93RGlyZWN0U3VwZXIsIHR5cGUsIGluQ2xhc3NTY29wZSk7XG4gICAgZnVuY05vZGUudHlwZSA9IFwiRnVuY3Rpb25FeHByZXNzaW9uXCI7XG4gICAgZGVsZXRlIGZ1bmNOb2RlLmtpbmQ7XG4gICAgbm9kZS52YWx1ZSA9IGZ1bmNOb2RlO1xuXG4gICAgaWYgKHR5cGUgPT09IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIpIHtcbiAgICAgIG5vZGUuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0aG9kRGVmaW5pdGlvblwiKTtcbiAgfVxuXG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eSguLi5hcmdzKSB7XG4gICAgY29uc3QgcHJvcGVydHlOb2RlID0gc3VwZXIucGFyc2VDbGFzc1Byb3BlcnR5KC4uLmFyZ3MpO1xuICAgIHtcbiAgICAgIGlmICghdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJlc3RyZWVcIiwgXCJjbGFzc0ZlYXR1cmVzXCIpKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eU5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BlcnR5Tm9kZS50eXBlID0gXCJQcm9wZXJ0eURlZmluaXRpb25cIjtcbiAgICByZXR1cm4gcHJvcGVydHlOb2RlO1xuICB9XG5cbiAgcGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eSguLi5hcmdzKSB7XG4gICAgY29uc3QgcHJvcGVydHlOb2RlID0gc3VwZXIucGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eSguLi5hcmdzKTtcbiAgICB7XG4gICAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wZXJ0eU5vZGUudHlwZSA9IFwiUHJvcGVydHlEZWZpbml0aW9uXCI7XG4gICAgcHJvcGVydHlOb2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHByb3BlcnR5Tm9kZTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0TWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VPYmplY3RNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3Nvcik7XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS50eXBlID0gXCJQcm9wZXJ0eVwiO1xuXG4gICAgICBpZiAobm9kZS5raW5kID09PSBcIm1ldGhvZFwiKSB7XG4gICAgICAgIG5vZGUua2luZCA9IFwiaW5pdFwiO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VPYmplY3RQcm9wZXJ0eShwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZU9iamVjdFByb3BlcnR5KHByb3AsIHN0YXJ0UG9zLCBzdGFydExvYywgaXNQYXR0ZXJuLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcblxuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLmtpbmQgPSBcImluaXRcIjtcbiAgICAgIG5vZGUudHlwZSA9IFwiUHJvcGVydHlcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGlzVmFsaWRMVmFsKHR5cGUsIGlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24sIGJpbmRpbmcpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJQcm9wZXJ0eVwiID8gXCJ2YWx1ZVwiIDogc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgaXNVbnBhcmVudGhlc2l6ZWRJbkFzc2lnbiwgYmluZGluZyk7XG4gIH1cblxuICBpc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKSB7XG4gICAgaWYgKG5vZGUgIT0gbnVsbCAmJiB0aGlzLmlzT2JqZWN0UHJvcGVydHkobm9kZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5pc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKTtcbiAgfVxuXG4gIHRvQXNzaWduYWJsZShub2RlLCBpc0xIUyA9IGZhbHNlKSB7XG4gICAgaWYgKG5vZGUgIT0gbnVsbCAmJiB0aGlzLmlzT2JqZWN0UHJvcGVydHkobm9kZSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IG5vZGU7XG5cbiAgICAgIGlmICh0aGlzLmlzUHJpdmF0ZU5hbWUoa2V5KSkge1xuICAgICAgICB0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUodGhpcy5nZXRQcml2YXRlTmFtZVNWKGtleSksIGtleS5sb2Muc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRvQXNzaWduYWJsZSh2YWx1ZSwgaXNMSFMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci50b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMpO1xuICAgIH1cbiAgfVxuXG4gIHRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpIHtcbiAgICBpZiAocHJvcC5raW5kID09PSBcImdldFwiIHx8IHByb3Aua2luZCA9PT0gXCJzZXRcIikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUGF0dGVybkhhc0FjY2Vzc29yLCB7XG4gICAgICAgIGF0OiBwcm9wLmtleVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwcm9wLm1ldGhvZCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUGF0dGVybkhhc01ldGhvZCwge1xuICAgICAgICBhdDogcHJvcC5rZXlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci50b0Fzc2lnbmFibGVPYmplY3RFeHByZXNzaW9uUHJvcChwcm9wLCBpc0xhc3QsIGlzTEhTKTtcbiAgICB9XG4gIH1cblxuICBmaW5pc2hDYWxsRXhwcmVzc2lvbih1bmZpbmlzaGVkLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5maW5pc2hDYWxsRXhwcmVzc2lvbih1bmZpbmlzaGVkLCBvcHRpb25hbCk7XG5cbiAgICBpZiAobm9kZS5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRcIikge1xuICAgICAgbm9kZS50eXBlID0gXCJJbXBvcnRFeHByZXNzaW9uXCI7XG4gICAgICBub2RlLnNvdXJjZSA9IG5vZGUuYXJndW1lbnRzWzBdO1xuXG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJpbXBvcnRBc3NlcnRpb25zXCIpKSB7XG4gICAgICAgIHZhciBfbm9kZSRhcmd1bWVudHMkO1xuXG4gICAgICAgIG5vZGUuYXR0cmlidXRlcyA9IChfbm9kZSRhcmd1bWVudHMkID0gbm9kZS5hcmd1bWVudHNbMV0pICE9IG51bGwgPyBfbm9kZSRhcmd1bWVudHMkIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIG5vZGUuYXJndW1lbnRzO1xuICAgICAgZGVsZXRlIG5vZGUuY2FsbGVlO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdG9SZWZlcmVuY2VkQXJndW1lbnRzKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkltcG9ydEV4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1cGVyLnRvUmVmZXJlbmNlZEFyZ3VtZW50cyhub2RlKTtcbiAgfVxuXG4gIHBhcnNlRXhwb3J0KHVuZmluaXNoZWQpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VFeHBvcnQodW5maW5pc2hlZCk7XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgICAgIG5vZGUuZXhwb3J0ZWQgPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIjpcbiAgICAgICAgaWYgKG5vZGUuc3BlY2lmaWVycy5sZW5ndGggPT09IDEgJiYgbm9kZS5zcGVjaWZpZXJzWzBdLnR5cGUgPT09IFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpIHtcbiAgICAgICAgICBub2RlLnR5cGUgPSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCI7XG4gICAgICAgICAgbm9kZS5leHBvcnRlZCA9IG5vZGUuc3BlY2lmaWVyc1swXS5leHBvcnRlZDtcbiAgICAgICAgICBkZWxldGUgbm9kZS5zcGVjaWZpZXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIikge1xuICAgICAgICBub2RlLnR5cGUgPSBub2RlLnR5cGUuc3Vic3RyaW5nKDgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuc3RvcCkge1xuICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMuc3RhcnROb2RlQXROb2RlKG5vZGUpO1xuICAgICAgICBjaGFpbi5leHByZXNzaW9uID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShjaGFpbiwgXCJDaGFpbkV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBoYXNQcm9wZXJ0eUFzUHJpdmF0ZU5hbWUobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiQ2hhaW5FeHByZXNzaW9uXCIpIHtcbiAgICAgIG5vZGUgPSBub2RlLmV4cHJlc3Npb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmhhc1Byb3BlcnR5QXNQcml2YXRlTmFtZShub2RlKTtcbiAgfVxuXG4gIGlzT3B0aW9uYWxDaGFpbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJDaGFpbkV4cHJlc3Npb25cIjtcbiAgfVxuXG4gIGlzT2JqZWN0UHJvcGVydHkobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJvcGVydHlcIiAmJiBub2RlLmtpbmQgPT09IFwiaW5pdFwiICYmICFub2RlLm1ldGhvZDtcbiAgfVxuXG4gIGlzT2JqZWN0TWV0aG9kKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5tZXRob2QgfHwgbm9kZS5raW5kID09PSBcImdldFwiIHx8IG5vZGUua2luZCA9PT0gXCJzZXRcIjtcbiAgfVxuXG4gIGZpbmlzaE5vZGVBdChub2RlLCB0eXBlLCBlbmRMb2MpIHtcbiAgICByZXR1cm4gdG9FU1RyZWVMb2NhdGlvbihzdXBlci5maW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgZW5kTG9jKSk7XG4gIH1cblxuICByZXNldFN0YXJ0TG9jYXRpb24obm9kZSwgc3RhcnQsIHN0YXJ0TG9jKSB7XG4gICAgc3VwZXIucmVzZXRTdGFydExvY2F0aW9uKG5vZGUsIHN0YXJ0LCBzdGFydExvYyk7XG4gICAgdG9FU1RyZWVMb2NhdGlvbihub2RlKTtcbiAgfVxuXG4gIHJlc2V0RW5kTG9jYXRpb24obm9kZSwgZW5kTG9jID0gdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKSB7XG4gICAgc3VwZXIucmVzZXRFbmRMb2NhdGlvbihub2RlLCBlbmRMb2MpO1xuICAgIHRvRVNUcmVlTG9jYXRpb24obm9kZSk7XG4gIH1cblxufSk7XG5cbmNsYXNzIFRva0NvbnRleHQge1xuICBjb25zdHJ1Y3Rvcih0b2tlbiwgcHJlc2VydmVTcGFjZSkge1xuICAgIHRoaXMudG9rZW4gPSB2b2lkIDA7XG4gICAgdGhpcy5wcmVzZXJ2ZVNwYWNlID0gdm9pZCAwO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLnByZXNlcnZlU3BhY2UgPSAhIXByZXNlcnZlU3BhY2U7XG4gIH1cblxufVxuY29uc3QgdHlwZXMgPSB7XG4gIGJyYWNlOiBuZXcgVG9rQ29udGV4dChcIntcIiksXG4gIGpfb1RhZzogbmV3IFRva0NvbnRleHQoXCI8dGFnXCIpLFxuICBqX2NUYWc6IG5ldyBUb2tDb250ZXh0KFwiPC90YWdcIiksXG4gIGpfZXhwcjogbmV3IFRva0NvbnRleHQoXCI8dGFnPi4uLjwvdGFnPlwiLCB0cnVlKVxufTtcbntcbiAgdHlwZXMudGVtcGxhdGUgPSBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSk7XG59XG5cbmNvbnN0IGJlZm9yZUV4cHIgPSB0cnVlO1xuY29uc3Qgc3RhcnRzRXhwciA9IHRydWU7XG5jb25zdCBpc0xvb3AgPSB0cnVlO1xuY29uc3QgaXNBc3NpZ24gPSB0cnVlO1xuY29uc3QgcHJlZml4ID0gdHJ1ZTtcbmNvbnN0IHBvc3RmaXggPSB0cnVlO1xuY2xhc3MgRXhwb3J0ZWRUb2tlblR5cGUge1xuICBjb25zdHJ1Y3RvcihsYWJlbCwgY29uZiA9IHt9KSB7XG4gICAgdGhpcy5sYWJlbCA9IHZvaWQgMDtcbiAgICB0aGlzLmtleXdvcmQgPSB2b2lkIDA7XG4gICAgdGhpcy5iZWZvcmVFeHByID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhcnRzRXhwciA9IHZvaWQgMDtcbiAgICB0aGlzLnJpZ2h0QXNzb2NpYXRpdmUgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0xvb3AgPSB2b2lkIDA7XG4gICAgdGhpcy5pc0Fzc2lnbiA9IHZvaWQgMDtcbiAgICB0aGlzLnByZWZpeCA9IHZvaWQgMDtcbiAgICB0aGlzLnBvc3RmaXggPSB2b2lkIDA7XG4gICAgdGhpcy5iaW5vcCA9IHZvaWQgMDtcbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5rZXl3b3JkID0gY29uZi5rZXl3b3JkO1xuICAgIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICAgIHRoaXMuc3RhcnRzRXhwciA9ICEhY29uZi5zdGFydHNFeHByO1xuICAgIHRoaXMucmlnaHRBc3NvY2lhdGl2ZSA9ICEhY29uZi5yaWdodEFzc29jaWF0aXZlO1xuICAgIHRoaXMuaXNMb29wID0gISFjb25mLmlzTG9vcDtcbiAgICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICAgIHRoaXMucHJlZml4ID0gISFjb25mLnByZWZpeDtcbiAgICB0aGlzLnBvc3RmaXggPSAhIWNvbmYucG9zdGZpeDtcbiAgICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCAhPSBudWxsID8gY29uZi5iaW5vcCA6IG51bGw7XG4gICAge1xuICAgICAgdGhpcy51cGRhdGVDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxufVxuY29uc3Qga2V5d29yZHMkMSA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gY3JlYXRlS2V5d29yZChuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgY29uc3QgdG9rZW4gPSBjcmVhdGVUb2tlbihuYW1lLCBvcHRpb25zKTtcbiAga2V5d29yZHMkMS5zZXQobmFtZSwgdG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJpbm9wKG5hbWUsIGJpbm9wKSB7XG4gIHJldHVybiBjcmVhdGVUb2tlbihuYW1lLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcFxuICB9KTtcbn1cblxubGV0IHRva2VuVHlwZUNvdW50ZXIgPSAtMTtcbmNvbnN0IHRva2VuVHlwZXMgPSBbXTtcbmNvbnN0IHRva2VuTGFiZWxzID0gW107XG5jb25zdCB0b2tlbkJpbm9wcyA9IFtdO1xuY29uc3QgdG9rZW5CZWZvcmVFeHBycyA9IFtdO1xuY29uc3QgdG9rZW5TdGFydHNFeHBycyA9IFtdO1xuY29uc3QgdG9rZW5QcmVmaXhlcyA9IFtdO1xuXG5mdW5jdGlvbiBjcmVhdGVUb2tlbihuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9vcHRpb25zJGJpbm9wLCBfb3B0aW9ucyRiZWZvcmVFeHByLCBfb3B0aW9ucyRzdGFydHNFeHByLCBfb3B0aW9ucyRwcmVmaXg7XG5cbiAgKyt0b2tlblR5cGVDb3VudGVyO1xuICB0b2tlbkxhYmVscy5wdXNoKG5hbWUpO1xuICB0b2tlbkJpbm9wcy5wdXNoKChfb3B0aW9ucyRiaW5vcCA9IG9wdGlvbnMuYmlub3ApICE9IG51bGwgPyBfb3B0aW9ucyRiaW5vcCA6IC0xKTtcbiAgdG9rZW5CZWZvcmVFeHBycy5wdXNoKChfb3B0aW9ucyRiZWZvcmVFeHByID0gb3B0aW9ucy5iZWZvcmVFeHByKSAhPSBudWxsID8gX29wdGlvbnMkYmVmb3JlRXhwciA6IGZhbHNlKTtcbiAgdG9rZW5TdGFydHNFeHBycy5wdXNoKChfb3B0aW9ucyRzdGFydHNFeHByID0gb3B0aW9ucy5zdGFydHNFeHByKSAhPSBudWxsID8gX29wdGlvbnMkc3RhcnRzRXhwciA6IGZhbHNlKTtcbiAgdG9rZW5QcmVmaXhlcy5wdXNoKChfb3B0aW9ucyRwcmVmaXggPSBvcHRpb25zLnByZWZpeCkgIT0gbnVsbCA/IF9vcHRpb25zJHByZWZpeCA6IGZhbHNlKTtcbiAgdG9rZW5UeXBlcy5wdXNoKG5ldyBFeHBvcnRlZFRva2VuVHlwZShuYW1lLCBvcHRpb25zKSk7XG4gIHJldHVybiB0b2tlblR5cGVDb3VudGVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXl3b3JkTGlrZShuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9vcHRpb25zJGJpbm9wMiwgX29wdGlvbnMkYmVmb3JlRXhwcjIsIF9vcHRpb25zJHN0YXJ0c0V4cHIyLCBfb3B0aW9ucyRwcmVmaXgyO1xuXG4gICsrdG9rZW5UeXBlQ291bnRlcjtcbiAga2V5d29yZHMkMS5zZXQobmFtZSwgdG9rZW5UeXBlQ291bnRlcik7XG4gIHRva2VuTGFiZWxzLnB1c2gobmFtZSk7XG4gIHRva2VuQmlub3BzLnB1c2goKF9vcHRpb25zJGJpbm9wMiA9IG9wdGlvbnMuYmlub3ApICE9IG51bGwgPyBfb3B0aW9ucyRiaW5vcDIgOiAtMSk7XG4gIHRva2VuQmVmb3JlRXhwcnMucHVzaCgoX29wdGlvbnMkYmVmb3JlRXhwcjIgPSBvcHRpb25zLmJlZm9yZUV4cHIpICE9IG51bGwgPyBfb3B0aW9ucyRiZWZvcmVFeHByMiA6IGZhbHNlKTtcbiAgdG9rZW5TdGFydHNFeHBycy5wdXNoKChfb3B0aW9ucyRzdGFydHNFeHByMiA9IG9wdGlvbnMuc3RhcnRzRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJHN0YXJ0c0V4cHIyIDogZmFsc2UpO1xuICB0b2tlblByZWZpeGVzLnB1c2goKF9vcHRpb25zJHByZWZpeDIgPSBvcHRpb25zLnByZWZpeCkgIT0gbnVsbCA/IF9vcHRpb25zJHByZWZpeDIgOiBmYWxzZSk7XG4gIHRva2VuVHlwZXMucHVzaChuZXcgRXhwb3J0ZWRUb2tlblR5cGUoXCJuYW1lXCIsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHRva2VuVHlwZUNvdW50ZXI7XG59XG5cbmNvbnN0IHR0ID0ge1xuICBicmFja2V0TDogY3JlYXRlVG9rZW4oXCJbXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJyYWNrZXRIYXNoTDogY3JlYXRlVG9rZW4oXCIjW1wiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFja2V0QmFyTDogY3JlYXRlVG9rZW4oXCJbfFwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFja2V0UjogY3JlYXRlVG9rZW4oXCJdXCIpLFxuICBicmFja2V0QmFyUjogY3JlYXRlVG9rZW4oXCJ8XVwiKSxcbiAgYnJhY2VMOiBjcmVhdGVUb2tlbihcIntcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYnJhY2VCYXJMOiBjcmVhdGVUb2tlbihcInt8XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJyYWNlSGFzaEw6IGNyZWF0ZVRva2VuKFwiI3tcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYnJhY2VSOiBjcmVhdGVUb2tlbihcIn1cIiksXG4gIGJyYWNlQmFyUjogY3JlYXRlVG9rZW4oXCJ8fVwiKSxcbiAgcGFyZW5MOiBjcmVhdGVUb2tlbihcIihcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgcGFyZW5SOiBjcmVhdGVUb2tlbihcIilcIiksXG4gIGNvbW1hOiBjcmVhdGVUb2tlbihcIixcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIHNlbWk6IGNyZWF0ZVRva2VuKFwiO1wiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgY29sb246IGNyZWF0ZVRva2VuKFwiOlwiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgZG91YmxlQ29sb246IGNyZWF0ZVRva2VuKFwiOjpcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGRvdDogY3JlYXRlVG9rZW4oXCIuXCIpLFxuICBxdWVzdGlvbjogY3JlYXRlVG9rZW4oXCI/XCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBxdWVzdGlvbkRvdDogY3JlYXRlVG9rZW4oXCI/LlwiKSxcbiAgYXJyb3c6IGNyZWF0ZVRva2VuKFwiPT5cIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIHRlbXBsYXRlOiBjcmVhdGVUb2tlbihcInRlbXBsYXRlXCIpLFxuICBlbGxpcHNpczogY3JlYXRlVG9rZW4oXCIuLi5cIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGJhY2tRdW90ZTogY3JlYXRlVG9rZW4oXCJgXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBkb2xsYXJCcmFjZUw6IGNyZWF0ZVRva2VuKFwiJHtcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgdGVtcGxhdGVUYWlsOiBjcmVhdGVUb2tlbihcIi4uLmBcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHRlbXBsYXRlTm9uVGFpbDogY3JlYXRlVG9rZW4oXCIuLi4ke1wiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBhdDogY3JlYXRlVG9rZW4oXCJAXCIpLFxuICBoYXNoOiBjcmVhdGVUb2tlbihcIiNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGludGVycHJldGVyRGlyZWN0aXZlOiBjcmVhdGVUb2tlbihcIiMhLi4uXCIpLFxuICBlcTogY3JlYXRlVG9rZW4oXCI9XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGlzQXNzaWduXG4gIH0pLFxuICBhc3NpZ246IGNyZWF0ZVRva2VuKFwiXz1cIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgaXNBc3NpZ25cbiAgfSksXG4gIHNsYXNoQXNzaWduOiBjcmVhdGVUb2tlbihcIl89XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGlzQXNzaWduXG4gIH0pLFxuICB4b3JBc3NpZ246IGNyZWF0ZVRva2VuKFwiXz1cIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgaXNBc3NpZ25cbiAgfSksXG4gIG1vZHVsb0Fzc2lnbjogY3JlYXRlVG9rZW4oXCJfPVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBpc0Fzc2lnblxuICB9KSxcbiAgaW5jRGVjOiBjcmVhdGVUb2tlbihcIisrLy0tXCIsIHtcbiAgICBwcmVmaXgsXG4gICAgcG9zdGZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBiYW5nOiBjcmVhdGVUb2tlbihcIiFcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgcHJlZml4LFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHRpbGRlOiBjcmVhdGVUb2tlbihcIn5cIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgcHJlZml4LFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGRvdWJsZUNhcmV0OiBjcmVhdGVUb2tlbihcIl5eXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBkb3VibGVBdDogY3JlYXRlVG9rZW4oXCJAQFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgcGlwZWxpbmU6IGNyZWF0ZUJpbm9wKFwifD5cIiwgMCksXG4gIG51bGxpc2hDb2FsZXNjaW5nOiBjcmVhdGVCaW5vcChcIj8/XCIsIDEpLFxuICBsb2dpY2FsT1I6IGNyZWF0ZUJpbm9wKFwifHxcIiwgMSksXG4gIGxvZ2ljYWxBTkQ6IGNyZWF0ZUJpbm9wKFwiJiZcIiwgMiksXG4gIGJpdHdpc2VPUjogY3JlYXRlQmlub3AoXCJ8XCIsIDMpLFxuICBiaXR3aXNlWE9SOiBjcmVhdGVCaW5vcChcIl5cIiwgNCksXG4gIGJpdHdpc2VBTkQ6IGNyZWF0ZUJpbm9wKFwiJlwiLCA1KSxcbiAgZXF1YWxpdHk6IGNyZWF0ZUJpbm9wKFwiPT0vIT0vPT09LyE9PVwiLCA2KSxcbiAgbHQ6IGNyZWF0ZUJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICBndDogY3JlYXRlQmlub3AoXCI8Lz4vPD0vPj1cIiwgNyksXG4gIHJlbGF0aW9uYWw6IGNyZWF0ZUJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICBiaXRTaGlmdDogY3JlYXRlQmlub3AoXCI8PC8+Pi8+Pj5cIiwgOCksXG4gIGJpdFNoaWZ0TDogY3JlYXRlQmlub3AoXCI8PC8+Pi8+Pj5cIiwgOCksXG4gIGJpdFNoaWZ0UjogY3JlYXRlQmlub3AoXCI8PC8+Pi8+Pj5cIiwgOCksXG4gIHBsdXNNaW46IGNyZWF0ZVRva2VuKFwiKy8tXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGJpbm9wOiA5LFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBtb2R1bG86IGNyZWF0ZVRva2VuKFwiJVwiLCB7XG4gICAgYmlub3A6IDEwLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHN0YXI6IGNyZWF0ZVRva2VuKFwiKlwiLCB7XG4gICAgYmlub3A6IDEwXG4gIH0pLFxuICBzbGFzaDogY3JlYXRlQmlub3AoXCIvXCIsIDEwKSxcbiAgZXhwb25lbnQ6IGNyZWF0ZVRva2VuKFwiKipcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgYmlub3A6IDExLFxuICAgIHJpZ2h0QXNzb2NpYXRpdmU6IHRydWVcbiAgfSksXG4gIF9pbjogY3JlYXRlS2V5d29yZChcImluXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGJpbm9wOiA3XG4gIH0pLFxuICBfaW5zdGFuY2VvZjogY3JlYXRlS2V5d29yZChcImluc3RhbmNlb2ZcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgYmlub3A6IDdcbiAgfSksXG4gIF9icmVhazogY3JlYXRlS2V5d29yZChcImJyZWFrXCIpLFxuICBfY2FzZTogY3JlYXRlS2V5d29yZChcImNhc2VcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9jYXRjaDogY3JlYXRlS2V5d29yZChcImNhdGNoXCIpLFxuICBfY29udGludWU6IGNyZWF0ZUtleXdvcmQoXCJjb250aW51ZVwiKSxcbiAgX2RlYnVnZ2VyOiBjcmVhdGVLZXl3b3JkKFwiZGVidWdnZXJcIiksXG4gIF9kZWZhdWx0OiBjcmVhdGVLZXl3b3JkKFwiZGVmYXVsdFwiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgX2Vsc2U6IGNyZWF0ZUtleXdvcmQoXCJlbHNlXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBfZmluYWxseTogY3JlYXRlS2V5d29yZChcImZpbmFsbHlcIiksXG4gIF9mdW5jdGlvbjogY3JlYXRlS2V5d29yZChcImZ1bmN0aW9uXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfaWY6IGNyZWF0ZUtleXdvcmQoXCJpZlwiKSxcbiAgX3JldHVybjogY3JlYXRlS2V5d29yZChcInJldHVyblwiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgX3N3aXRjaDogY3JlYXRlS2V5d29yZChcInN3aXRjaFwiKSxcbiAgX3Rocm93OiBjcmVhdGVLZXl3b3JkKFwidGhyb3dcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgcHJlZml4LFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF90cnk6IGNyZWF0ZUtleXdvcmQoXCJ0cnlcIiksXG4gIF92YXI6IGNyZWF0ZUtleXdvcmQoXCJ2YXJcIiksXG4gIF9jb25zdDogY3JlYXRlS2V5d29yZChcImNvbnN0XCIpLFxuICBfd2l0aDogY3JlYXRlS2V5d29yZChcIndpdGhcIiksXG4gIF9uZXc6IGNyZWF0ZUtleXdvcmQoXCJuZXdcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3RoaXM6IGNyZWF0ZUtleXdvcmQoXCJ0aGlzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfc3VwZXI6IGNyZWF0ZUtleXdvcmQoXCJzdXBlclwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2NsYXNzOiBjcmVhdGVLZXl3b3JkKFwiY2xhc3NcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9leHRlbmRzOiBjcmVhdGVLZXl3b3JkKFwiZXh0ZW5kc1wiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgX2V4cG9ydDogY3JlYXRlS2V5d29yZChcImV4cG9ydFwiKSxcbiAgX2ltcG9ydDogY3JlYXRlS2V5d29yZChcImltcG9ydFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX251bGw6IGNyZWF0ZUtleXdvcmQoXCJudWxsXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdHJ1ZTogY3JlYXRlS2V5d29yZChcInRydWVcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9mYWxzZTogY3JlYXRlS2V5d29yZChcImZhbHNlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdHlwZW9mOiBjcmVhdGVLZXl3b3JkKFwidHlwZW9mXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdm9pZDogY3JlYXRlS2V5d29yZChcInZvaWRcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgcHJlZml4LFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9kZWxldGU6IGNyZWF0ZUtleXdvcmQoXCJkZWxldGVcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgcHJlZml4LFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9kbzogY3JlYXRlS2V5d29yZChcImRvXCIsIHtcbiAgICBpc0xvb3AsXG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgX2ZvcjogY3JlYXRlS2V5d29yZChcImZvclwiLCB7XG4gICAgaXNMb29wXG4gIH0pLFxuICBfd2hpbGU6IGNyZWF0ZUtleXdvcmQoXCJ3aGlsZVwiLCB7XG4gICAgaXNMb29wXG4gIH0pLFxuICBfYXM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiYXNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9hc3NlcnQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwiYXNzZXJ0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXN5bmM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiYXN5bmNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9hd2FpdDogY3JlYXRlS2V5d29yZExpa2UoXCJhd2FpdFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2Zyb206IGNyZWF0ZUtleXdvcmRMaWtlKFwiZnJvbVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2dldDogY3JlYXRlS2V5d29yZExpa2UoXCJnZXRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9sZXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwibGV0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfbWV0YTogY3JlYXRlS2V5d29yZExpa2UoXCJtZXRhXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfb2Y6IGNyZWF0ZUtleXdvcmRMaWtlKFwib2ZcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9zZW50OiBjcmVhdGVLZXl3b3JkTGlrZShcInNlbnRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9zZXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwic2V0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfc3RhdGljOiBjcmVhdGVLZXl3b3JkTGlrZShcInN0YXRpY1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3lpZWxkOiBjcmVhdGVLZXl3b3JkTGlrZShcInlpZWxkXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXNzZXJ0czogY3JlYXRlS2V5d29yZExpa2UoXCJhc3NlcnRzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfY2hlY2tzOiBjcmVhdGVLZXl3b3JkTGlrZShcImNoZWNrc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2V4cG9ydHM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiZXhwb3J0c1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2dsb2JhbDogY3JlYXRlS2V5d29yZExpa2UoXCJnbG9iYWxcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbXBsZW1lbnRzOiBjcmVhdGVLZXl3b3JkTGlrZShcImltcGxlbWVudHNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbnRyaW5zaWM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW50cmluc2ljXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfaW5mZXI6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW5mZXJcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pczogY3JlYXRlS2V5d29yZExpa2UoXCJpc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX21peGluczogY3JlYXRlS2V5d29yZExpa2UoXCJtaXhpbnNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9wcm90bzogY3JlYXRlS2V5d29yZExpa2UoXCJwcm90b1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3JlcXVpcmU6IGNyZWF0ZUtleXdvcmRMaWtlKFwicmVxdWlyZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2tleW9mOiBjcmVhdGVLZXl3b3JkTGlrZShcImtleW9mXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfcmVhZG9ubHk6IGNyZWF0ZUtleXdvcmRMaWtlKFwicmVhZG9ubHlcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF91bmlxdWU6IGNyZWF0ZUtleXdvcmRMaWtlKFwidW5pcXVlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYWJzdHJhY3Q6IGNyZWF0ZUtleXdvcmRMaWtlKFwiYWJzdHJhY3RcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9kZWNsYXJlOiBjcmVhdGVLZXl3b3JkTGlrZShcImRlY2xhcmVcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9lbnVtOiBjcmVhdGVLZXl3b3JkTGlrZShcImVudW1cIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9tb2R1bGU6IGNyZWF0ZUtleXdvcmRMaWtlKFwibW9kdWxlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfbmFtZXNwYWNlOiBjcmVhdGVLZXl3b3JkTGlrZShcIm5hbWVzcGFjZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2ludGVyZmFjZTogY3JlYXRlS2V5d29yZExpa2UoXCJpbnRlcmZhY2VcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF90eXBlOiBjcmVhdGVLZXl3b3JkTGlrZShcInR5cGVcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9vcGFxdWU6IGNyZWF0ZUtleXdvcmRMaWtlKFwib3BhcXVlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBuYW1lOiBjcmVhdGVUb2tlbihcIm5hbWVcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHN0cmluZzogY3JlYXRlVG9rZW4oXCJzdHJpbmdcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIG51bTogY3JlYXRlVG9rZW4oXCJudW1cIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJpZ2ludDogY3JlYXRlVG9rZW4oXCJiaWdpbnRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGRlY2ltYWw6IGNyZWF0ZVRva2VuKFwiZGVjaW1hbFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgcmVnZXhwOiBjcmVhdGVUb2tlbihcInJlZ2V4cFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgcHJpdmF0ZU5hbWU6IGNyZWF0ZVRva2VuKFwiI25hbWVcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGVvZjogY3JlYXRlVG9rZW4oXCJlb2ZcIiksXG4gIGpzeE5hbWU6IGNyZWF0ZVRva2VuKFwianN4TmFtZVwiKSxcbiAganN4VGV4dDogY3JlYXRlVG9rZW4oXCJqc3hUZXh0XCIsIHtcbiAgICBiZWZvcmVFeHByOiB0cnVlXG4gIH0pLFxuICBqc3hUYWdTdGFydDogY3JlYXRlVG9rZW4oXCJqc3hUYWdTdGFydFwiLCB7XG4gICAgc3RhcnRzRXhwcjogdHJ1ZVxuICB9KSxcbiAganN4VGFnRW5kOiBjcmVhdGVUb2tlbihcImpzeFRhZ0VuZFwiKSxcbiAgcGxhY2Vob2xkZXI6IGNyZWF0ZVRva2VuKFwiJSVcIiwge1xuICAgIHN0YXJ0c0V4cHI6IHRydWVcbiAgfSlcbn07XG5mdW5jdGlvbiB0b2tlbklzSWRlbnRpZmllcih0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gOTMgJiYgdG9rZW4gPD0gMTI4O1xufVxuZnVuY3Rpb24gdG9rZW5LZXl3b3JkT3JJZGVudGlmaWVySXNLZXl3b3JkKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA8PSA5Mjtcbn1cbmZ1bmN0aW9uIHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSA1OCAmJiB0b2tlbiA8PSAxMjg7XG59XG5mdW5jdGlvbiB0b2tlbklzTGl0ZXJhbFByb3BlcnR5TmFtZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gNTggJiYgdG9rZW4gPD0gMTMyO1xufVxuZnVuY3Rpb24gdG9rZW5Db21lc0JlZm9yZUV4cHJlc3Npb24odG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuQmVmb3JlRXhwcnNbdG9rZW5dO1xufVxuZnVuY3Rpb24gdG9rZW5DYW5TdGFydEV4cHJlc3Npb24odG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuU3RhcnRzRXhwcnNbdG9rZW5dO1xufVxuZnVuY3Rpb24gdG9rZW5Jc0Fzc2lnbm1lbnQodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDI5ICYmIHRva2VuIDw9IDMzO1xufVxuZnVuY3Rpb24gdG9rZW5Jc0Zsb3dJbnRlcmZhY2VPclR5cGVPck9wYXF1ZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gMTI1ICYmIHRva2VuIDw9IDEyNztcbn1cbmZ1bmN0aW9uIHRva2VuSXNMb29wKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSA5MCAmJiB0b2tlbiA8PSA5Mjtcbn1cbmZ1bmN0aW9uIHRva2VuSXNLZXl3b3JkKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSA1OCAmJiB0b2tlbiA8PSA5Mjtcbn1cbmZ1bmN0aW9uIHRva2VuSXNPcGVyYXRvcih0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gMzkgJiYgdG9rZW4gPD0gNTk7XG59XG5mdW5jdGlvbiB0b2tlbklzUG9zdGZpeCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPT09IDM0O1xufVxuZnVuY3Rpb24gdG9rZW5Jc1ByZWZpeCh0b2tlbikge1xuICByZXR1cm4gdG9rZW5QcmVmaXhlc1t0b2tlbl07XG59XG5mdW5jdGlvbiB0b2tlbklzVFNUeXBlT3BlcmF0b3IodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDExNyAmJiB0b2tlbiA8PSAxMTk7XG59XG5mdW5jdGlvbiB0b2tlbklzVFNEZWNsYXJhdGlvblN0YXJ0KHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSAxMjAgJiYgdG9rZW4gPD0gMTI2O1xufVxuZnVuY3Rpb24gdG9rZW5MYWJlbE5hbWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuTGFiZWxzW3Rva2VuXTtcbn1cbmZ1bmN0aW9uIHRva2VuT3BlcmF0b3JQcmVjZWRlbmNlKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbkJpbm9wc1t0b2tlbl07XG59XG5mdW5jdGlvbiB0b2tlbklzUmlnaHRBc3NvY2lhdGl2ZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPT09IDU3O1xufVxuZnVuY3Rpb24gdG9rZW5Jc1RlbXBsYXRlKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSAyNCAmJiB0b2tlbiA8PSAyNTtcbn1cbmZ1bmN0aW9uIGdldEV4cG9ydGVkVG9rZW4odG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuVHlwZXNbdG9rZW5dO1xufVxue1xuICB0b2tlblR5cGVzWzhdLnVwZGF0ZUNvbnRleHQgPSBjb250ZXh0ID0+IHtcbiAgICBjb250ZXh0LnBvcCgpO1xuICB9O1xuXG4gIHRva2VuVHlwZXNbNV0udXBkYXRlQ29udGV4dCA9IHRva2VuVHlwZXNbN10udXBkYXRlQ29udGV4dCA9IHRva2VuVHlwZXNbMjNdLnVwZGF0ZUNvbnRleHQgPSBjb250ZXh0ID0+IHtcbiAgICBjb250ZXh0LnB1c2godHlwZXMuYnJhY2UpO1xuICB9O1xuXG4gIHRva2VuVHlwZXNbMjJdLnVwZGF0ZUNvbnRleHQgPSBjb250ZXh0ID0+IHtcbiAgICBpZiAoY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdID09PSB0eXBlcy50ZW1wbGF0ZSkge1xuICAgICAgY29udGV4dC5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5wdXNoKHR5cGVzLnRlbXBsYXRlKTtcbiAgICB9XG4gIH07XG5cbiAgdG9rZW5UeXBlc1sxMzhdLnVwZGF0ZUNvbnRleHQgPSBjb250ZXh0ID0+IHtcbiAgICBjb250ZXh0LnB1c2godHlwZXMual9leHByLCB0eXBlcy5qX29UYWcpO1xuICB9O1xufVxuXG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1ZDAtXFx1MDVlYVxcdTA1ZWYtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NmFcXHUwODcwLVxcdTA4ODdcXHUwODg5LVxcdTA4OGVcXHUwOGEwLVxcdTA4YzlcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTA5ZmNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYWY5XFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzVhXFx1MGM1ZFxcdTBjNjBcXHUwYzYxXFx1MGM4MFxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA0LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNTQtXFx1MGQ1NlxcdTBkNWYtXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODYtXFx1MGU4YVxcdTBlOGMtXFx1MGVhM1xcdTBlYTVcXHUwZWE3LVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNVxcdTEzZjgtXFx1MTNmZFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmOFxcdTE3MDAtXFx1MTcxMVxcdTE3MWYtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc4XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxZVxcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YjAtXFx1MTljOVxcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGNcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjODAtXFx1MWM4OFxcdTFjOTAtXFx1MWNiYVxcdTFjYmQtXFx1MWNiZlxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmM1xcdTFjZjVcXHUxY2Y2XFx1MWNmYVxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWItXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZlxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiZlxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiZlxcdTRlMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjlkXFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhN2NhXFx1YTdkMFxcdWE3ZDFcXHVhN2QzXFx1YTdkNS1cXHVhN2Q5XFx1YTdmMi1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE4ZmRcXHVhOGZlXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWE5ZTAtXFx1YTllNFxcdWE5ZTYtXFx1YTllZlxcdWE5ZmEtXFx1YTlmZVxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTdlLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiMzAtXFx1YWI1YVxcdWFiNWMtXFx1YWI2OVxcdWFiNzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiO1xubGV0IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUyMDBjXFx1MjAwZFxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDg5OC1cXHUwODlmXFx1MDhjYS1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzY1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDAtXFx1MGQwM1xcdTBkM2JcXHUwZDNjXFx1MGQzZS1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MS1cXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGU2LVxcdTBkZWZcXHUwZGYyXFx1MGRmM1xcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZTUwLVxcdTBlNTlcXHUwZWIxXFx1MGViNC1cXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjNlXFx1MGYzZlxcdTBmNzEtXFx1MGY4NFxcdTBmODZcXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMmItXFx1MTAzZVxcdTEwNDAtXFx1MTA0OVxcdTEwNTYtXFx1MTA1OVxcdTEwNWUtXFx1MTA2MFxcdTEwNjItXFx1MTA2NFxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTEzNjktXFx1MTM3MVxcdTE3MTItXFx1MTcxNVxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN2I0LVxcdTE3ZDNcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgwZi1cXHUxODE5XFx1MThhOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NDYtXFx1MTk0ZlxcdTE5ZDAtXFx1MTlkYVxcdTFhMTctXFx1MWExYlxcdTFhNTUtXFx1MWE1ZVxcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFhYjAtXFx1MWFiZFxcdTFhYmYtXFx1MWFjZVxcdTFiMDAtXFx1MWIwNFxcdTFiMzQtXFx1MWI0NFxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiODAtXFx1MWI4MlxcdTFiYTEtXFx1MWJhZFxcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMjQtXFx1MWMzN1xcdTFjNDAtXFx1MWM0OVxcdTFjNTAtXFx1MWM1OVxcdTFjZDAtXFx1MWNkMlxcdTFjZDQtXFx1MWNlOFxcdTFjZWRcXHUxY2Y0XFx1MWNmNy1cXHUxY2Y5XFx1MWRjMC1cXHUxZGZmXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2MjAtXFx1YTYyOVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjllXFx1YTY5ZlxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTgyY1xcdWE4ODBcXHVhODgxXFx1YThiNC1cXHVhOGM1XFx1YThkMC1cXHVhOGQ5XFx1YThlMC1cXHVhOGYxXFx1YThmZi1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUzXFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YTlkMC1cXHVhOWQ5XFx1YTllNVxcdWE5ZjAtXFx1YTlmOVxcdWFhMjktXFx1YWEzNlxcdWFhNDNcXHVhYTRjXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2ItXFx1YWE3ZFxcdWFhYjBcXHVhYWIyLVxcdWFhYjRcXHVhYWI3XFx1YWFiOFxcdWFhYmVcXHVhYWJmXFx1YWFjMVxcdWFhZWItXFx1YWFlZlxcdWFhZjVcXHVhYWY2XFx1YWJlMy1cXHVhYmVhXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTJmXFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCI7XG5jb25zdCBub25BU0NJSWlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgXCJdXCIpO1xuY29uc3Qgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcbm5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgPSBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IG51bGw7XG5jb25zdCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcyA9IFswLCAxMSwgMiwgMjUsIDIsIDE4LCAyLCAxLCAyLCAxNCwgMywgMTMsIDM1LCAxMjIsIDcwLCA1MiwgMjY4LCAyOCwgNCwgNDgsIDQ4LCAzMSwgMTQsIDI5LCA2LCAzNywgMTEsIDI5LCAzLCAzNSwgNSwgNywgMiwgNCwgNDMsIDE1NywgMTksIDM1LCA1LCAzNSwgNSwgMzksIDksIDUxLCAxMywgMTAsIDIsIDE0LCAyLCA2LCAyLCAxLCAyLCAxMCwgMiwgMTQsIDIsIDYsIDIsIDEsIDY4LCAzMTAsIDEwLCAyMSwgMTEsIDcsIDI1LCA1LCAyLCA0MSwgMiwgOCwgNzAsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcxLCA1NSwgNywgMSwgNjUsIDAsIDE2LCAzLCAyLCAyLCAyLCAyOCwgNDMsIDI4LCA0LCAyOCwgMzYsIDcsIDIsIDI3LCAyOCwgNTMsIDExLCAyMSwgMTEsIDE4LCAxNCwgMTcsIDExMSwgNzIsIDU2LCA1MCwgMTQsIDUwLCAxNCwgMzUsIDM0OSwgNDEsIDcsIDEsIDc5LCAyOCwgMTEsIDAsIDksIDIxLCA0MywgMTcsIDQ3LCAyMCwgMjgsIDIyLCAxMywgNTIsIDU4LCAxLCAzLCAwLCAxNCwgNDQsIDMzLCAyNCwgMjcsIDM1LCAzMCwgMCwgMywgMCwgOSwgMzQsIDQsIDAsIDEzLCA0NywgMTUsIDMsIDIyLCAwLCAyLCAwLCAzNiwgMTcsIDIsIDI0LCA4NSwgNiwgMiwgMCwgMiwgMywgMiwgMTQsIDIsIDksIDgsIDQ2LCAzOSwgNywgMywgMSwgMywgMjEsIDIsIDYsIDIsIDEsIDIsIDQsIDQsIDAsIDE5LCAwLCAxMywgNCwgMTU5LCA1MiwgMTksIDMsIDIxLCAyLCAzMSwgNDcsIDIxLCAxLCAyLCAwLCAxODUsIDQ2LCA0MiwgMywgMzcsIDQ3LCAyMSwgMCwgNjAsIDQyLCAxNCwgMCwgNzIsIDI2LCAzOCwgNiwgMTg2LCA0MywgMTE3LCA2MywgMzIsIDcsIDMsIDAsIDMsIDcsIDIsIDEsIDIsIDIzLCAxNiwgMCwgMiwgMCwgOTUsIDcsIDMsIDM4LCAxNywgMCwgMiwgMCwgMjksIDAsIDExLCAzOSwgOCwgMCwgMjIsIDAsIDEyLCA0NSwgMjAsIDAsIDE5LCA3MiwgMjY0LCA4LCAyLCAzNiwgMTgsIDAsIDUwLCAyOSwgMTEzLCA2LCAyLCAxLCAyLCAzNywgMjIsIDAsIDI2LCA1LCAyLCAxLCAyLCAzMSwgMTUsIDAsIDMyOCwgMTgsIDE5MCwgMCwgODAsIDkyMSwgMTAzLCAxMTAsIDE4LCAxOTUsIDI2MzcsIDk2LCAxNiwgMTA3MCwgNDA1MCwgNTgyLCA4NjM0LCA1NjgsIDgsIDMwLCAxOCwgNzgsIDE4LCAyOSwgMTksIDQ3LCAxNywgMywgMzIsIDIwLCA2LCAxOCwgNjg5LCA2MywgMTI5LCA3NCwgNiwgMCwgNjcsIDEyLCA2NSwgMSwgMiwgMCwgMjksIDYxMzUsIDksIDEyMzcsIDQzLCA4LCA4OTM2LCAzLCAyLCA2LCAyLCAxLCAyLCAyOTAsIDQ2LCAyLCAxOCwgMywgOSwgMzk1LCAyMzA5LCAxMDYsIDYsIDEyLCA0LCA4LCA4LCA5LCA1OTkxLCA4NCwgMiwgNzAsIDIsIDEsIDMsIDAsIDMsIDEsIDMsIDMsIDIsIDExLCAyLCAwLCAyLCA2LCAyLCA2NCwgMiwgMywgMywgNywgMiwgNiwgMiwgMjcsIDIsIDMsIDIsIDQsIDIsIDAsIDQsIDYsIDIsIDMzOSwgMywgMjQsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDcsIDE4NDUsIDMwLCA0ODIsIDQ0LCAxMSwgNiwgMTcsIDAsIDMyMiwgMjksIDE5LCA0MywgMTI2OSwgNiwgMiwgMywgMiwgMSwgMiwgMTQsIDIsIDE5NiwgNjAsIDY3LCA4LCAwLCAxMjA1LCAzLCAyLCAyNiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgOSwgMiwgMywgMiwgMCwgMiwgMCwgNywgMCwgNSwgMCwgMiwgMCwgMiwgMCwgMiwgMiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMSwgMiwgMCwgMywgMywgMiwgNiwgMiwgMywgMiwgMywgMiwgMCwgMiwgOSwgMiwgMTYsIDYsIDIsIDIsIDQsIDIsIDE2LCA0NDIxLCA0MjcxOSwgMzMsIDQxNTIsIDgsIDIyMSwgMywgNTc2MSwgMTUsIDc0NzIsIDMxMDQsIDU0MSwgMTUwNywgNDkzOF07XG5jb25zdCBhc3RyYWxJZGVudGlmaWVyQ29kZXMgPSBbNTA5LCAwLCAyMjcsIDAsIDE1MCwgNCwgMjk0LCA5LCAxMzY4LCAyLCAyLCAxLCA2LCAzLCA0MSwgMiwgNSwgMCwgMTY2LCAxLCA1NzQsIDMsIDksIDksIDM3MCwgMSwgMTU0LCAxMCwgNTAsIDMsIDEyMywgMiwgNTQsIDE0LCAzMiwgMTAsIDMsIDEsIDExLCAzLCA0NiwgMTAsIDgsIDAsIDQ2LCA5LCA3LCAyLCAzNywgMTMsIDIsIDksIDYsIDEsIDQ1LCAwLCAxMywgMiwgNDksIDEzLCA5LCAzLCAyLCAxMSwgODMsIDExLCA3LCAwLCAxNjEsIDExLCA2LCA5LCA3LCAzLCA1NiwgMSwgMiwgNiwgMywgMSwgMywgMiwgMTAsIDAsIDExLCAxLCAzLCA2LCA0LCA0LCAxOTMsIDE3LCAxMCwgOSwgNSwgMCwgODIsIDE5LCAxMywgOSwgMjE0LCA2LCAzLCA4LCAyOCwgMSwgODMsIDE2LCAxNiwgOSwgODIsIDEyLCA5LCA5LCA4NCwgMTQsIDUsIDksIDI0MywgMTQsIDE2NiwgOSwgNzEsIDUsIDIsIDEsIDMsIDMsIDIsIDAsIDIsIDEsIDEzLCA5LCAxMjAsIDYsIDMsIDYsIDQsIDAsIDI5LCA5LCA0MSwgNiwgMiwgMywgOSwgMCwgMTAsIDEwLCA0NywgMTUsIDQwNiwgNywgMiwgNywgMTcsIDksIDU3LCAyMSwgMiwgMTMsIDEyMywgNSwgNCwgMCwgMiwgMSwgMiwgNiwgMiwgMCwgOSwgOSwgNDksIDQsIDIsIDEsIDIsIDQsIDksIDksIDMzMCwgMywgMTkzMDYsIDksIDg3LCA5LCAzOSwgNCwgNjAsIDYsIDI2LCA5LCAxMDE0LCAwLCAyLCA1NCwgOCwgMywgODIsIDAsIDEyLCAxLCAxOTYyOCwgMSwgNDcwNiwgNDUsIDMsIDIyLCA1NDMsIDQsIDQsIDUsIDksIDcsIDMsIDYsIDMxLCAzLCAxNDksIDIsIDE0MTgsIDQ5LCA1MTMsIDU0LCA1LCA0OSwgOSwgMCwgMTUsIDAsIDIzLCA0LCAyLCAxNCwgMTM2MSwgNiwgMiwgMTYsIDMsIDYsIDIsIDEsIDIsIDQsIDI2MiwgNiwgMTAsIDksIDM1NywgMCwgNjIsIDEzLCAxNDk1LCA2LCAxMTAsIDYsIDYsIDksIDQ3NTksIDksIDc4NzcxOSwgMjM5XTtcblxuZnVuY3Rpb24gaXNJbkFzdHJhbFNldChjb2RlLCBzZXQpIHtcbiAgbGV0IHBvcyA9IDB4MTAwMDA7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IHNldC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgIHBvcyArPSBzZXRbaV07XG4gICAgaWYgKHBvcyA+IGNvZGUpIHJldHVybiBmYWxzZTtcbiAgICBwb3MgKz0gc2V0W2kgKyAxXTtcbiAgICBpZiAocG9zID49IGNvZGUpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlKSB7XG4gIGlmIChjb2RlIDwgNjUpIHJldHVybiBjb2RlID09PSAzNjtcbiAgaWYgKGNvZGUgPD0gOTApIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDw9IDEyMikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xuICB9XG5cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpO1xufVxuZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlKSB7XG4gIGlmIChjb2RlIDwgNDgpIHJldHVybiBjb2RlID09PSAzNjtcbiAgaWYgKGNvZGUgPCA1OCkgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDwgNjUpIHJldHVybiBmYWxzZTtcbiAgaWYgKGNvZGUgPD0gOTApIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDw9IDEyMikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfVxuXG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2Rlcyk7XG59XG5cbmNvbnN0IHJlc2VydmVkV29yZHMgPSB7XG4gIGtleXdvcmQ6IFtcImJyZWFrXCIsIFwiY2FzZVwiLCBcImNhdGNoXCIsIFwiY29udGludWVcIiwgXCJkZWJ1Z2dlclwiLCBcImRlZmF1bHRcIiwgXCJkb1wiLCBcImVsc2VcIiwgXCJmaW5hbGx5XCIsIFwiZm9yXCIsIFwiZnVuY3Rpb25cIiwgXCJpZlwiLCBcInJldHVyblwiLCBcInN3aXRjaFwiLCBcInRocm93XCIsIFwidHJ5XCIsIFwidmFyXCIsIFwiY29uc3RcIiwgXCJ3aGlsZVwiLCBcIndpdGhcIiwgXCJuZXdcIiwgXCJ0aGlzXCIsIFwic3VwZXJcIiwgXCJjbGFzc1wiLCBcImV4dGVuZHNcIiwgXCJleHBvcnRcIiwgXCJpbXBvcnRcIiwgXCJudWxsXCIsIFwidHJ1ZVwiLCBcImZhbHNlXCIsIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCIsIFwidHlwZW9mXCIsIFwidm9pZFwiLCBcImRlbGV0ZVwiXSxcbiAgc3RyaWN0OiBbXCJpbXBsZW1lbnRzXCIsIFwiaW50ZXJmYWNlXCIsIFwibGV0XCIsIFwicGFja2FnZVwiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwdWJsaWNcIiwgXCJzdGF0aWNcIiwgXCJ5aWVsZFwiXSxcbiAgc3RyaWN0QmluZDogW1wiZXZhbFwiLCBcImFyZ3VtZW50c1wiXVxufTtcbmNvbnN0IGtleXdvcmRzID0gbmV3IFNldChyZXNlcnZlZFdvcmRzLmtleXdvcmQpO1xuY29uc3QgcmVzZXJ2ZWRXb3Jkc1N0cmljdFNldCA9IG5ldyBTZXQocmVzZXJ2ZWRXb3Jkcy5zdHJpY3QpO1xuY29uc3QgcmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmRTZXQgPSBuZXcgU2V0KHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG5mdW5jdGlvbiBpc1Jlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkge1xuICByZXR1cm4gaW5Nb2R1bGUgJiYgd29yZCA9PT0gXCJhd2FpdFwiIHx8IHdvcmQgPT09IFwiZW51bVwiO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHtcbiAgcmV0dXJuIGlzUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB8fCByZXNlcnZlZFdvcmRzU3RyaWN0U2V0Lmhhcyh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQod29yZCkge1xuICByZXR1cm4gcmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmRTZXQuaGFzKHdvcmQpO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB7XG4gIHJldHVybiBpc1N0cmljdFJlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkgfHwgaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZCh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzS2V5d29yZCh3b3JkKSB7XG4gIHJldHVybiBrZXl3b3Jkcy5oYXMod29yZCk7XG59XG5cbmZ1bmN0aW9uIGlzSXRlcmF0b3JTdGFydChjdXJyZW50LCBuZXh0LCBuZXh0Mikge1xuICByZXR1cm4gY3VycmVudCA9PT0gNjQgJiYgbmV4dCA9PT0gNjQgJiYgaXNJZGVudGlmaWVyU3RhcnQobmV4dDIpO1xufVxuY29uc3QgcmVzZXJ2ZWRXb3JkTGlrZVNldCA9IG5ldyBTZXQoW1wiYnJlYWtcIiwgXCJjYXNlXCIsIFwiY2F0Y2hcIiwgXCJjb250aW51ZVwiLCBcImRlYnVnZ2VyXCIsIFwiZGVmYXVsdFwiLCBcImRvXCIsIFwiZWxzZVwiLCBcImZpbmFsbHlcIiwgXCJmb3JcIiwgXCJmdW5jdGlvblwiLCBcImlmXCIsIFwicmV0dXJuXCIsIFwic3dpdGNoXCIsIFwidGhyb3dcIiwgXCJ0cnlcIiwgXCJ2YXJcIiwgXCJjb25zdFwiLCBcIndoaWxlXCIsIFwid2l0aFwiLCBcIm5ld1wiLCBcInRoaXNcIiwgXCJzdXBlclwiLCBcImNsYXNzXCIsIFwiZXh0ZW5kc1wiLCBcImV4cG9ydFwiLCBcImltcG9ydFwiLCBcIm51bGxcIiwgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCIsIFwiZGVsZXRlXCIsIFwiaW1wbGVtZW50c1wiLCBcImludGVyZmFjZVwiLCBcImxldFwiLCBcInBhY2thZ2VcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCIsIFwic3RhdGljXCIsIFwieWllbGRcIiwgXCJldmFsXCIsIFwiYXJndW1lbnRzXCIsIFwiZW51bVwiLCBcImF3YWl0XCJdKTtcbmZ1bmN0aW9uIGNhbkJlUmVzZXJ2ZWRXb3JkKHdvcmQpIHtcbiAgcmV0dXJuIHJlc2VydmVkV29yZExpa2VTZXQuaGFzKHdvcmQpO1xufVxuXG5jb25zdCBTQ09QRV9PVEhFUiA9IDBiMDAwMDAwMDAwLFxuICAgICAgU0NPUEVfUFJPR1JBTSA9IDBiMDAwMDAwMDAxLFxuICAgICAgU0NPUEVfRlVOQ1RJT04gPSAwYjAwMDAwMDAxMCxcbiAgICAgIFNDT1BFX0FSUk9XID0gMGIwMDAwMDAxMDAsXG4gICAgICBTQ09QRV9TSU1QTEVfQ0FUQ0ggPSAwYjAwMDAwMTAwMCxcbiAgICAgIFNDT1BFX1NVUEVSID0gMGIwMDAwMTAwMDAsXG4gICAgICBTQ09QRV9ESVJFQ1RfU1VQRVIgPSAwYjAwMDEwMDAwMCxcbiAgICAgIFNDT1BFX0NMQVNTID0gMGIwMDEwMDAwMDAsXG4gICAgICBTQ09QRV9TVEFUSUNfQkxPQ0sgPSAwYjAxMDAwMDAwMCxcbiAgICAgIFNDT1BFX1RTX01PRFVMRSA9IDBiMTAwMDAwMDAwLFxuICAgICAgU0NPUEVfVkFSID0gU0NPUEVfUFJPR1JBTSB8IFNDT1BFX0ZVTkNUSU9OIHwgU0NPUEVfVFNfTU9EVUxFO1xuY29uc3QgQklORF9LSU5EX1ZBTFVFID0gMGIwMDAwMDAwMDAwMDEsXG4gICAgICBCSU5EX0tJTkRfVFlQRSA9IDBiMDAwMDAwMDAwMDEwLFxuICAgICAgQklORF9TQ09QRV9WQVIgPSAwYjAwMDAwMDAwMDEwMCxcbiAgICAgIEJJTkRfU0NPUEVfTEVYSUNBTCA9IDBiMDAwMDAwMDAxMDAwLFxuICAgICAgQklORF9TQ09QRV9GVU5DVElPTiA9IDBiMDAwMDAwMDEwMDAwLFxuICAgICAgQklORF9GTEFHU19OT05FID0gMGIwMDAwMDEwMDAwMDAsXG4gICAgICBCSU5EX0ZMQUdTX0NMQVNTID0gMGIwMDAwMTAwMDAwMDAsXG4gICAgICBCSU5EX0ZMQUdTX1RTX0VOVU0gPSAwYjAwMDEwMDAwMDAwMCxcbiAgICAgIEJJTkRfRkxBR1NfVFNfQ09OU1RfRU5VTSA9IDBiMDAxMDAwMDAwMDAwLFxuICAgICAgQklORF9GTEFHU19UU19FWFBPUlRfT05MWSA9IDBiMDEwMDAwMDAwMDAwLFxuICAgICAgQklORF9GTEFHU19GTE9XX0RFQ0xBUkVfRk4gPSAwYjEwMDAwMDAwMDAwMDtcbmNvbnN0IEJJTkRfQ0xBU1MgPSBCSU5EX0tJTkRfVkFMVUUgfCBCSU5EX0tJTkRfVFlQRSB8IEJJTkRfU0NPUEVfTEVYSUNBTCB8IEJJTkRfRkxBR1NfQ0xBU1MsXG4gICAgICBCSU5EX0xFWElDQUwgPSBCSU5EX0tJTkRfVkFMVUUgfCAwIHwgQklORF9TQ09QRV9MRVhJQ0FMIHwgMCxcbiAgICAgIEJJTkRfVkFSID0gQklORF9LSU5EX1ZBTFVFIHwgMCB8IEJJTkRfU0NPUEVfVkFSIHwgMCxcbiAgICAgIEJJTkRfRlVOQ1RJT04gPSBCSU5EX0tJTkRfVkFMVUUgfCAwIHwgQklORF9TQ09QRV9GVU5DVElPTiB8IDAsXG4gICAgICBCSU5EX1RTX0lOVEVSRkFDRSA9IDAgfCBCSU5EX0tJTkRfVFlQRSB8IDAgfCBCSU5EX0ZMQUdTX0NMQVNTLFxuICAgICAgQklORF9UU19UWVBFID0gMCB8IEJJTkRfS0lORF9UWVBFIHwgMCB8IDAsXG4gICAgICBCSU5EX1RTX0VOVU0gPSBCSU5EX0tJTkRfVkFMVUUgfCBCSU5EX0tJTkRfVFlQRSB8IEJJTkRfU0NPUEVfTEVYSUNBTCB8IEJJTkRfRkxBR1NfVFNfRU5VTSxcbiAgICAgIEJJTkRfVFNfQU1CSUVOVCA9IDAgfCAwIHwgMCB8IEJJTkRfRkxBR1NfVFNfRVhQT1JUX09OTFksXG4gICAgICBCSU5EX05PTkUgPSAwIHwgMCB8IDAgfCBCSU5EX0ZMQUdTX05PTkUsXG4gICAgICBCSU5EX09VVFNJREUgPSBCSU5EX0tJTkRfVkFMVUUgfCAwIHwgMCB8IEJJTkRfRkxBR1NfTk9ORSxcbiAgICAgIEJJTkRfVFNfQ09OU1RfRU5VTSA9IEJJTkRfVFNfRU5VTSB8IEJJTkRfRkxBR1NfVFNfQ09OU1RfRU5VTSxcbiAgICAgIEJJTkRfVFNfTkFNRVNQQUNFID0gMCB8IDAgfCAwIHwgQklORF9GTEFHU19UU19FWFBPUlRfT05MWSxcbiAgICAgIEJJTkRfRkxPV19ERUNMQVJFX0ZOID0gQklORF9GTEFHU19GTE9XX0RFQ0xBUkVfRk47XG5jb25zdCBDTEFTU19FTEVNRU5UX0ZMQUdfU1RBVElDID0gMGIxMDAsXG4gICAgICBDTEFTU19FTEVNRU5UX0tJTkRfR0VUVEVSID0gMGIwMTAsXG4gICAgICBDTEFTU19FTEVNRU5UX0tJTkRfU0VUVEVSID0gMGIwMDEsXG4gICAgICBDTEFTU19FTEVNRU5UX0tJTkRfQUNDRVNTT1IgPSBDTEFTU19FTEVNRU5UX0tJTkRfR0VUVEVSIHwgQ0xBU1NfRUxFTUVOVF9LSU5EX1NFVFRFUjtcbmNvbnN0IENMQVNTX0VMRU1FTlRfU1RBVElDX0dFVFRFUiA9IENMQVNTX0VMRU1FTlRfS0lORF9HRVRURVIgfCBDTEFTU19FTEVNRU5UX0ZMQUdfU1RBVElDLFxuICAgICAgQ0xBU1NfRUxFTUVOVF9TVEFUSUNfU0VUVEVSID0gQ0xBU1NfRUxFTUVOVF9LSU5EX1NFVFRFUiB8IENMQVNTX0VMRU1FTlRfRkxBR19TVEFUSUMsXG4gICAgICBDTEFTU19FTEVNRU5UX0lOU1RBTkNFX0dFVFRFUiA9IENMQVNTX0VMRU1FTlRfS0lORF9HRVRURVIsXG4gICAgICBDTEFTU19FTEVNRU5UX0lOU1RBTkNFX1NFVFRFUiA9IENMQVNTX0VMRU1FTlRfS0lORF9TRVRURVIsXG4gICAgICBDTEFTU19FTEVNRU5UX09USEVSID0gMDtcblxuY2xhc3MgQmFzZVBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSBmYWxzZTtcbiAgICB0aGlzLmFtYmlndW91c1NjcmlwdERpZmZlcmVudEFzdCA9IGZhbHNlO1xuICB9XG5cbiAgaGFzUGx1Z2luKHBsdWdpbkNvbmZpZykge1xuICAgIGlmICh0eXBlb2YgcGx1Z2luQ29uZmlnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5wbHVnaW5zLmhhcyhwbHVnaW5Db25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbcGx1Z2luTmFtZSwgcGx1Z2luT3B0aW9uc10gPSBwbHVnaW5Db25maWc7XG5cbiAgICAgIGlmICghdGhpcy5oYXNQbHVnaW4ocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY3R1YWxPcHRpb25zID0gdGhpcy5wbHVnaW5zLmdldChwbHVnaW5OYW1lKTtcblxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGx1Z2luT3B0aW9ucykpIHtcbiAgICAgICAgaWYgKChhY3R1YWxPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBhY3R1YWxPcHRpb25zW2tleV0pICE9PSBwbHVnaW5PcHRpb25zW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZ2V0UGx1Z2luT3B0aW9uKHBsdWdpbiwgbmFtZSkge1xuICAgIHZhciBfdGhpcyRwbHVnaW5zJGdldDtcblxuICAgIHJldHVybiAoX3RoaXMkcGx1Z2lucyRnZXQgPSB0aGlzLnBsdWdpbnMuZ2V0KHBsdWdpbikpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwbHVnaW5zJGdldFtuYW1lXTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHNldFRyYWlsaW5nQ29tbWVudHMobm9kZSwgY29tbWVudHMpIHtcbiAgaWYgKG5vZGUudHJhaWxpbmdDb21tZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gY29tbWVudHM7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzLnVuc2hpZnQoLi4uY29tbWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldExlYWRpbmdDb21tZW50cyhub2RlLCBjb21tZW50cykge1xuICBpZiAobm9kZS5sZWFkaW5nQ29tbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gY29tbWVudHM7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5sZWFkaW5nQ29tbWVudHMudW5zaGlmdCguLi5jb21tZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0SW5uZXJDb21tZW50cyhub2RlLCBjb21tZW50cykge1xuICBpZiAobm9kZS5pbm5lckNvbW1lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBub2RlLmlubmVyQ29tbWVudHMgPSBjb21tZW50cztcbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVyQ29tbWVudHMudW5zaGlmdCguLi5jb21tZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRqdXN0SW5uZXJDb21tZW50cyhub2RlLCBlbGVtZW50cywgY29tbWVudFdTKSB7XG4gIGxldCBsYXN0RWxlbWVudCA9IG51bGw7XG4gIGxldCBpID0gZWxlbWVudHMubGVuZ3RoO1xuXG4gIHdoaWxlIChsYXN0RWxlbWVudCA9PT0gbnVsbCAmJiBpID4gMCkge1xuICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudHNbLS1pXTtcbiAgfVxuXG4gIGlmIChsYXN0RWxlbWVudCA9PT0gbnVsbCB8fCBsYXN0RWxlbWVudC5zdGFydCA+IGNvbW1lbnRXUy5zdGFydCkge1xuICAgIHNldElubmVyQ29tbWVudHMobm9kZSwgY29tbWVudFdTLmNvbW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRUcmFpbGluZ0NvbW1lbnRzKGxhc3RFbGVtZW50LCBjb21tZW50V1MuY29tbWVudHMpO1xuICB9XG59XG5cbmNsYXNzIENvbW1lbnRzUGFyc2VyIGV4dGVuZHMgQmFzZVBhcnNlciB7XG4gIGFkZENvbW1lbnQoY29tbWVudCkge1xuICAgIGlmICh0aGlzLmZpbGVuYW1lKSBjb21tZW50LmxvYy5maWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgdGhpcy5zdGF0ZS5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICB9XG5cbiAgcHJvY2Vzc0NvbW1lbnQobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRTdGFja1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNvbW1lbnRTdGFja0xlbmd0aCA9IGNvbW1lbnRTdGFjay5sZW5ndGg7XG4gICAgaWYgKGNvbW1lbnRTdGFja0xlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGxldCBpID0gY29tbWVudFN0YWNrTGVuZ3RoIC0gMTtcbiAgICBjb25zdCBsYXN0Q29tbWVudFdTID0gY29tbWVudFN0YWNrW2ldO1xuXG4gICAgaWYgKGxhc3RDb21tZW50V1Muc3RhcnQgPT09IG5vZGUuZW5kKSB7XG4gICAgICBsYXN0Q29tbWVudFdTLmxlYWRpbmdOb2RlID0gbm9kZTtcbiAgICAgIGktLTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBzdGFydDogbm9kZVN0YXJ0XG4gICAgfSA9IG5vZGU7XG5cbiAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGNvbW1lbnRXUyA9IGNvbW1lbnRTdGFja1tpXTtcbiAgICAgIGNvbnN0IGNvbW1lbnRFbmQgPSBjb21tZW50V1MuZW5kO1xuXG4gICAgICBpZiAoY29tbWVudEVuZCA+IG5vZGVTdGFydCkge1xuICAgICAgICBjb21tZW50V1MuY29udGFpbmluZ05vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmZpbmFsaXplQ29tbWVudChjb21tZW50V1MpO1xuICAgICAgICBjb21tZW50U3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbW1lbnRFbmQgPT09IG5vZGVTdGFydCkge1xuICAgICAgICAgIGNvbW1lbnRXUy50cmFpbGluZ05vZGUgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZmluYWxpemVDb21tZW50KGNvbW1lbnRXUykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRzXG4gICAgfSA9IGNvbW1lbnRXUztcblxuICAgIGlmIChjb21tZW50V1MubGVhZGluZ05vZGUgIT09IG51bGwgfHwgY29tbWVudFdTLnRyYWlsaW5nTm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNvbW1lbnRXUy5sZWFkaW5nTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBzZXRUcmFpbGluZ0NvbW1lbnRzKGNvbW1lbnRXUy5sZWFkaW5nTm9kZSwgY29tbWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tbWVudFdTLnRyYWlsaW5nTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBzZXRMZWFkaW5nQ29tbWVudHMoY29tbWVudFdTLnRyYWlsaW5nTm9kZSwgY29tbWVudHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRhaW5pbmdOb2RlOiBub2RlLFxuICAgICAgICBzdGFydDogY29tbWVudFN0YXJ0XG4gICAgICB9ID0gY29tbWVudFdTO1xuXG4gICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KGNvbW1lbnRTdGFydCAtIDEpID09PSA0NCkge1xuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgICAgICBjYXNlIFwiUmVjb3JkRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgYWRqdXN0SW5uZXJDb21tZW50cyhub2RlLCBub2RlLnByb3BlcnRpZXMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuYXJndW1lbnRzLCBjb21tZW50V1MpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiT2JqZWN0TWV0aG9kXCI6XG4gICAgICAgICAgY2FzZSBcIkNsYXNzTWV0aG9kXCI6XG4gICAgICAgICAgY2FzZSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiOlxuICAgICAgICAgICAgYWRqdXN0SW5uZXJDb21tZW50cyhub2RlLCBub2RlLnBhcmFtcywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgICAgICBjYXNlIFwiVHVwbGVFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuZWxlbWVudHMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkltcG9ydERlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuc3BlY2lmaWVycywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc2V0SW5uZXJDb21tZW50cyhub2RlLCBjb21tZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldElubmVyQ29tbWVudHMobm9kZSwgY29tbWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZpbmFsaXplUmVtYWluaW5nQ29tbWVudHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudFN0YWNrXG4gICAgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBmb3IgKGxldCBpID0gY29tbWVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLmZpbmFsaXplQ29tbWVudChjb21tZW50U3RhY2tbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuY29tbWVudFN0YWNrID0gW107XG4gIH1cblxuICByZXNldFByZXZpb3VzTm9kZVRyYWlsaW5nQ29tbWVudHMobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRTdGFja1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aFxuICAgIH0gPSBjb21tZW50U3RhY2s7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IGNvbW1lbnRXUyA9IGNvbW1lbnRTdGFja1tsZW5ndGggLSAxXTtcblxuICAgIGlmIChjb21tZW50V1MubGVhZGluZ05vZGUgPT09IG5vZGUpIHtcbiAgICAgIGNvbW1lbnRXUy5sZWFkaW5nTm9kZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgdGFrZVN1cnJvdW5kaW5nQ29tbWVudHMobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRTdGFja1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNvbW1lbnRTdGFja0xlbmd0aCA9IGNvbW1lbnRTdGFjay5sZW5ndGg7XG4gICAgaWYgKGNvbW1lbnRTdGFja0xlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGxldCBpID0gY29tbWVudFN0YWNrTGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY29tbWVudFdTID0gY29tbWVudFN0YWNrW2ldO1xuICAgICAgY29uc3QgY29tbWVudEVuZCA9IGNvbW1lbnRXUy5lbmQ7XG4gICAgICBjb25zdCBjb21tZW50U3RhcnQgPSBjb21tZW50V1Muc3RhcnQ7XG5cbiAgICAgIGlmIChjb21tZW50U3RhcnQgPT09IGVuZCkge1xuICAgICAgICBjb21tZW50V1MubGVhZGluZ05vZGUgPSBub2RlO1xuICAgICAgfSBlbHNlIGlmIChjb21tZW50RW5kID09PSBzdGFydCkge1xuICAgICAgICBjb21tZW50V1MudHJhaWxpbmdOb2RlID0gbm9kZTtcbiAgICAgIH0gZWxzZSBpZiAoY29tbWVudEVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbmNvbnN0IGxpbmVCcmVhayA9IC9cXHJcXG4/fFtcXG5cXHUyMDI4XFx1MjAyOV0vO1xuY29uc3QgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAxMDpcbiAgICBjYXNlIDEzOlxuICAgIGNhc2UgODIzMjpcbiAgICBjYXNlIDgyMzM6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IHNraXBXaGl0ZVNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKnxcXC9cXCpbXl0qP1xcKlxcLykqL2c7XG5jb25zdCBza2lwV2hpdGVTcGFjZUluTGluZSA9IC8oPzpbXlxcU1xcblxcclxcdTIwMjhcXHUyMDI5XXxcXC9cXC8uKnxcXC9cXCouKj9cXCpcXC8pKi95O1xuY29uc3Qgc2tpcFdoaXRlU3BhY2VUb0xpbmVCcmVhayA9IG5ldyBSZWdFeHAoXCIoPz0oXCIgKyBza2lwV2hpdGVTcGFjZUluTGluZS5zb3VyY2UgKyBcIikpXFxcXDFcIiArIC8oPz1bXFxuXFxyXFx1MjAyOFxcdTIwMjldfFxcL1xcKig/IS4qP1xcKlxcLyl8JCkvLnNvdXJjZSwgXCJ5XCIpO1xuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDAwMDk6XG4gICAgY2FzZSAweDAwMGI6XG4gICAgY2FzZSAweDAwMGM6XG4gICAgY2FzZSAzMjpcbiAgICBjYXNlIDE2MDpcbiAgICBjYXNlIDU3NjA6XG4gICAgY2FzZSAweDIwMDA6XG4gICAgY2FzZSAweDIwMDE6XG4gICAgY2FzZSAweDIwMDI6XG4gICAgY2FzZSAweDIwMDM6XG4gICAgY2FzZSAweDIwMDQ6XG4gICAgY2FzZSAweDIwMDU6XG4gICAgY2FzZSAweDIwMDY6XG4gICAgY2FzZSAweDIwMDc6XG4gICAgY2FzZSAweDIwMDg6XG4gICAgY2FzZSAweDIwMDk6XG4gICAgY2FzZSAweDIwMGE6XG4gICAgY2FzZSAweDIwMmY6XG4gICAgY2FzZSAweDIwNWY6XG4gICAgY2FzZSAweDMwMDA6XG4gICAgY2FzZSAweGZlZmY6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuY2xhc3MgU3RhdGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0cmljdCA9IHZvaWQgMDtcbiAgICB0aGlzLmN1ckxpbmUgPSB2b2lkIDA7XG4gICAgdGhpcy5saW5lU3RhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydExvYyA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZExvYyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuICAgIHRoaXMubm9BcnJvd0F0ID0gW107XG4gICAgdGhpcy5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0ID0gW107XG4gICAgdGhpcy5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5pblR5cGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuICAgIHRoaXMuaGFzRmxvd0NvbW1lbnQgPSBmYWxzZTtcbiAgICB0aGlzLmlzQW1iaWVudENvbnRleHQgPSBmYWxzZTtcbiAgICB0aGlzLmluQWJzdHJhY3RDbGFzcyA9IGZhbHNlO1xuICAgIHRoaXMuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gZmFsc2U7XG4gICAgdGhpcy50b3BpY0NvbnRleHQgPSB7XG4gICAgICBtYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6IDAsXG4gICAgICBtYXhUb3BpY0luZGV4OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLnNvbG9Bd2FpdCA9IGZhbHNlO1xuICAgIHRoaXMuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBmYWxzZTtcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMuZGVjb3JhdG9yU3RhY2sgPSBbW11dO1xuICAgIHRoaXMuY29tbWVudHMgPSBbXTtcbiAgICB0aGlzLmNvbW1lbnRTdGFjayA9IFtdO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLnR5cGUgPSAxMzU7XG4gICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5lbmQgPSAwO1xuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IG51bGw7XG4gICAgdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSBudWxsO1xuICAgIHRoaXMubGFzdFRva1N0YXJ0ID0gMDtcbiAgICB0aGlzLmNvbnRleHQgPSBbdHlwZXMuYnJhY2VdO1xuICAgIHRoaXMuY2FuU3RhcnRKU1hFbGVtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gICAgdGhpcy5zdHJpY3RFcnJvcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy50b2tlbnNMZW5ndGggPSAwO1xuICB9XG5cbiAgaW5pdCh7XG4gICAgc3RyaWN0TW9kZSxcbiAgICBzb3VyY2VUeXBlLFxuICAgIHN0YXJ0TGluZSxcbiAgICBzdGFydENvbHVtblxuICB9KSB7XG4gICAgdGhpcy5zdHJpY3QgPSBzdHJpY3RNb2RlID09PSBmYWxzZSA/IGZhbHNlIDogc3RyaWN0TW9kZSA9PT0gdHJ1ZSA/IHRydWUgOiBzb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiO1xuICAgIHRoaXMuY3VyTGluZSA9IHN0YXJ0TGluZTtcbiAgICB0aGlzLmxpbmVTdGFydCA9IC1zdGFydENvbHVtbjtcbiAgICB0aGlzLnN0YXJ0TG9jID0gdGhpcy5lbmRMb2MgPSBuZXcgUG9zaXRpb24oc3RhcnRMaW5lLCBzdGFydENvbHVtbiwgMCk7XG4gIH1cblxuICBjdXJQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMuY3VyTGluZSwgdGhpcy5wb3MgLSB0aGlzLmxpbmVTdGFydCwgdGhpcy5wb3MpO1xuICB9XG5cbiAgY2xvbmUoc2tpcEFycmF5cykge1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBsZXQgdmFsID0gdGhpc1trZXldO1xuXG4gICAgICBpZiAoIXNraXBBcnJheXMgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbCA9IHZhbC5zbGljZSgpO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZVtrZXldID0gdmFsO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG59XG5cbnZhciBfaXNEaWdpdCA9IGZ1bmN0aW9uIGlzRGlnaXQoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3O1xufTtcblxuY29uc3QgZm9yYmlkZGVuTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzID0ge1xuICBkZWNCaW5PY3Q6IG5ldyBTZXQoWzQ2LCA2NiwgNjksIDc5LCA5NSwgOTgsIDEwMSwgMTExXSksXG4gIGhleDogbmV3IFNldChbNDYsIDg4LCA5NSwgMTIwXSlcbn07XG5jb25zdCBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZyA9IHtcbiAgYmluOiBjaCA9PiBjaCA9PT0gNDggfHwgY2ggPT09IDQ5LFxuICBvY3Q6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU1LFxuICBkZWM6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU3LFxuICBoZXg6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU3IHx8IGNoID49IDY1ICYmIGNoIDw9IDcwIHx8IGNoID49IDk3ICYmIGNoIDw9IDEwMlxufTtcbmZ1bmN0aW9uIHJlYWRTdHJpbmdDb250ZW50cyh0eXBlLCBpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIGVycm9ycykge1xuICBjb25zdCBpbml0aWFsUG9zID0gcG9zO1xuICBjb25zdCBpbml0aWFsTGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICBjb25zdCBpbml0aWFsQ3VyTGluZSA9IGN1ckxpbmU7XG4gIGxldCBvdXQgPSBcIlwiO1xuICBsZXQgY29udGFpbnNJbnZhbGlkID0gZmFsc2U7XG4gIGxldCBjaHVua1N0YXJ0ID0gcG9zO1xuICBjb25zdCB7XG4gICAgbGVuZ3RoXG4gIH0gPSBpbnB1dDtcblxuICBmb3IgKDs7KSB7XG4gICAgaWYgKHBvcyA+PSBsZW5ndGgpIHtcbiAgICAgIGVycm9ycy51bnRlcm1pbmF0ZWQoaW5pdGlhbFBvcywgaW5pdGlhbExpbmVTdGFydCwgaW5pdGlhbEN1ckxpbmUpO1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCBjaCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChpc1N0cmluZ0VuZCh0eXBlLCBjaCwgaW5wdXQsIHBvcykpIHtcbiAgICAgIG91dCArPSBpbnB1dC5zbGljZShjaHVua1N0YXJ0LCBwb3MpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBsZXQgZXNjYXBlZDtcbiAgICAgICh7XG4gICAgICAgIGNoOiBlc2NhcGVkLFxuICAgICAgICBwb3MsXG4gICAgICAgIGxpbmVTdGFydCxcbiAgICAgICAgY3VyTGluZVxuICAgICAgfSA9IHJlYWRFc2NhcGVkQ2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHR5cGUgPT09IFwidGVtcGxhdGVcIiwgZXJyb3JzKSk7XG5cbiAgICAgIGlmIChlc2NhcGVkID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRhaW5zSW52YWxpZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gZXNjYXBlZDtcbiAgICAgIH1cblxuICAgICAgY2h1bmtTdGFydCA9IHBvcztcbiAgICB9IGVsc2UgaWYgKGNoID09PSA4MjMyIHx8IGNoID09PSA4MjMzKSB7XG4gICAgICArK3BvcztcbiAgICAgICsrY3VyTGluZTtcbiAgICAgIGxpbmVTdGFydCA9IHBvcztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAxMCB8fCBjaCA9PT0gMTMpIHtcbiAgICAgIGlmICh0eXBlID09PSBcInRlbXBsYXRlXCIpIHtcbiAgICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcykgKyBcIlxcblwiO1xuICAgICAgICArK3BvcztcblxuICAgICAgICBpZiAoY2ggPT09IDEzICYmIGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTApIHtcbiAgICAgICAgICArK3BvcztcbiAgICAgICAgfVxuXG4gICAgICAgICsrY3VyTGluZTtcbiAgICAgICAgY2h1bmtTdGFydCA9IGxpbmVTdGFydCA9IHBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy51bnRlcm1pbmF0ZWQoaW5pdGlhbFBvcywgaW5pdGlhbExpbmVTdGFydCwgaW5pdGlhbEN1ckxpbmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICArK3BvcztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvcyxcbiAgICBzdHI6IG91dCxcbiAgICBjb250YWluc0ludmFsaWQsXG4gICAgbGluZVN0YXJ0LFxuICAgIGN1ckxpbmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdFbmQodHlwZSwgY2gsIGlucHV0LCBwb3MpIHtcbiAgaWYgKHR5cGUgPT09IFwidGVtcGxhdGVcIikge1xuICAgIHJldHVybiBjaCA9PT0gOTYgfHwgY2ggPT09IDM2ICYmIGlucHV0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDEyMztcbiAgfVxuXG4gIHJldHVybiBjaCA9PT0gKHR5cGUgPT09IFwiZG91YmxlXCIgPyAzNCA6IDM5KTtcbn1cblxuZnVuY3Rpb24gcmVhZEVzY2FwZWRDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgaW5UZW1wbGF0ZSwgZXJyb3JzKSB7XG4gIGNvbnN0IHRocm93T25JbnZhbGlkID0gIWluVGVtcGxhdGU7XG4gIHBvcysrO1xuXG4gIGNvbnN0IHJlcyA9IGNoID0+ICh7XG4gICAgcG9zLFxuICAgIGNoLFxuICAgIGxpbmVTdGFydCxcbiAgICBjdXJMaW5lXG4gIH0pO1xuXG4gIGNvbnN0IGNoID0gaW5wdXQuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMTEwOlxuICAgICAgcmV0dXJuIHJlcyhcIlxcblwiKTtcblxuICAgIGNhc2UgMTE0OlxuICAgICAgcmV0dXJuIHJlcyhcIlxcclwiKTtcblxuICAgIGNhc2UgMTIwOlxuICAgICAge1xuICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgKHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHBvc1xuICAgICAgICB9ID0gcmVhZEhleENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCAyLCBmYWxzZSwgdGhyb3dPbkludmFsaWQsIGVycm9ycykpO1xuICAgICAgICByZXR1cm4gcmVzKGNvZGUgPT09IG51bGwgPyBudWxsIDogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gICAgICB9XG5cbiAgICBjYXNlIDExNzpcbiAgICAgIHtcbiAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICh7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfSA9IHJlYWRDb2RlUG9pbnQoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gICAgICAgIHJldHVybiByZXMoY29kZSA9PT0gbnVsbCA/IG51bGwgOiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKSk7XG4gICAgICB9XG5cbiAgICBjYXNlIDExNjpcbiAgICAgIHJldHVybiByZXMoXCJcXHRcIik7XG5cbiAgICBjYXNlIDk4OlxuICAgICAgcmV0dXJuIHJlcyhcIlxcYlwiKTtcblxuICAgIGNhc2UgMTE4OlxuICAgICAgcmV0dXJuIHJlcyhcIlxcdTAwMGJcIik7XG5cbiAgICBjYXNlIDEwMjpcbiAgICAgIHJldHVybiByZXMoXCJcXGZcIik7XG5cbiAgICBjYXNlIDEzOlxuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTApIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG5cbiAgICBjYXNlIDEwOlxuICAgICAgbGluZVN0YXJ0ID0gcG9zO1xuICAgICAgKytjdXJMaW5lO1xuXG4gICAgY2FzZSA4MjMyOlxuICAgIGNhc2UgODIzMzpcbiAgICAgIHJldHVybiByZXMoXCJcIik7XG5cbiAgICBjYXNlIDU2OlxuICAgIGNhc2UgNTc6XG4gICAgICBpZiAoaW5UZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm4gcmVzKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JzLnN0cmljdE51bWVyaWNFc2NhcGUocG9zIC0gMSwgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBwb3MgLSAxO1xuICAgICAgICBjb25zdCBtYXRjaCA9IGlucHV0LnNsaWNlKHN0YXJ0UG9zLCBwb3MgKyAyKS5tYXRjaCgvXlswLTddKy8pO1xuICAgICAgICBsZXQgb2N0YWxTdHIgPSBtYXRjaFswXTtcbiAgICAgICAgbGV0IG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuXG4gICAgICAgIGlmIChvY3RhbCA+IDI1NSkge1xuICAgICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgICAgaWYgKG9jdGFsU3RyICE9PSBcIjBcIiB8fCBuZXh0ID09PSA1NiB8fCBuZXh0ID09PSA1Nykge1xuICAgICAgICAgIGlmIChpblRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzKG51bGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMuc3RyaWN0TnVtZXJpY0VzY2FwZShzdGFydFBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzKFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZEhleENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCBsZW4sIGZvcmNlTGVuLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSB7XG4gIGNvbnN0IGluaXRpYWxQb3MgPSBwb3M7XG4gIGxldCBuO1xuICAoe1xuICAgIG4sXG4gICAgcG9zXG4gIH0gPSByZWFkSW50KGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgMTYsIGxlbiwgZm9yY2VMZW4sIGZhbHNlLCBlcnJvcnMpKTtcblxuICBpZiAobiA9PT0gbnVsbCkge1xuICAgIGlmICh0aHJvd09uSW52YWxpZCkge1xuICAgICAgZXJyb3JzLmludmFsaWRFc2NhcGVTZXF1ZW5jZShpbml0aWFsUG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBpbml0aWFsUG9zIC0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvZGU6IG4sXG4gICAgcG9zXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRJbnQoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCByYWRpeCwgbGVuLCBmb3JjZUxlbiwgYWxsb3dOdW1TZXBhcmF0b3IsIGVycm9ycykge1xuICBjb25zdCBzdGFydCA9IHBvcztcbiAgY29uc3QgZm9yYmlkZGVuU2libGluZ3MgPSByYWRpeCA9PT0gMTYgPyBmb3JiaWRkZW5OdW1lcmljU2VwYXJhdG9yU2libGluZ3MuaGV4IDogZm9yYmlkZGVuTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzLmRlY0Jpbk9jdDtcbiAgY29uc3QgaXNBbGxvd2VkU2libGluZyA9IHJhZGl4ID09PSAxNiA/IGlzQWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5nLmhleCA6IHJhZGl4ID09PSAxMCA/IGlzQWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5nLmRlYyA6IHJhZGl4ID09PSA4ID8gaXNBbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmcub2N0IDogaXNBbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmcuYmluO1xuICBsZXQgaW52YWxpZCA9IGZhbHNlO1xuICBsZXQgdG90YWwgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgbGV0IHZhbDtcblxuICAgIGlmIChjb2RlID09PSA5NSAmJiBhbGxvd051bVNlcGFyYXRvciAhPT0gXCJiYWlsXCIpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyAtIDEpO1xuICAgICAgY29uc3QgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zICsgMSk7XG5cbiAgICAgIGlmICghYWxsb3dOdW1TZXBhcmF0b3IpIHtcbiAgICAgICAgZXJyb3JzLm51bWVyaWNTZXBhcmF0b3JJbkVzY2FwZVNlcXVlbmNlKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzTmFOKG5leHQpIHx8ICFpc0FsbG93ZWRTaWJsaW5nKG5leHQpIHx8IGZvcmJpZGRlblNpYmxpbmdzLmhhcyhwcmV2KSB8fCBmb3JiaWRkZW5TaWJsaW5ncy5oYXMobmV4dCkpIHtcbiAgICAgICAgZXJyb3JzLnVuZXhwZWN0ZWROdW1lcmljU2VwYXJhdG9yKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH1cblxuICAgICAgKytwb3M7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA+PSA5Nykge1xuICAgICAgdmFsID0gY29kZSAtIDk3ICsgMTA7XG4gICAgfSBlbHNlIGlmIChjb2RlID49IDY1KSB7XG4gICAgICB2YWwgPSBjb2RlIC0gNjUgKyAxMDtcbiAgICB9IGVsc2UgaWYgKF9pc0RpZ2l0KGNvZGUpKSB7XG4gICAgICB2YWwgPSBjb2RlIC0gNDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IEluZmluaXR5O1xuICAgIH1cblxuICAgIGlmICh2YWwgPj0gcmFkaXgpIHtcbiAgICAgIGlmICh2YWwgPD0gOSAmJiBlcnJvcnMuaW52YWxpZERpZ2l0KHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCByYWRpeCkpIHtcbiAgICAgICAgdmFsID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoZm9yY2VMZW4pIHtcbiAgICAgICAgdmFsID0gMDtcbiAgICAgICAgaW52YWxpZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICArK3BvcztcbiAgICB0b3RhbCA9IHRvdGFsICogcmFkaXggKyB2YWw7XG4gIH1cblxuICBpZiAocG9zID09PSBzdGFydCB8fCBsZW4gIT0gbnVsbCAmJiBwb3MgLSBzdGFydCAhPT0gbGVuIHx8IGludmFsaWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbjogbnVsbCxcbiAgICAgIHBvc1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG46IHRvdGFsLFxuICAgIHBvc1xuICB9O1xufVxuZnVuY3Rpb24gcmVhZENvZGVQb2ludChpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHRocm93T25JbnZhbGlkLCBlcnJvcnMpIHtcbiAgY29uc3QgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gIGxldCBjb2RlO1xuXG4gIGlmIChjaCA9PT0gMTIzKSB7XG4gICAgKytwb3M7XG4gICAgKHtcbiAgICAgIGNvZGUsXG4gICAgICBwb3NcbiAgICB9ID0gcmVhZEhleENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCBpbnB1dC5pbmRleE9mKFwifVwiLCBwb3MpIC0gcG9zLCB0cnVlLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gICAgKytwb3M7XG5cbiAgICBpZiAoY29kZSAhPT0gbnVsbCAmJiBjb2RlID4gMHgxMGZmZmYpIHtcbiAgICAgIGlmICh0aHJvd09uSW52YWxpZCkge1xuICAgICAgICBlcnJvcnMuaW52YWxpZENvZGVQb2ludChwb3MsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgICh7XG4gICAgICBjb2RlLFxuICAgICAgcG9zXG4gICAgfSA9IHJlYWRIZXhDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgNCwgZmFsc2UsIHRocm93T25JbnZhbGlkLCBlcnJvcnMpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29kZSxcbiAgICBwb3NcbiAgfTtcbn1cblxuY29uc3QgX2V4Y2x1ZGVkID0gW1wiYXRcIl0sXG4gICAgICBfZXhjbHVkZWQyID0gW1wiYXRcIl07XG5cbmZ1bmN0aW9uIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpIHtcbiAgcmV0dXJuIG5ldyBQb3NpdGlvbihjdXJMaW5lLCBwb3MgLSBsaW5lU3RhcnQsIHBvcyk7XG59XG5cbmNvbnN0IFZBTElEX1JFR0VYX0ZMQUdTID0gbmV3IFNldChbMTAzLCAxMDksIDExNSwgMTA1LCAxMjEsIDExNywgMTAwLCAxMThdKTtcbmNsYXNzIFRva2VuIHtcbiAgY29uc3RydWN0b3Ioc3RhdGUpIHtcbiAgICB0aGlzLnR5cGUgPSBzdGF0ZS50eXBlO1xuICAgIHRoaXMudmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhdGUuc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBzdGF0ZS5lbmQ7XG4gICAgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24oc3RhdGUuc3RhcnRMb2MsIHN0YXRlLmVuZExvYyk7XG4gIH1cblxufVxuY2xhc3MgVG9rZW5pemVyIGV4dGVuZHMgQ29tbWVudHNQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpbnB1dCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pc0xvb2thaGVhZCA9IHZvaWQgMDtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkSW50ID0ge1xuICAgICAgaW52YWxpZERpZ2l0OiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHJhZGl4KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmVycm9yUmVjb3ZlcnkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZERpZ2l0LCB7XG4gICAgICAgICAgYXQ6IGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpLFxuICAgICAgICAgIHJhZGl4XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBudW1lcmljU2VwYXJhdG9ySW5Fc2NhcGVTZXF1ZW5jZTogdGhpcy5lcnJvckJ1aWxkZXIoRXJyb3JzLk51bWVyaWNTZXBhcmF0b3JJbkVzY2FwZVNlcXVlbmNlKSxcbiAgICAgIHVuZXhwZWN0ZWROdW1lcmljU2VwYXJhdG9yOiB0aGlzLmVycm9yQnVpbGRlcihFcnJvcnMuVW5leHBlY3RlZE51bWVyaWNTZXBhcmF0b3IpXG4gICAgfTtcbiAgICB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZENvZGVQb2ludCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkSW50LCB7XG4gICAgICBpbnZhbGlkRXNjYXBlU2VxdWVuY2U6IHRoaXMuZXJyb3JCdWlsZGVyKEVycm9ycy5JbnZhbGlkRXNjYXBlU2VxdWVuY2UpLFxuICAgICAgaW52YWxpZENvZGVQb2ludDogdGhpcy5lcnJvckJ1aWxkZXIoRXJyb3JzLkludmFsaWRDb2RlUG9pbnQpXG4gICAgfSk7XG4gICAgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRTdHJpbmdDb250ZW50c19zdHJpbmcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZENvZGVQb2ludCwge1xuICAgICAgc3RyaWN0TnVtZXJpY0VzY2FwZTogKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSA9PiB7XG4gICAgICAgIHRoaXMucmVjb3JkU3RyaWN0TW9kZUVycm9ycyhFcnJvcnMuU3RyaWN0TnVtZXJpY0VzY2FwZSwge1xuICAgICAgICAgIGF0OiBidWlsZFBvc2l0aW9uKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB1bnRlcm1pbmF0ZWQ6IChwb3MsIGxpbmVTdGFydCwgY3VyTGluZSkgPT4ge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRTdHJpbmcsIHtcbiAgICAgICAgICBhdDogYnVpbGRQb3NpdGlvbihwb3MgLSAxLCBsaW5lU3RhcnQsIGN1ckxpbmUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkU3RyaW5nQ29udGVudHNfdGVtcGxhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZENvZGVQb2ludCwge1xuICAgICAgc3RyaWN0TnVtZXJpY0VzY2FwZTogdGhpcy5lcnJvckJ1aWxkZXIoRXJyb3JzLlN0cmljdE51bWVyaWNFc2NhcGUpLFxuICAgICAgdW50ZXJtaW5hdGVkOiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpID0+IHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkVGVtcGxhdGUsIHtcbiAgICAgICAgICBhdDogYnVpbGRQb3NpdGlvbihwb3MsIGxpbmVTdGFydCwgY3VyTGluZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZSgpO1xuICAgIHRoaXMuc3RhdGUuaW5pdChvcHRpb25zKTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgdGhpcy5pc0xvb2thaGVhZCA9IGZhbHNlO1xuICB9XG5cbiAgcHVzaFRva2VuKHRva2VuKSB7XG4gICAgdGhpcy50b2tlbnMubGVuZ3RoID0gdGhpcy5zdGF0ZS50b2tlbnNMZW5ndGg7XG4gICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgKyt0aGlzLnN0YXRlLnRva2Vuc0xlbmd0aDtcbiAgfVxuXG4gIG5leHQoKSB7XG4gICAgdGhpcy5jaGVja0tleXdvcmRFc2NhcGVzKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRva2Vucykge1xuICAgICAgdGhpcy5wdXNoVG9rZW4obmV3IFRva2VuKHRoaXMuc3RhdGUpKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jID0gdGhpcy5zdGF0ZS5lbmRMb2M7XG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gIH1cblxuICBlYXQodHlwZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKHR5cGUpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgbWF0Y2godHlwZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnR5cGUgPT09IHR5cGU7XG4gIH1cblxuICBjcmVhdGVMb29rYWhlYWRTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3M6IHN0YXRlLnBvcyxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgdHlwZTogc3RhdGUudHlwZSxcbiAgICAgIHN0YXJ0OiBzdGF0ZS5zdGFydCxcbiAgICAgIGVuZDogc3RhdGUuZW5kLFxuICAgICAgY29udGV4dDogW3RoaXMuY3VyQ29udGV4dCgpXSxcbiAgICAgIGluVHlwZTogc3RhdGUuaW5UeXBlLFxuICAgICAgc3RhcnRMb2M6IHN0YXRlLnN0YXJ0TG9jLFxuICAgICAgbGFzdFRva0VuZExvYzogc3RhdGUubGFzdFRva0VuZExvYyxcbiAgICAgIGN1ckxpbmU6IHN0YXRlLmN1ckxpbmUsXG4gICAgICBsaW5lU3RhcnQ6IHN0YXRlLmxpbmVTdGFydCxcbiAgICAgIGN1clBvc2l0aW9uOiBzdGF0ZS5jdXJQb3NpdGlvblxuICAgIH07XG4gIH1cblxuICBsb29rYWhlYWQoKSB7XG4gICAgY29uc3Qgb2xkID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5jcmVhdGVMb29rYWhlYWRTdGF0ZShvbGQpO1xuICAgIHRoaXMuaXNMb29rYWhlYWQgPSB0cnVlO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgdGhpcy5pc0xvb2thaGVhZCA9IGZhbHNlO1xuICAgIGNvbnN0IGN1cnIgPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuc3RhdGUgPSBvbGQ7XG4gICAgcmV0dXJuIGN1cnI7XG4gIH1cblxuICBuZXh0VG9rZW5TdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW5TdGFydFNpbmNlKHRoaXMuc3RhdGUucG9zKTtcbiAgfVxuXG4gIG5leHRUb2tlblN0YXJ0U2luY2UocG9zKSB7XG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gcG9zO1xuICAgIHJldHVybiBza2lwV2hpdGVTcGFjZS50ZXN0KHRoaXMuaW5wdXQpID8gc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4IDogcG9zO1xuICB9XG5cbiAgbG9va2FoZWFkQ2hhckNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLm5leHRUb2tlblN0YXJ0KCkpO1xuICB9XG5cbiAgY29kZVBvaW50QXRQb3MocG9zKSB7XG4gICAgbGV0IGNwID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoKGNwICYgMHhmYzAwKSA9PT0gMHhkODAwICYmICsrcG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRyYWlsID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIGlmICgodHJhaWwgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgY3AgPSAweDEwMDAwICsgKChjcCAmIDB4M2ZmKSA8PCAxMCkgKyAodHJhaWwgJiAweDNmZik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNwO1xuICB9XG5cbiAgc2V0U3RyaWN0KHN0cmljdCkge1xuICAgIHRoaXMuc3RhdGUuc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuZm9yRWFjaCgoW3RvUGFyc2VFcnJvciwgYXRdKSA9PiB0aGlzLnJhaXNlKHRvUGFyc2VFcnJvciwge1xuICAgICAgICBhdFxuICAgICAgfSkpO1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICBjdXJDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbnRleHRbdGhpcy5zdGF0ZS5jb250ZXh0Lmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgbmV4dFRva2VuKCkge1xuICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgdGhpcy5zdGF0ZS5zdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGlmICghdGhpcy5pc0xvb2thaGVhZCkgdGhpcy5zdGF0ZS5zdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcblxuICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0VG9rZW5Gcm9tQ29kZSh0aGlzLmNvZGVQb2ludEF0UG9zKHRoaXMuc3RhdGUucG9zKSk7XG4gIH1cblxuICBza2lwQmxvY2tDb21tZW50KCkge1xuICAgIGxldCBzdGFydExvYztcbiAgICBpZiAoIXRoaXMuaXNMb29rYWhlYWQpIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3QgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgc3RhcnQgKyAyKTtcblxuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRDb21tZW50LCB7XG4gICAgICAgIGF0OiB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUucG9zID0gZW5kICsgMjtcbiAgICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IHN0YXJ0ICsgMjtcblxuICAgIHdoaWxlIChsaW5lQnJlYWtHLnRlc3QodGhpcy5pbnB1dCkgJiYgbGluZUJyZWFrRy5sYXN0SW5kZXggPD0gZW5kKSB7XG4gICAgICArK3RoaXMuc3RhdGUuY3VyTGluZTtcbiAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gbGluZUJyZWFrRy5sYXN0SW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNMb29rYWhlYWQpIHJldHVybjtcbiAgICBjb25zdCBjb21tZW50ID0ge1xuICAgICAgdHlwZTogXCJDb21tZW50QmxvY2tcIixcbiAgICAgIHZhbHVlOiB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgZW5kKSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kOiBlbmQgKyAyLFxuICAgICAgbG9jOiBuZXcgU291cmNlTG9jYXRpb24oc3RhcnRMb2MsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSlcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG9rZW5zKSB0aGlzLnB1c2hUb2tlbihjb21tZW50KTtcbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuXG4gIHNraXBMaW5lQ29tbWVudChzdGFydFNraXApIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGxldCBzdGFydExvYztcbiAgICBpZiAoIXRoaXMuaXNMb29rYWhlYWQpIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGxldCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArPSBzdGFydFNraXApO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIHdoaWxlICghaXNOZXdMaW5lKGNoKSAmJiArK3RoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTG9va2FoZWFkKSByZXR1cm47XG4gICAgY29uc3QgZW5kID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCBlbmQpO1xuICAgIGNvbnN0IGNvbW1lbnQgPSB7XG4gICAgICB0eXBlOiBcIkNvbW1lbnRMaW5lXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgbG9jOiBuZXcgU291cmNlTG9jYXRpb24oc3RhcnRMb2MsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSlcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG9rZW5zKSB0aGlzLnB1c2hUb2tlbihjb21tZW50KTtcbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuXG4gIHNraXBTcGFjZSgpIHtcbiAgICBjb25zdCBzcGFjZVN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3QgY29tbWVudHMgPSBbXTtcblxuICAgIGxvb3A6IHdoaWxlICh0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG5cbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgY2FzZSAxNjA6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAxMCkge1xuICAgICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgY2FzZSA4MjMyOlxuICAgICAgICBjYXNlIDgyMzM6XG4gICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICArK3RoaXMuc3RhdGUuY3VyTGluZTtcbiAgICAgICAgICB0aGlzLnN0YXRlLmxpbmVTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgc3dpdGNoICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSkge1xuICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLnNraXBCbG9ja0NvbW1lbnQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXR0YWNoQ29tbWVudCkgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuc2tpcExpbmVDb21tZW50KDIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZGRDb21tZW50KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdHRhY2hDb21tZW50KSBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGNoKSkge1xuICAgICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSA0NSAmJiAhdGhpcy5pbk1vZHVsZSkge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5zdGF0ZS5wb3M7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDQ1ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAyKSA9PT0gNjIgJiYgKHNwYWNlU3RhcnQgPT09IDAgfHwgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPiBzcGFjZVN0YXJ0KSkge1xuICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG5cbiAgICAgICAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF0dGFjaENvbW1lbnQpIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuc3RhdGUucG9zO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDEpID09PSAzMyAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMikgPT09IDQ1ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAzKSA9PT0gNDUpIHtcbiAgICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuc2tpcExpbmVDb21tZW50KDQpO1xuXG4gICAgICAgICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdHRhY2hDb21tZW50KSBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBlbmQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgIGNvbnN0IGNvbW1lbnRXaGl0ZXNwYWNlID0ge1xuICAgICAgICBzdGFydDogc3BhY2VTdGFydCxcbiAgICAgICAgZW5kLFxuICAgICAgICBjb21tZW50cyxcbiAgICAgICAgbGVhZGluZ05vZGU6IG51bGwsXG4gICAgICAgIHRyYWlsaW5nTm9kZTogbnVsbCxcbiAgICAgICAgY29udGFpbmluZ05vZGU6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLnN0YXRlLmNvbW1lbnRTdGFjay5wdXNoKGNvbW1lbnRXaGl0ZXNwYWNlKTtcbiAgICB9XG4gIH1cblxuICBmaW5pc2hUb2tlbih0eXBlLCB2YWwpIHtcbiAgICB0aGlzLnN0YXRlLmVuZCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHRoaXMuc3RhdGUuZW5kTG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGNvbnN0IHByZXZUeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIHRoaXMuc3RhdGUudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zdGF0ZS52YWx1ZSA9IHZhbDtcblxuICAgIGlmICghdGhpcy5pc0xvb2thaGVhZCkge1xuICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKTtcbiAgICB9XG4gIH1cblxuICByZXBsYWNlVG9rZW4odHlwZSkge1xuICAgIHRoaXMuc3RhdGUudHlwZSA9IHR5cGU7XG4gICAgdGhpcy51cGRhdGVDb250ZXh0KCk7XG4gIH1cblxuICByZWFkVG9rZW5fbnVtYmVyU2lnbigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IDAgJiYgdGhpcy5yZWFkVG9rZW5faW50ZXJwcmV0ZXIoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5leHRQb3MgPSB0aGlzLnN0YXRlLnBvcyArIDE7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY29kZVBvaW50QXRQb3MobmV4dFBvcyk7XG5cbiAgICBpZiAobmV4dCA+PSA0OCAmJiBuZXh0IDw9IDU3KSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkRGlnaXRBZnRlckhhc2gsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IDEyMyB8fCBuZXh0ID09PSA5MSAmJiB0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpO1xuXG4gICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLCBcInN5bnRheFR5cGVcIikgIT09IFwiaGFzaFwiKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UobmV4dCA9PT0gMTIzID8gRXJyb3JzLlJlY29yZEV4cHJlc3Npb25IYXNoSW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlIDogRXJyb3JzLlR1cGxlRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGUsIHtcbiAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuXG4gICAgICBpZiAobmV4dCA9PT0gMTIzKSB7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oNyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNJZGVudGlmaWVyU3RhcnQobmV4dCkpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDEzNCwgdGhpcy5yZWFkV29yZDEobmV4dCkpO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gOTIpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDEzNCwgdGhpcy5yZWFkV29yZDEoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMjcsIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJlYWRUb2tlbl9kb3QoKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuXG4gICAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1Nykge1xuICAgICAgdGhpcy5yZWFkTnVtYmVyKHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSA0NiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKSA9PT0gNDYpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zICs9IDM7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDIxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTYpO1xuICAgIH1cbiAgfVxuXG4gIHJlYWRUb2tlbl9zbGFzaCgpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzEsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDU2LCAxKTtcbiAgICB9XG4gIH1cblxuICByZWFkVG9rZW5faW50ZXJwcmV0ZXIoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUucG9zICE9PSAwIHx8IHRoaXMubGVuZ3RoIDwgMikgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGlmIChjaCAhPT0gMzMpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHRoaXMuc3RhdGUucG9zICs9IDE7XG5cbiAgICB3aGlsZSAoIWlzTmV3TGluZShjaCkgJiYgKyt0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMjgsIHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJlYWRUb2tlbl9tdWx0X21vZHVsbyhjb2RlKSB7XG4gICAgbGV0IHR5cGUgPSBjb2RlID09PSA0MiA/IDU1IDogNTQ7XG4gICAgbGV0IHdpZHRoID0gMTtcbiAgICBsZXQgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuXG4gICAgaWYgKGNvZGUgPT09IDQyICYmIG5leHQgPT09IDQyKSB7XG4gICAgICB3aWR0aCsrO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpO1xuICAgICAgdHlwZSA9IDU3O1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSA2MSAmJiAhdGhpcy5zdGF0ZS5pblR5cGUpIHtcbiAgICAgIHdpZHRoKys7XG4gICAgICB0eXBlID0gY29kZSA9PT0gMzcgPyAzMyA6IDMwO1xuICAgIH1cblxuICAgIHRoaXMuZmluaXNoT3AodHlwZSwgd2lkdGgpO1xuICB9XG5cbiAgcmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG5cbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA2MSkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDMwLCAzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gNDEgOiA0MiwgMik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMTI0KSB7XG4gICAgICBpZiAobmV4dCA9PT0gNjIpIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCgzOSwgMik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwicmVjb3JkQW5kVHVwbGVcIikgJiYgbmV4dCA9PT0gMTI1KSB7XG4gICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInJlY29yZEFuZFR1cGxlXCIsIFwic3ludGF4VHlwZVwiKSAhPT0gXCJiYXJcIikge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RFbmRTeW50YXhUeXBlLCB7XG4gICAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpICYmIG5leHQgPT09IDkzKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInJlY29yZEFuZFR1cGxlXCIsIFwic3ludGF4VHlwZVwiKSAhPT0gXCJiYXJcIikge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlR1cGxlRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGUsIHtcbiAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oNCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzAsIDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gNDMgOiA0NSwgMSk7XG4gIH1cblxuICByZWFkVG9rZW5fY2FyZXQoKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuXG4gICAgaWYgKG5leHQgPT09IDYxICYmICF0aGlzLnN0YXRlLmluVHlwZSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzMiwgMik7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSA5NCAmJiB0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgIHByb3Bvc2FsOiBcImhhY2tcIixcbiAgICAgIHRvcGljVG9rZW46IFwiXl5cIlxuICAgIH1dKSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzNywgMik7XG4gICAgICBjb25zdCBsb29rYWhlYWRDaCA9IHRoaXMuaW5wdXQuY29kZVBvaW50QXQodGhpcy5zdGF0ZS5wb3MpO1xuXG4gICAgICBpZiAobG9va2FoZWFkQ2ggPT09IDk0KSB7XG4gICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ0LCAxKTtcbiAgICB9XG4gIH1cblxuICByZWFkVG9rZW5fYXRTaWduKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcblxuICAgIGlmIChuZXh0ID09PSA2NCAmJiB0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgIHByb3Bvc2FsOiBcImhhY2tcIixcbiAgICAgIHRvcGljVG9rZW46IFwiQEBcIlxuICAgIH1dKSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzOCwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMjYsIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJlYWRUb2tlbl9wbHVzX21pbihjb2RlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuXG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzQsIDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzMCwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNTMsIDEpO1xuICAgIH1cbiAgfVxuXG4gIHJlYWRUb2tlbl9sdCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwb3NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDEpO1xuXG4gICAgaWYgKG5leHQgPT09IDYwKSB7XG4gICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDIpID09PSA2MSkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDMwLCAzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbmlzaE9wKDUxLCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNDksIDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZmluaXNoT3AoNDcsIDEpO1xuICB9XG5cbiAgcmVhZFRva2VuX2d0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMSk7XG5cbiAgICBpZiAobmV4dCA9PT0gNjIpIHtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMikgPT09IDYyID8gMyA6IDI7XG5cbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgc2l6ZSkgPT09IDYxKSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMzAsIHNpemUgKyAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbmlzaE9wKDUyLCBzaXplKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNDksIDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZmluaXNoT3AoNDgsIDEpO1xuICB9XG5cbiAgcmVhZFRva2VuX2VxX2V4Y2woY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcblxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgdGhpcy5maW5pc2hPcCg0NiwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMikgPT09IDYxID8gMyA6IDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSA2MSAmJiBuZXh0ID09PSA2Mikge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyAyOSA6IDM1LCAxKTtcbiAgfVxuXG4gIHJlYWRUb2tlbl9xdWVzdGlvbigpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgY29uc3QgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKTtcblxuICAgIGlmIChuZXh0ID09PSA2Mykge1xuICAgICAgaWYgKG5leHQyID09PSA2MSkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDMwLCAzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoNDAsIDIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gNDYgJiYgIShuZXh0MiA+PSA0OCAmJiBuZXh0MiA8PSA1NykpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDE4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTcpO1xuICAgIH1cbiAgfVxuXG4gIGdldFRva2VuRnJvbUNvZGUoY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSA0NjpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fZG90KCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSA0MDpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxMCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSA0MTpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxMSk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSA1OTpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSA0NDpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxMik7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSA5MTpcbiAgICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwicmVjb3JkQW5kVHVwbGVcIikgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSkgPT09IDEyNCkge1xuICAgICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInJlY29yZEFuZFR1cGxlXCIsIFwic3ludGF4VHlwZVwiKSAhPT0gXCJiYXJcIikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVHVwbGVFeHByZXNzaW9uQmFySW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlLCB7XG4gICAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICAgICAgdGhpcy5maW5pc2hUb2tlbigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgOTM6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMyk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAxMjM6XG4gICAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAxMjQpIHtcbiAgICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLCBcInN5bnRheFR5cGVcIikgIT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGUsIHtcbiAgICAgICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgdGhpcy5maW5pc2hUb2tlbig1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAxMjU6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oOCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSA1ODpcbiAgICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZnVuY3Rpb25CaW5kXCIpICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSA1OCkge1xuICAgICAgICAgIHRoaXMuZmluaXNoT3AoMTUsIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxNCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgNjM6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX3F1ZXN0aW9uKCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSA5NjpcbiAgICAgICAgdGhpcy5yZWFkVGVtcGxhdGVUb2tlbigpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgNDg6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG5cbiAgICAgICAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYWRpeE51bWJlcigxNik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5leHQgPT09IDExMSB8fCBuZXh0ID09PSA3OSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkUmFkaXhOdW1iZXIoOCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYWRpeE51bWJlcigyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSA0OTpcbiAgICAgIGNhc2UgNTA6XG4gICAgICBjYXNlIDUxOlxuICAgICAgY2FzZSA1MjpcbiAgICAgIGNhc2UgNTM6XG4gICAgICBjYXNlIDU0OlxuICAgICAgY2FzZSA1NTpcbiAgICAgIGNhc2UgNTY6XG4gICAgICBjYXNlIDU3OlxuICAgICAgICB0aGlzLnJlYWROdW1iZXIoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgMzQ6XG4gICAgICBjYXNlIDM5OlxuICAgICAgICB0aGlzLnJlYWRTdHJpbmcoY29kZSk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSA0NzpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fc2xhc2goKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIDM3OlxuICAgICAgY2FzZSA0MjpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAxMjQ6XG4gICAgICBjYXNlIDM4OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIDk0OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9jYXJldCgpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgNDM6XG4gICAgICBjYXNlIDQ1OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIDYwOlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9sdCgpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgNjI6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2d0KCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSA2MTpcbiAgICAgIGNhc2UgMzM6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSAxMjY6XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMzYsIDEpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgNjQ6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2F0U2lnbigpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgMzU6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX251bWJlclNpZ24oKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBjYXNlIDkyOlxuICAgICAgICB0aGlzLnJlYWRXb3JkKCk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpKSB7XG4gICAgICAgICAgdGhpcy5yZWFkV29yZChjb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRPclVuZXhwZWN0ZWRUb2tlbiwge1xuICAgICAgYXQ6IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSxcbiAgICAgIHVuZXhwZWN0ZWQ6IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpXG4gICAgfSk7XG4gIH1cblxuICBmaW5pc2hPcCh0eXBlLCBzaXplKSB7XG4gICAgY29uc3Qgc3RyID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLnBvcywgdGhpcy5zdGF0ZS5wb3MgKyBzaXplKTtcbiAgICB0aGlzLnN0YXRlLnBvcyArPSBzaXplO1xuICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKTtcbiAgfVxuXG4gIHJlYWRSZWdleHAoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5zdGFydCArIDE7XG4gICAgbGV0IGVzY2FwZWQsIGluQ2xhc3M7XG4gICAgbGV0IHtcbiAgICAgIHBvc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgZm9yICg7OyArK3Bvcykge1xuICAgICAgaWYgKHBvcyA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRSZWdFeHAsIHtcbiAgICAgICAgICBhdDogY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHN0YXJ0TG9jLCAxKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkUmVnRXhwLCB7XG4gICAgICAgICAgYXQ6IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgMSlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaCA9PT0gOTEpIHtcbiAgICAgICAgICBpbkNsYXNzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTMgJiYgaW5DbGFzcykge1xuICAgICAgICAgIGluQ2xhc3MgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNDcgJiYgIWluQ2xhc3MpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGVzY2FwZWQgPSBjaCA9PT0gOTI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHBvcyk7XG4gICAgKytwb3M7XG4gICAgbGV0IG1vZHMgPSBcIlwiO1xuXG4gICAgY29uc3QgbmV4dFBvcyA9ICgpID0+IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgcG9zICsgMiAtIHN0YXJ0KTtcblxuICAgIHdoaWxlIChwb3MgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgY29uc3QgY3AgPSB0aGlzLmNvZGVQb2ludEF0UG9zKHBvcyk7XG4gICAgICBjb25zdCBjaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjcCk7XG5cbiAgICAgIGlmIChWQUxJRF9SRUdFWF9GTEFHUy5oYXMoY3ApKSB7XG4gICAgICAgIGlmIChjcCA9PT0gMTE4KSB7XG4gICAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJyZWdleHBVbmljb2RlU2V0c1wiLCBuZXh0UG9zKCkpO1xuXG4gICAgICAgICAgaWYgKG1vZHMuaW5jbHVkZXMoXCJ1XCIpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbmNvbXBhdGlibGVSZWdFeHBVVkZsYWdzLCB7XG4gICAgICAgICAgICAgIGF0OiBuZXh0UG9zKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjcCA9PT0gMTE3KSB7XG4gICAgICAgICAgaWYgKG1vZHMuaW5jbHVkZXMoXCJ2XCIpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbmNvbXBhdGlibGVSZWdFeHBVVkZsYWdzLCB7XG4gICAgICAgICAgICAgIGF0OiBuZXh0UG9zKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RzLmluY2x1ZGVzKGNoYXIpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlUmVnRXhwRmxhZ3MsIHtcbiAgICAgICAgICAgIGF0OiBuZXh0UG9zKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXJDaGFyKGNwKSB8fCBjcCA9PT0gOTIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTWFsZm9ybWVkUmVnRXhwRmxhZ3MsIHtcbiAgICAgICAgICBhdDogbmV4dFBvcygpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgICsrcG9zO1xuICAgICAgbW9kcyArPSBjaGFyO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUucG9zID0gcG9zO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMTMzLCB7XG4gICAgICBwYXR0ZXJuOiBjb250ZW50LFxuICAgICAgZmxhZ3M6IG1vZHNcbiAgICB9KTtcbiAgfVxuXG4gIHJlYWRJbnQocmFkaXgsIGxlbiwgZm9yY2VMZW4gPSBmYWxzZSwgYWxsb3dOdW1TZXBhcmF0b3IgPSB0cnVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbixcbiAgICAgIHBvc1xuICAgIH0gPSByZWFkSW50KHRoaXMuaW5wdXQsIHRoaXMuc3RhdGUucG9zLCB0aGlzLnN0YXRlLmxpbmVTdGFydCwgdGhpcy5zdGF0ZS5jdXJMaW5lLCByYWRpeCwgbGVuLCBmb3JjZUxlbiwgYWxsb3dOdW1TZXBhcmF0b3IsIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkSW50KTtcbiAgICB0aGlzLnN0YXRlLnBvcyA9IHBvcztcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIHJlYWRSYWRpeE51bWJlcihyYWRpeCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGxldCBpc0JpZ0ludCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgY29uc3QgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KTtcblxuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZERpZ2l0LCB7XG4gICAgICAgIGF0OiBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIDIpLFxuICAgICAgICByYWRpeFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG5cbiAgICBpZiAobmV4dCA9PT0gMTEwKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgaXNCaWdJbnQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gMTA5KSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGVjaW1hbCwge1xuICAgICAgICBhdDogc3RhcnRMb2NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmNvZGVQb2ludEF0UG9zKHRoaXMuc3RhdGUucG9zKSkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLk51bWJlcklkZW50aWZpZXIsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQmlnSW50KSB7XG4gICAgICBjb25zdCBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0TG9jLmluZGV4LCB0aGlzLnN0YXRlLnBvcykucmVwbGFjZSgvW19uXS9nLCBcIlwiKTtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTMxLCBzdHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZmluaXNoVG9rZW4oMTMwLCB2YWwpO1xuICB9XG5cbiAgcmVhZE51bWJlcihzdGFydHNXaXRoRG90KSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBsZXQgaXNGbG9hdCA9IGZhbHNlO1xuICAgIGxldCBpc0JpZ0ludCA9IGZhbHNlO1xuICAgIGxldCBpc0RlY2ltYWwgPSBmYWxzZTtcbiAgICBsZXQgaGFzRXhwb25lbnQgPSBmYWxzZTtcbiAgICBsZXQgaXNPY3RhbCA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGFydHNXaXRoRG90ICYmIHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWROdW1iZXIsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzTGVhZGluZ1plcm8gPSB0aGlzLnN0YXRlLnBvcyAtIHN0YXJ0ID49IDIgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gNDg7XG5cbiAgICBpZiAoaGFzTGVhZGluZ1plcm8pIHtcbiAgICAgIGNvbnN0IGludGVnZXIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICB0aGlzLnJlY29yZFN0cmljdE1vZGVFcnJvcnMoRXJyb3JzLlN0cmljdE9jdGFsTGl0ZXJhbCwge1xuICAgICAgICBhdDogc3RhcnRMb2NcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRoaXMuc3RhdGUuc3RyaWN0KSB7XG4gICAgICAgIGNvbnN0IHVuZGVyc2NvcmVQb3MgPSBpbnRlZ2VyLmluZGV4T2YoXCJfXCIpO1xuXG4gICAgICAgIGlmICh1bmRlcnNjb3JlUG9zID4gMCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlplcm9EaWdpdE51bWVyaWNTZXBhcmF0b3IsIHtcbiAgICAgICAgICAgIGF0OiBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIHVuZGVyc2NvcmVQb3MpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXNPY3RhbCA9IGhhc0xlYWRpbmdaZXJvICYmICEvWzg5XS8udGVzdChpbnRlZ2VyKTtcbiAgICB9XG5cbiAgICBsZXQgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG5cbiAgICBpZiAobmV4dCA9PT0gNDYgJiYgIWlzT2N0YWwpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB0aGlzLnJlYWRJbnQoMTApO1xuICAgICAgaXNGbG9hdCA9IHRydWU7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICB9XG5cbiAgICBpZiAoKG5leHQgPT09IDY5IHx8IG5leHQgPT09IDEwMSkgJiYgIWlzT2N0YWwpIHtcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcyk7XG5cbiAgICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkT3JNaXNzaW5nRXhwb25lbnQsIHtcbiAgICAgICAgICBhdDogc3RhcnRMb2NcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgICAgaGFzRXhwb25lbnQgPSB0cnVlO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IDExMCkge1xuICAgICAgaWYgKGlzRmxvYXQgfHwgaGFzTGVhZGluZ1plcm8pIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZEJpZ0ludExpdGVyYWwsIHtcbiAgICAgICAgICBhdDogc3RhcnRMb2NcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICBpc0JpZ0ludCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IDEwOSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJkZWNpbWFsXCIsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG5cbiAgICAgIGlmIChoYXNFeHBvbmVudCB8fCBoYXNMZWFkaW5nWmVybykge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGVjaW1hbCwge1xuICAgICAgICAgIGF0OiBzdGFydExvY1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIGlzRGVjaW1hbCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTnVtYmVySWRlbnRpZmllciwge1xuICAgICAgICBhdDogdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcykucmVwbGFjZSgvW19tbl0vZywgXCJcIik7XG5cbiAgICBpZiAoaXNCaWdJbnQpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTMxLCBzdHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0RlY2ltYWwpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTMyLCBzdHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbCA9IGlzT2N0YWwgPyBwYXJzZUludChzdHIsIDgpIDogcGFyc2VGbG9hdChzdHIpO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMTMwLCB2YWwpO1xuICB9XG5cbiAgcmVhZENvZGVQb2ludCh0aHJvd09uSW52YWxpZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvZGUsXG4gICAgICBwb3NcbiAgICB9ID0gcmVhZENvZGVQb2ludCh0aGlzLmlucHV0LCB0aGlzLnN0YXRlLnBvcywgdGhpcy5zdGF0ZS5saW5lU3RhcnQsIHRoaXMuc3RhdGUuY3VyTGluZSwgdGhyb3dPbkludmFsaWQsIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkQ29kZVBvaW50KTtcbiAgICB0aGlzLnN0YXRlLnBvcyA9IHBvcztcbiAgICByZXR1cm4gY29kZTtcbiAgfVxuXG4gIHJlYWRTdHJpbmcocXVvdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdHIsXG4gICAgICBwb3MsXG4gICAgICBjdXJMaW5lLFxuICAgICAgbGluZVN0YXJ0XG4gICAgfSA9IHJlYWRTdHJpbmdDb250ZW50cyhxdW90ZSA9PT0gMzQgPyBcImRvdWJsZVwiIDogXCJzaW5nbGVcIiwgdGhpcy5pbnB1dCwgdGhpcy5zdGF0ZS5wb3MgKyAxLCB0aGlzLnN0YXRlLmxpbmVTdGFydCwgdGhpcy5zdGF0ZS5jdXJMaW5lLCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZFN0cmluZ0NvbnRlbnRzX3N0cmluZyk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3MgKyAxO1xuICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgIHRoaXMuc3RhdGUuY3VyTGluZSA9IGN1ckxpbmU7XG4gICAgdGhpcy5maW5pc2hUb2tlbigxMjksIHN0cik7XG4gIH1cblxuICByZWFkVGVtcGxhdGVDb250aW51YXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgOCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5wb3MtLTtcbiAgICB0aGlzLnJlYWRUZW1wbGF0ZVRva2VuKCk7XG4gIH1cblxuICByZWFkVGVtcGxhdGVUb2tlbigpIHtcbiAgICBjb25zdCBvcGVuaW5nID0gdGhpcy5pbnB1dFt0aGlzLnN0YXRlLnBvc107XG4gICAgY29uc3Qge1xuICAgICAgc3RyLFxuICAgICAgY29udGFpbnNJbnZhbGlkLFxuICAgICAgcG9zLFxuICAgICAgY3VyTGluZSxcbiAgICAgIGxpbmVTdGFydFxuICAgIH0gPSByZWFkU3RyaW5nQ29udGVudHMoXCJ0ZW1wbGF0ZVwiLCB0aGlzLmlucHV0LCB0aGlzLnN0YXRlLnBvcyArIDEsIHRoaXMuc3RhdGUubGluZVN0YXJ0LCB0aGlzLnN0YXRlLmN1ckxpbmUsIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkU3RyaW5nQ29udGVudHNfdGVtcGxhdGUpO1xuICAgIHRoaXMuc3RhdGUucG9zID0gcG9zICsgMTtcbiAgICB0aGlzLnN0YXRlLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICB0aGlzLnN0YXRlLmN1ckxpbmUgPSBjdXJMaW5lO1xuXG4gICAgaWYgKHRoaXMuaW5wdXQuY29kZVBvaW50QXQocG9zKSA9PT0gOTYpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMjQsIGNvbnRhaW5zSW52YWxpZCA/IG51bGwgOiBvcGVuaW5nICsgc3RyICsgXCJgXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcysrO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigyNSwgY29udGFpbnNJbnZhbGlkID8gbnVsbCA6IG9wZW5pbmcgKyBzdHIgKyBcIiR7XCIpO1xuICAgIH1cbiAgfVxuXG4gIHJlY29yZFN0cmljdE1vZGVFcnJvcnModG9QYXJzZUVycm9yLCB7XG4gICAgYXRcbiAgfSkge1xuICAgIGNvbnN0IGluZGV4ID0gYXQuaW5kZXg7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5zdHJpY3QgJiYgIXRoaXMuc3RhdGUuc3RyaWN0RXJyb3JzLmhhcyhpbmRleCkpIHtcbiAgICAgIHRoaXMucmFpc2UodG9QYXJzZUVycm9yLCB7XG4gICAgICAgIGF0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuc2V0KGluZGV4LCBbdG9QYXJzZUVycm9yLCBhdF0pO1xuICAgIH1cbiAgfVxuXG4gIHJlYWRXb3JkMShmaXJzdENvZGUpIHtcbiAgICB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gICAgbGV0IHdvcmQgPSBcIlwiO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgbGV0IGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcblxuICAgIGlmIChmaXJzdENvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gZmlyc3RDb2RlIDw9IDB4ZmZmZiA/IDEgOiAyO1xuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaCA9IHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpO1xuXG4gICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSA5Mikge1xuICAgICAgICB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgY29uc3QgZXNjU3RhcnQgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXJDaGVjayA9IHRoaXMuc3RhdGUucG9zID09PSBzdGFydCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcjtcblxuICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5zdGF0ZS5wb3MpICE9PSAxMTcpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5NaXNzaW5nVW5pY29kZUVzY2FwZSwge1xuICAgICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcyAtIDE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICBjb25zdCBlc2MgPSB0aGlzLnJlYWRDb2RlUG9pbnQodHJ1ZSk7XG5cbiAgICAgICAgaWYgKGVzYyAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghaWRlbnRpZmllckNoZWNrKGVzYykpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkVzY2FwZWRDaGFyTm90QW5JZGVudGlmaWVyLCB7XG4gICAgICAgICAgICAgIGF0OiBlc2NTdGFydFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd29yZCArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmQgKyB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgfVxuXG4gIHJlYWRXb3JkKGZpcnN0Q29kZSkge1xuICAgIGNvbnN0IHdvcmQgPSB0aGlzLnJlYWRXb3JkMShmaXJzdENvZGUpO1xuICAgIGNvbnN0IHR5cGUgPSBrZXl3b3JkcyQxLmdldCh3b3JkKTtcblxuICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgdG9rZW5MYWJlbE5hbWUodHlwZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDEyOCwgd29yZCk7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tLZXl3b3JkRXNjYXBlcygpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBpZiAodG9rZW5Jc0tleXdvcmQodHlwZSkgJiYgdGhpcy5zdGF0ZS5jb250YWluc0VzYykge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2MsXG4gICAgICAgIHJlc2VydmVkV29yZDogdG9rZW5MYWJlbE5hbWUodHlwZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJhaXNlKHRvUGFyc2VFcnJvciwgcmFpc2VQcm9wZXJ0aWVzKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXRcbiAgICB9ID0gcmFpc2VQcm9wZXJ0aWVzLFxuICAgICAgICAgIGRldGFpbHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShyYWlzZVByb3BlcnRpZXMsIF9leGNsdWRlZCk7XG5cbiAgICBjb25zdCBsb2MgPSBhdCBpbnN0YW5jZW9mIFBvc2l0aW9uID8gYXQgOiBhdC5sb2Muc3RhcnQ7XG4gICAgY29uc3QgZXJyb3IgPSB0b1BhcnNlRXJyb3Ioe1xuICAgICAgbG9jLFxuICAgICAgZGV0YWlsc1xuICAgIH0pO1xuICAgIGlmICghdGhpcy5vcHRpb25zLmVycm9yUmVjb3ZlcnkpIHRocm93IGVycm9yO1xuICAgIGlmICghdGhpcy5pc0xvb2thaGVhZCkgdGhpcy5zdGF0ZS5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgcmFpc2VPdmVyd3JpdGUodG9QYXJzZUVycm9yLCByYWlzZVByb3BlcnRpZXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdFxuICAgIH0gPSByYWlzZVByb3BlcnRpZXMsXG4gICAgICAgICAgZGV0YWlscyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHJhaXNlUHJvcGVydGllcywgX2V4Y2x1ZGVkMik7XG5cbiAgICBjb25zdCBsb2MgPSBhdCBpbnN0YW5jZW9mIFBvc2l0aW9uID8gYXQgOiBhdC5sb2Muc3RhcnQ7XG4gICAgY29uc3QgcG9zID0gbG9jLmluZGV4O1xuICAgIGNvbnN0IGVycm9ycyA9IHRoaXMuc3RhdGUuZXJyb3JzO1xuXG4gICAgZm9yIChsZXQgaSA9IGVycm9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgZXJyb3IgPSBlcnJvcnNbaV07XG5cbiAgICAgIGlmIChlcnJvci5sb2MuaW5kZXggPT09IHBvcykge1xuICAgICAgICByZXR1cm4gZXJyb3JzW2ldID0gdG9QYXJzZUVycm9yKHtcbiAgICAgICAgICBsb2MsXG4gICAgICAgICAgZGV0YWlsc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVycm9yLmxvYy5pbmRleCA8IHBvcykgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmFpc2UodG9QYXJzZUVycm9yLCByYWlzZVByb3BlcnRpZXMpO1xuICB9XG5cbiAgdXBkYXRlQ29udGV4dChwcmV2VHlwZSkge31cblxuICB1bmV4cGVjdGVkKGxvYywgdHlwZSkge1xuICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRUb2tlbiwge1xuICAgICAgZXhwZWN0ZWQ6IHR5cGUgPyB0b2tlbkxhYmVsTmFtZSh0eXBlKSA6IG51bGwsXG4gICAgICBhdDogbG9jICE9IG51bGwgPyBsb2MgOiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgfSk7XG4gIH1cblxuICBleHBlY3RQbHVnaW4ocGx1Z2luTmFtZSwgbG9jKSB7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKHBsdWdpbk5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5NaXNzaW5nUGx1Z2luLCB7XG4gICAgICBhdDogbG9jICE9IG51bGwgPyBsb2MgOiB0aGlzLnN0YXRlLnN0YXJ0TG9jLFxuICAgICAgbWlzc2luZ1BsdWdpbjogW3BsdWdpbk5hbWVdXG4gICAgfSk7XG4gIH1cblxuICBleHBlY3RPbmVQbHVnaW4ocGx1Z2luTmFtZXMpIHtcbiAgICBpZiAoIXBsdWdpbk5hbWVzLnNvbWUobmFtZSA9PiB0aGlzLmhhc1BsdWdpbihuYW1lKSkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLk1pc3NpbmdPbmVPZlBsdWdpbnMsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2MsXG4gICAgICAgIG1pc3NpbmdQbHVnaW46IHBsdWdpbk5hbWVzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBlcnJvckJ1aWxkZXIoZXJyb3IpIHtcbiAgICByZXR1cm4gKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSA9PiB7XG4gICAgICB0aGlzLnJhaXNlKGVycm9yLCB7XG4gICAgICAgIGF0OiBidWlsZFBvc2l0aW9uKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG59XG5cbmNsYXNzIFNjb3BlIHtcbiAgY29uc3RydWN0b3IoZmxhZ3MpIHtcbiAgICB0aGlzLnZhciA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmxleGljYWwgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICB9XG5cbn1cbmNsYXNzIFNjb3BlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5Nb2R1bGUpIHtcbiAgICB0aGlzLnBhcnNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgICB0aGlzLmluTW9kdWxlID0gdm9pZCAwO1xuICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLmluTW9kdWxlID0gaW5Nb2R1bGU7XG4gIH1cblxuICBnZXQgaW5GdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlRmxhZ3MoKSAmIFNDT1BFX0ZVTkNUSU9OKSA+IDA7XG4gIH1cblxuICBnZXQgYWxsb3dTdXBlcigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZUZsYWdzKCkgJiBTQ09QRV9TVVBFUikgPiAwO1xuICB9XG5cbiAgZ2V0IGFsbG93RGlyZWN0U3VwZXIoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGVGbGFncygpICYgU0NPUEVfRElSRUNUX1NVUEVSKSA+IDA7XG4gIH1cblxuICBnZXQgaW5DbGFzcygpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZUZsYWdzKCkgJiBTQ09QRV9DTEFTUykgPiAwO1xuICB9XG5cbiAgZ2V0IGluQ2xhc3NBbmROb3RJbk5vbkFycm93RnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZmxhZ3MgPSB0aGlzLmN1cnJlbnRUaGlzU2NvcGVGbGFncygpO1xuICAgIHJldHVybiAoZmxhZ3MgJiBTQ09QRV9DTEFTUykgPiAwICYmIChmbGFncyAmIFNDT1BFX0ZVTkNUSU9OKSA9PT0gMDtcbiAgfVxuXG4gIGdldCBpblN0YXRpY0Jsb2NrKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmbGFnc1xuICAgICAgfSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcblxuICAgICAgaWYgKGZsYWdzICYgU0NPUEVfU1RBVElDX0JMT0NLKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxhZ3MgJiAoU0NPUEVfVkFSIHwgU0NPUEVfQ0xBU1MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgaW5Ob25BcnJvd0Z1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlRmxhZ3MoKSAmIFNDT1BFX0ZVTkNUSU9OKSA+IDA7XG4gIH1cblxuICBnZXQgdHJlYXRGdW5jdGlvbnNBc1ZhcigpIHtcbiAgICByZXR1cm4gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSh0aGlzLmN1cnJlbnRTY29wZSgpKTtcbiAgfVxuXG4gIGNyZWF0ZVNjb3BlKGZsYWdzKSB7XG4gICAgcmV0dXJuIG5ldyBTY29wZShmbGFncyk7XG4gIH1cblxuICBlbnRlcihmbGFncykge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wdXNoKHRoaXMuY3JlYXRlU2NvcGUoZmxhZ3MpKTtcbiAgfVxuXG4gIGV4aXQoKSB7XG4gICAgdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICB9XG5cbiAgdHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUoc2NvcGUpIHtcbiAgICByZXR1cm4gISEoc2NvcGUuZmxhZ3MgJiAoU0NPUEVfRlVOQ1RJT04gfCBTQ09QRV9TVEFUSUNfQkxPQ0spIHx8ICF0aGlzLnBhcnNlci5pbk1vZHVsZSAmJiBzY29wZS5mbGFncyAmIFNDT1BFX1BST0dSQU0pO1xuICB9XG5cbiAgZGVjbGFyZU5hbWUobmFtZSwgYmluZGluZ1R5cGUsIGxvYykge1xuICAgIGxldCBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG5cbiAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX1NDT1BFX0xFWElDQUwgfHwgYmluZGluZ1R5cGUgJiBCSU5EX1NDT1BFX0ZVTkNUSU9OKSB7XG4gICAgICB0aGlzLmNoZWNrUmVkZWNsYXJhdGlvbkluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpO1xuXG4gICAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX1NDT1BFX0ZVTkNUSU9OKSB7XG4gICAgICAgIHNjb3BlLmZ1bmN0aW9ucy5hZGQobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY29wZS5sZXhpY2FsLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJpbmRpbmdUeXBlICYgQklORF9TQ09QRV9MRVhJQ0FMKSB7XG4gICAgICAgIHRoaXMubWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJpbmRpbmdUeXBlICYgQklORF9TQ09QRV9WQVIpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICAgIHNjb3BlLnZhci5hZGQobmFtZSk7XG4gICAgICAgIHRoaXMubWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKTtcbiAgICAgICAgaWYgKHNjb3BlLmZsYWdzICYgU0NPUEVfVkFSKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJzZXIuaW5Nb2R1bGUgJiYgc2NvcGUuZmxhZ3MgJiBTQ09QRV9QUk9HUkFNKSB7XG4gICAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIG1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSkge1xuICAgIGlmICh0aGlzLnBhcnNlci5pbk1vZHVsZSAmJiBzY29wZS5mbGFncyAmIFNDT1BFX1BST0dSQU0pIHtcbiAgICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0cy5kZWxldGUobmFtZSk7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYykge1xuICAgIGlmICh0aGlzLmlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSkge1xuICAgICAgdGhpcy5wYXJzZXIucmFpc2UoRXJyb3JzLlZhclJlZGVjbGFyYXRpb24sIHtcbiAgICAgICAgYXQ6IGxvYyxcbiAgICAgICAgaWRlbnRpZmllck5hbWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKCEoYmluZGluZ1R5cGUgJiBCSU5EX0tJTkRfVkFMVUUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX1NDT1BFX0xFWElDQUwpIHtcbiAgICAgIHJldHVybiBzY29wZS5sZXhpY2FsLmhhcyhuYW1lKSB8fCBzY29wZS5mdW5jdGlvbnMuaGFzKG5hbWUpIHx8IHNjb3BlLnZhci5oYXMobmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGJpbmRpbmdUeXBlICYgQklORF9TQ09QRV9GVU5DVElPTikge1xuICAgICAgcmV0dXJuIHNjb3BlLmxleGljYWwuaGFzKG5hbWUpIHx8ICF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHNjb3BlKSAmJiBzY29wZS52YXIuaGFzKG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBzY29wZS5sZXhpY2FsLmhhcyhuYW1lKSAmJiAhKHNjb3BlLmZsYWdzICYgU0NPUEVfU0lNUExFX0NBVENIICYmIHNjb3BlLmxleGljYWwudmFsdWVzKCkubmV4dCgpLnZhbHVlID09PSBuYW1lKSB8fCAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkgJiYgc2NvcGUuZnVuY3Rpb25zLmhhcyhuYW1lKTtcbiAgfVxuXG4gIGNoZWNrTG9jYWxFeHBvcnQoaWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lXG4gICAgfSA9IGlkO1xuICAgIGNvbnN0IHRvcExldmVsU2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbMF07XG5cbiAgICBpZiAoIXRvcExldmVsU2NvcGUubGV4aWNhbC5oYXMobmFtZSkgJiYgIXRvcExldmVsU2NvcGUudmFyLmhhcyhuYW1lKSAmJiAhdG9wTGV2ZWxTY29wZS5mdW5jdGlvbnMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMuc2V0KG5hbWUsIGlkLmxvYy5zdGFydCk7XG4gICAgfVxuICB9XG5cbiAgY3VycmVudFNjb3BlKCkge1xuICAgIHJldHVybiB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgY3VycmVudFZhclNjb3BlRmxhZ3MoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZsYWdzXG4gICAgICB9ID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuXG4gICAgICBpZiAoZmxhZ3MgJiBTQ09QRV9WQVIpIHtcbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRUaGlzU2NvcGVGbGFncygpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmxhZ3NcbiAgICAgIH0gPSB0aGlzLnNjb3BlU3RhY2tbaV07XG5cbiAgICAgIGlmIChmbGFncyAmIChTQ09QRV9WQVIgfCBTQ09QRV9DTEFTUykgJiYgIShmbGFncyAmIFNDT1BFX0FSUk9XKSkge1xuICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgRmxvd1Njb3BlIGV4dGVuZHMgU2NvcGUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5kZWNsYXJlRnVuY3Rpb25zID0gbmV3IFNldCgpO1xuICB9XG5cbn1cblxuY2xhc3MgRmxvd1Njb3BlSGFuZGxlciBleHRlbmRzIFNjb3BlSGFuZGxlciB7XG4gIGNyZWF0ZVNjb3BlKGZsYWdzKSB7XG4gICAgcmV0dXJuIG5ldyBGbG93U2NvcGUoZmxhZ3MpO1xuICB9XG5cbiAgZGVjbGFyZU5hbWUobmFtZSwgYmluZGluZ1R5cGUsIGxvYykge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcblxuICAgIGlmIChiaW5kaW5nVHlwZSAmIEJJTkRfRkxBR1NfRkxPV19ERUNMQVJFX0ZOKSB7XG4gICAgICB0aGlzLmNoZWNrUmVkZWNsYXJhdGlvbkluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpO1xuICAgICAgdGhpcy5tYXliZUV4cG9ydERlZmluZWQoc2NvcGUsIG5hbWUpO1xuICAgICAgc2NvcGUuZGVjbGFyZUZ1bmN0aW9ucy5hZGQobmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3VwZXIuZGVjbGFyZU5hbWUobmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gIH1cblxuICBpc1JlZGVjbGFyZWRJblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSkge1xuICAgIGlmIChzdXBlci5pc1JlZGVjbGFyZWRJblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSkpIHJldHVybiB0cnVlO1xuXG4gICAgaWYgKGJpbmRpbmdUeXBlICYgQklORF9GTEFHU19GTE9XX0RFQ0xBUkVfRk4pIHtcbiAgICAgIHJldHVybiAhc2NvcGUuZGVjbGFyZUZ1bmN0aW9ucy5oYXMobmFtZSkgJiYgKHNjb3BlLmxleGljYWwuaGFzKG5hbWUpIHx8IHNjb3BlLmZ1bmN0aW9ucy5oYXMobmFtZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNoZWNrTG9jYWxFeHBvcnQoaWQpIHtcbiAgICBpZiAoIXRoaXMuc2NvcGVTdGFja1swXS5kZWNsYXJlRnVuY3Rpb25zLmhhcyhpZC5uYW1lKSkge1xuICAgICAgc3VwZXIuY2hlY2tMb2NhbEV4cG9ydChpZCk7XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgQ2xhc3NTY29wZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJpdmF0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMubG9uZUFjY2Vzc29ycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVuZGVmaW5lZFByaXZhdGVOYW1lcyA9IG5ldyBNYXAoKTtcbiAgfVxuXG59XG5jbGFzcyBDbGFzc1Njb3BlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLnVuZGVmaW5lZFByaXZhdGVOYW1lcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuXG4gIGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGVudGVyKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaChuZXcgQ2xhc3NTY29wZSgpKTtcbiAgfVxuXG4gIGV4aXQoKSB7XG4gICAgY29uc3Qgb2xkQ2xhc3NTY29wZSA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudCgpO1xuXG4gICAgZm9yIChjb25zdCBbbmFtZSwgbG9jXSBvZiBBcnJheS5mcm9tKG9sZENsYXNzU2NvcGUudW5kZWZpbmVkUHJpdmF0ZU5hbWVzKSkge1xuICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50LnVuZGVmaW5lZFByaXZhdGVOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICBjdXJyZW50LnVuZGVmaW5lZFByaXZhdGVOYW1lcy5zZXQobmFtZSwgbG9jKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZXIucmFpc2UoRXJyb3JzLkludmFsaWRQcml2YXRlRmllbGRSZXNvbHV0aW9uLCB7XG4gICAgICAgICAgYXQ6IGxvYyxcbiAgICAgICAgICBpZGVudGlmaWVyTmFtZTogbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWNsYXJlUHJpdmF0ZU5hbWUobmFtZSwgZWxlbWVudFR5cGUsIGxvYykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVOYW1lcyxcbiAgICAgIGxvbmVBY2Nlc3NvcnMsXG4gICAgICB1bmRlZmluZWRQcml2YXRlTmFtZXNcbiAgICB9ID0gdGhpcy5jdXJyZW50KCk7XG4gICAgbGV0IHJlZGVmaW5lZCA9IHByaXZhdGVOYW1lcy5oYXMobmFtZSk7XG5cbiAgICBpZiAoZWxlbWVudFR5cGUgJiBDTEFTU19FTEVNRU5UX0tJTkRfQUNDRVNTT1IpIHtcbiAgICAgIGNvbnN0IGFjY2Vzc29yID0gcmVkZWZpbmVkICYmIGxvbmVBY2Nlc3NvcnMuZ2V0KG5hbWUpO1xuXG4gICAgICBpZiAoYWNjZXNzb3IpIHtcbiAgICAgICAgY29uc3Qgb2xkU3RhdGljID0gYWNjZXNzb3IgJiBDTEFTU19FTEVNRU5UX0ZMQUdfU1RBVElDO1xuICAgICAgICBjb25zdCBuZXdTdGF0aWMgPSBlbGVtZW50VHlwZSAmIENMQVNTX0VMRU1FTlRfRkxBR19TVEFUSUM7XG4gICAgICAgIGNvbnN0IG9sZEtpbmQgPSBhY2Nlc3NvciAmIENMQVNTX0VMRU1FTlRfS0lORF9BQ0NFU1NPUjtcbiAgICAgICAgY29uc3QgbmV3S2luZCA9IGVsZW1lbnRUeXBlICYgQ0xBU1NfRUxFTUVOVF9LSU5EX0FDQ0VTU09SO1xuICAgICAgICByZWRlZmluZWQgPSBvbGRLaW5kID09PSBuZXdLaW5kIHx8IG9sZFN0YXRpYyAhPT0gbmV3U3RhdGljO1xuICAgICAgICBpZiAoIXJlZGVmaW5lZCkgbG9uZUFjY2Vzc29ycy5kZWxldGUobmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKCFyZWRlZmluZWQpIHtcbiAgICAgICAgbG9uZUFjY2Vzc29ycy5zZXQobmFtZSwgZWxlbWVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWRlZmluZWQpIHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5Qcml2YXRlTmFtZVJlZGVjbGFyYXRpb24sIHtcbiAgICAgICAgYXQ6IGxvYyxcbiAgICAgICAgaWRlbnRpZmllck5hbWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGVOYW1lcy5hZGQobmFtZSk7XG4gICAgdW5kZWZpbmVkUHJpdmF0ZU5hbWVzLmRlbGV0ZShuYW1lKTtcbiAgfVxuXG4gIHVzZVByaXZhdGVOYW1lKG5hbWUsIGxvYykge1xuICAgIGxldCBjbGFzc1Njb3BlO1xuXG4gICAgZm9yIChjbGFzc1Njb3BlIG9mIHRoaXMuc3RhY2spIHtcbiAgICAgIGlmIChjbGFzc1Njb3BlLnByaXZhdGVOYW1lcy5oYXMobmFtZSkpIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2xhc3NTY29wZSkge1xuICAgICAgY2xhc3NTY29wZS51bmRlZmluZWRQcml2YXRlTmFtZXMuc2V0KG5hbWUsIGxvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5JbnZhbGlkUHJpdmF0ZUZpZWxkUmVzb2x1dGlvbiwge1xuICAgICAgICBhdDogbG9jLFxuICAgICAgICBpZGVudGlmaWVyTmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbn1cblxuY29uc3Qga0V4cHJlc3Npb24gPSAwLFxuICAgICAga01heWJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IDEsXG4gICAgICBrTWF5YmVBc3luY0Fycm93UGFyYW1ldGVyRGVjbGFyYXRpb24gPSAyLFxuICAgICAga1BhcmFtZXRlckRlY2xhcmF0aW9uID0gMztcblxuY2xhc3MgRXhwcmVzc2lvblNjb3BlIHtcbiAgY29uc3RydWN0b3IodHlwZSA9IGtFeHByZXNzaW9uKSB7XG4gICAgdGhpcy50eXBlID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cblxuICBjYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0ga01heWJlQXN5bmNBcnJvd1BhcmFtZXRlckRlY2xhcmF0aW9uIHx8IHRoaXMudHlwZSA9PT0ga01heWJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbiAgfVxuXG4gIGlzQ2VydGFpbmx5UGFyYW1ldGVyRGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0ga1BhcmFtZXRlckRlY2xhcmF0aW9uO1xuICB9XG5cbn1cblxuY2xhc3MgQXJyb3dIZWFkUGFyc2luZ1Njb3BlIGV4dGVuZHMgRXhwcmVzc2lvblNjb3BlIHtcbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHN1cGVyKHR5cGUpO1xuICAgIHRoaXMuZGVjbGFyYXRpb25FcnJvcnMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICByZWNvcmREZWNsYXJhdGlvbkVycm9yKFBhcnNpbmdFcnJvckNsYXNzLCB7XG4gICAgYXRcbiAgfSkge1xuICAgIGNvbnN0IGluZGV4ID0gYXQuaW5kZXg7XG4gICAgdGhpcy5kZWNsYXJhdGlvbkVycm9ycy5zZXQoaW5kZXgsIFtQYXJzaW5nRXJyb3JDbGFzcywgYXRdKTtcbiAgfVxuXG4gIGNsZWFyRGVjbGFyYXRpb25FcnJvcihpbmRleCkge1xuICAgIHRoaXMuZGVjbGFyYXRpb25FcnJvcnMuZGVsZXRlKGluZGV4KTtcbiAgfVxuXG4gIGl0ZXJhdGVFcnJvcnMoaXRlcmF0b3IpIHtcbiAgICB0aGlzLmRlY2xhcmF0aW9uRXJyb3JzLmZvckVhY2goaXRlcmF0b3IpO1xuICB9XG5cbn1cblxuY2xhc3MgRXhwcmVzc2lvblNjb3BlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhY2sgPSBbbmV3IEV4cHJlc3Npb25TY29wZSgpXTtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuXG4gIGVudGVyKHNjb3BlKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHNjb3BlKTtcbiAgfVxuXG4gIGV4aXQoKSB7XG4gICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgfVxuXG4gIHJlY29yZFBhcmFtZXRlckluaXRpYWxpemVyRXJyb3IodG9QYXJzZUVycm9yLCB7XG4gICAgYXQ6IG5vZGVcbiAgfSkge1xuICAgIGNvbnN0IG9yaWdpbiA9IHtcbiAgICAgIGF0OiBub2RlLmxvYy5zdGFydFxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgc3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgbGV0IHNjb3BlID0gc3RhY2tbaV07XG5cbiAgICB3aGlsZSAoIXNjb3BlLmlzQ2VydGFpbmx5UGFyYW1ldGVyRGVjbGFyYXRpb24oKSkge1xuICAgICAgaWYgKHNjb3BlLmNhbkJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICAgIHNjb3BlLnJlY29yZERlY2xhcmF0aW9uRXJyb3IodG9QYXJzZUVycm9yLCBvcmlnaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzY29wZSA9IHN0YWNrWy0taV07XG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZXIucmFpc2UodG9QYXJzZUVycm9yLCBvcmlnaW4pO1xuICB9XG5cbiAgcmVjb3JkQXJyb3dQYXJlbWV0ZXJCaW5kaW5nRXJyb3IoZXJyb3IsIHtcbiAgICBhdDogbm9kZVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzY29wZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IG9yaWdpbiA9IHtcbiAgICAgIGF0OiBub2RlLmxvYy5zdGFydFxuICAgIH07XG5cbiAgICBpZiAoc2NvcGUuaXNDZXJ0YWlubHlQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICB0aGlzLnBhcnNlci5yYWlzZShlcnJvciwgb3JpZ2luKTtcbiAgICB9IGVsc2UgaWYgKHNjb3BlLmNhbkJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICBzY29wZS5yZWNvcmREZWNsYXJhdGlvbkVycm9yKGVycm9yLCBvcmlnaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgcmVjb3JkQXN5bmNBcnJvd1BhcmFtZXRlcnNFcnJvcih7XG4gICAgYXRcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgIGxldCBzY29wZSA9IHN0YWNrW2ldO1xuXG4gICAgd2hpbGUgKHNjb3BlLmNhbkJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICBpZiAoc2NvcGUudHlwZSA9PT0ga01heWJlQXN5bmNBcnJvd1BhcmFtZXRlckRlY2xhcmF0aW9uKSB7XG4gICAgICAgIHNjb3BlLnJlY29yZERlY2xhcmF0aW9uRXJyb3IoRXJyb3JzLkF3YWl0QmluZGluZ0lkZW50aWZpZXIsIHtcbiAgICAgICAgICBhdFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2NvcGUgPSBzdGFja1stLWldO1xuICAgIH1cbiAgfVxuXG4gIHZhbGlkYXRlQXNQYXR0ZXJuKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY3VycmVudFNjb3BlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKCFjdXJyZW50U2NvcGUuY2FuQmVBcnJvd1BhcmFtZXRlckRlY2xhcmF0aW9uKCkpIHJldHVybjtcbiAgICBjdXJyZW50U2NvcGUuaXRlcmF0ZUVycm9ycygoW3RvUGFyc2VFcnJvciwgbG9jXSkgPT4ge1xuICAgICAgdGhpcy5wYXJzZXIucmFpc2UodG9QYXJzZUVycm9yLCB7XG4gICAgICAgIGF0OiBsb2NcbiAgICAgIH0pO1xuICAgICAgbGV0IGkgPSBzdGFjay5sZW5ndGggLSAyO1xuICAgICAgbGV0IHNjb3BlID0gc3RhY2tbaV07XG5cbiAgICAgIHdoaWxlIChzY29wZS5jYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSkge1xuICAgICAgICBzY29wZS5jbGVhckRlY2xhcmF0aW9uRXJyb3IobG9jLmluZGV4KTtcbiAgICAgICAgc2NvcGUgPSBzdGFja1stLWldO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn1cbmZ1bmN0aW9uIG5ld1BhcmFtZXRlckRlY2xhcmF0aW9uU2NvcGUoKSB7XG4gIHJldHVybiBuZXcgRXhwcmVzc2lvblNjb3BlKGtQYXJhbWV0ZXJEZWNsYXJhdGlvbik7XG59XG5mdW5jdGlvbiBuZXdBcnJvd0hlYWRTY29wZSgpIHtcbiAgcmV0dXJuIG5ldyBBcnJvd0hlYWRQYXJzaW5nU2NvcGUoa01heWJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbik7XG59XG5mdW5jdGlvbiBuZXdBc3luY0Fycm93U2NvcGUoKSB7XG4gIHJldHVybiBuZXcgQXJyb3dIZWFkUGFyc2luZ1Njb3BlKGtNYXliZUFzeW5jQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbik7XG59XG5mdW5jdGlvbiBuZXdFeHByZXNzaW9uU2NvcGUoKSB7XG4gIHJldHVybiBuZXcgRXhwcmVzc2lvblNjb3BlKCk7XG59XG5cbmNvbnN0IFBBUkFNID0gMGIwMDAwLFxuICAgICAgUEFSQU1fWUlFTEQgPSAwYjAwMDEsXG4gICAgICBQQVJBTV9BV0FJVCA9IDBiMDAxMCxcbiAgICAgIFBBUkFNX1JFVFVSTiA9IDBiMDEwMCxcbiAgICAgIFBBUkFNX0lOID0gMGIxMDAwO1xuY2xhc3MgUHJvZHVjdGlvblBhcmFtZXRlckhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YWNrcyA9IFtdO1xuICB9XG5cbiAgZW50ZXIoZmxhZ3MpIHtcbiAgICB0aGlzLnN0YWNrcy5wdXNoKGZsYWdzKTtcbiAgfVxuXG4gIGV4aXQoKSB7XG4gICAgdGhpcy5zdGFja3MucG9wKCk7XG4gIH1cblxuICBjdXJyZW50RmxhZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tzW3RoaXMuc3RhY2tzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZ2V0IGhhc0F3YWl0KCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50RmxhZ3MoKSAmIFBBUkFNX0FXQUlUKSA+IDA7XG4gIH1cblxuICBnZXQgaGFzWWllbGQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRGbGFncygpICYgUEFSQU1fWUlFTEQpID4gMDtcbiAgfVxuXG4gIGdldCBoYXNSZXR1cm4oKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRGbGFncygpICYgUEFSQU1fUkVUVVJOKSA+IDA7XG4gIH1cblxuICBnZXQgaGFzSW4oKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRGbGFncygpICYgUEFSQU1fSU4pID4gMDtcbiAgfVxuXG59XG5mdW5jdGlvbiBmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIGlzR2VuZXJhdG9yKSB7XG4gIHJldHVybiAoaXNBc3luYyA/IFBBUkFNX0FXQUlUIDogMCkgfCAoaXNHZW5lcmF0b3IgPyBQQVJBTV9ZSUVMRCA6IDApO1xufVxuXG5jbGFzcyBVdGlsUGFyc2VyIGV4dGVuZHMgVG9rZW5pemVyIHtcbiAgYWRkRXh0cmEobm9kZSwga2V5LCB2YWx1ZSwgZW51bWVyYWJsZSA9IHRydWUpIHtcbiAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICBjb25zdCBleHRyYSA9IG5vZGUuZXh0cmEgPSBub2RlLmV4dHJhIHx8IHt9O1xuXG4gICAgaWYgKGVudW1lcmFibGUpIHtcbiAgICAgIGV4dHJhW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4dHJhLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlzQ29udGV4dHVhbCh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnR5cGUgPT09IHRva2VuICYmICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICB9XG5cbiAgaXNVbnBhcnNlZENvbnRleHR1YWwobmFtZVN0YXJ0LCBuYW1lKSB7XG4gICAgY29uc3QgbmFtZUVuZCA9IG5hbWVTdGFydCArIG5hbWUubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMuaW5wdXQuc2xpY2UobmFtZVN0YXJ0LCBuYW1lRW5kKSA9PT0gbmFtZSkge1xuICAgICAgY29uc3QgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5hbWVFbmQpO1xuICAgICAgcmV0dXJuICEoaXNJZGVudGlmaWVyQ2hhcihuZXh0Q2gpIHx8IChuZXh0Q2ggJiAweGZjMDApID09PSAweGQ4MDApO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzTG9va2FoZWFkQ29udGV4dHVhbChuYW1lKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICByZXR1cm4gdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBuYW1lKTtcbiAgfVxuXG4gIGVhdENvbnRleHR1YWwodG9rZW4pIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwodG9rZW4pKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGV4cGVjdENvbnRleHR1YWwodG9rZW4sIHRvUGFyc2VFcnJvcikge1xuICAgIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKHRva2VuKSkge1xuICAgICAgaWYgKHRvUGFyc2VFcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UodG9QYXJzZUVycm9yLCB7XG4gICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZChudWxsLCB0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgY2FuSW5zZXJ0U2VtaWNvbG9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDEzNSkgfHwgdGhpcy5tYXRjaCg4KSB8fCB0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpO1xuICB9XG5cbiAgaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkge1xuICAgIHJldHVybiBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhdGUubGFzdFRva0VuZExvYy5pbmRleCwgdGhpcy5zdGF0ZS5zdGFydCkpO1xuICB9XG5cbiAgaGFzRm9sbG93aW5nTGluZUJyZWFrKCkge1xuICAgIHNraXBXaGl0ZVNwYWNlVG9MaW5lQnJlYWsubGFzdEluZGV4ID0gdGhpcy5zdGF0ZS5lbmQ7XG4gICAgcmV0dXJuIHNraXBXaGl0ZVNwYWNlVG9MaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0KTtcbiAgfVxuXG4gIGlzTGluZVRlcm1pbmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWF0KDEzKSB8fCB0aGlzLmNhbkluc2VydFNlbWljb2xvbigpO1xuICB9XG5cbiAgc2VtaWNvbG9uKGFsbG93QXNpID0gdHJ1ZSkge1xuICAgIGlmIChhbGxvd0FzaSA/IHRoaXMuaXNMaW5lVGVybWluYXRvcigpIDogdGhpcy5lYXQoMTMpKSByZXR1cm47XG4gICAgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ1NlbWljb2xvbiwge1xuICAgICAgYXQ6IHRoaXMuc3RhdGUubGFzdFRva0VuZExvY1xuICAgIH0pO1xuICB9XG5cbiAgZXhwZWN0KHR5cGUsIGxvYykge1xuICAgIHRoaXMuZWF0KHR5cGUpIHx8IHRoaXMudW5leHBlY3RlZChsb2MsIHR5cGUpO1xuICB9XG5cbiAgdHJ5UGFyc2UoZm4sIG9sZFN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpKSB7XG4gICAgY29uc3QgYWJvcnRTaWduYWwgPSB7XG4gICAgICBub2RlOiBudWxsXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBub2RlID0gZm4oKG5vZGUgPSBudWxsKSA9PiB7XG4gICAgICAgIGFib3J0U2lnbmFsLm5vZGUgPSBub2RlO1xuICAgICAgICB0aHJvdyBhYm9ydFNpZ25hbDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcnMubGVuZ3RoID4gb2xkU3RhdGUuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBmYWlsU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB0aGlzLnN0YXRlID0gb2xkU3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUudG9rZW5zTGVuZ3RoID0gZmFpbFN0YXRlLnRva2Vuc0xlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGVycm9yOiBmYWlsU3RhdGUuZXJyb3JzW29sZFN0YXRlLmVycm9ycy5sZW5ndGhdLFxuICAgICAgICAgIHRocm93bjogZmFsc2UsXG4gICAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB0aHJvd246IGZhbHNlLFxuICAgICAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICAgICAgZmFpbFN0YXRlOiBudWxsXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBmYWlsU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgdGhpcy5zdGF0ZSA9IG9sZFN0YXRlO1xuXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG51bGwsXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgdGhyb3duOiB0cnVlLFxuICAgICAgICAgIGFib3J0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGZhaWxTdGF0ZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3IgPT09IGFib3J0U2lnbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogYWJvcnRTaWduYWwubm9kZSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB0aHJvd246IGZhbHNlLFxuICAgICAgICAgIGFib3J0ZWQ6IHRydWUsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCBhbmRUaHJvdykge1xuICAgIGlmICghcmVmRXhwcmVzc2lvbkVycm9ycykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHNob3J0aGFuZEFzc2lnbkxvYyxcbiAgICAgIGRvdWJsZVByb3RvTG9jLFxuICAgICAgcHJpdmF0ZUtleUxvYyxcbiAgICAgIG9wdGlvbmFsUGFyYW1ldGVyc0xvY1xuICAgIH0gPSByZWZFeHByZXNzaW9uRXJyb3JzO1xuICAgIGNvbnN0IGhhc0Vycm9ycyA9ICEhc2hvcnRoYW5kQXNzaWduTG9jIHx8ICEhZG91YmxlUHJvdG9Mb2MgfHwgISFvcHRpb25hbFBhcmFtZXRlcnNMb2MgfHwgISFwcml2YXRlS2V5TG9jO1xuXG4gICAgaWYgKCFhbmRUaHJvdykge1xuICAgICAgcmV0dXJuIGhhc0Vycm9ycztcbiAgICB9XG5cbiAgICBpZiAoc2hvcnRoYW5kQXNzaWduTG9jICE9IG51bGwpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRDb3ZlckluaXRpYWxpemVkTmFtZSwge1xuICAgICAgICBhdDogc2hvcnRoYW5kQXNzaWduTG9jXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZG91YmxlUHJvdG9Mb2MgIT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlUHJvdG8sIHtcbiAgICAgICAgYXQ6IGRvdWJsZVByb3RvTG9jXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocHJpdmF0ZUtleUxvYyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkUHJpdmF0ZUZpZWxkLCB7XG4gICAgICAgIGF0OiBwcml2YXRlS2V5TG9jXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uYWxQYXJhbWV0ZXJzTG9jICE9IG51bGwpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChvcHRpb25hbFBhcmFtZXRlcnNMb2MpO1xuICAgIH1cbiAgfVxuXG4gIGlzTGl0ZXJhbFByb3BlcnR5TmFtZSgpIHtcbiAgICByZXR1cm4gdG9rZW5Jc0xpdGVyYWxQcm9wZXJ0eU5hbWUodGhpcy5zdGF0ZS50eXBlKTtcbiAgfVxuXG4gIGlzUHJpdmF0ZU5hbWUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJpdmF0ZU5hbWVcIjtcbiAgfVxuXG4gIGdldFByaXZhdGVOYW1lU1Yobm9kZSkge1xuICAgIHJldHVybiBub2RlLmlkLm5hbWU7XG4gIH1cblxuICBoYXNQcm9wZXJ0eUFzUHJpdmF0ZU5hbWUobm9kZSkge1xuICAgIHJldHVybiAobm9kZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpICYmIHRoaXMuaXNQcml2YXRlTmFtZShub2RlLnByb3BlcnR5KTtcbiAgfVxuXG4gIGlzT3B0aW9uYWxDaGFpbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiO1xuICB9XG5cbiAgaXNPYmplY3RQcm9wZXJ0eShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiO1xuICB9XG5cbiAgaXNPYmplY3RNZXRob2Qobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiT2JqZWN0TWV0aG9kXCI7XG4gIH1cblxuICBpbml0aWFsaXplU2NvcGVzKGluTW9kdWxlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIpIHtcbiAgICBjb25zdCBvbGRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscztcbiAgICB0aGlzLnN0YXRlLmxhYmVscyA9IFtdO1xuICAgIGNvbnN0IG9sZEV4cG9ydGVkSWRlbnRpZmllcnMgPSB0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnM7XG4gICAgdGhpcy5leHBvcnRlZElkZW50aWZpZXJzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG9sZEluTW9kdWxlID0gdGhpcy5pbk1vZHVsZTtcbiAgICB0aGlzLmluTW9kdWxlID0gaW5Nb2R1bGU7XG4gICAgY29uc3Qgb2xkU2NvcGUgPSB0aGlzLnNjb3BlO1xuICAgIGNvbnN0IFNjb3BlSGFuZGxlciA9IHRoaXMuZ2V0U2NvcGVIYW5kbGVyKCk7XG4gICAgdGhpcy5zY29wZSA9IG5ldyBTY29wZUhhbmRsZXIodGhpcywgaW5Nb2R1bGUpO1xuICAgIGNvbnN0IG9sZFByb2RQYXJhbSA9IHRoaXMucHJvZFBhcmFtO1xuICAgIHRoaXMucHJvZFBhcmFtID0gbmV3IFByb2R1Y3Rpb25QYXJhbWV0ZXJIYW5kbGVyKCk7XG4gICAgY29uc3Qgb2xkQ2xhc3NTY29wZSA9IHRoaXMuY2xhc3NTY29wZTtcbiAgICB0aGlzLmNsYXNzU2NvcGUgPSBuZXcgQ2xhc3NTY29wZUhhbmRsZXIodGhpcyk7XG4gICAgY29uc3Qgb2xkRXhwcmVzc2lvblNjb3BlID0gdGhpcy5leHByZXNzaW9uU2NvcGU7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUgPSBuZXcgRXhwcmVzc2lvblNjb3BlSGFuZGxlcih0aGlzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgICB0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnMgPSBvbGRFeHBvcnRlZElkZW50aWZpZXJzO1xuICAgICAgdGhpcy5pbk1vZHVsZSA9IG9sZEluTW9kdWxlO1xuICAgICAgdGhpcy5zY29wZSA9IG9sZFNjb3BlO1xuICAgICAgdGhpcy5wcm9kUGFyYW0gPSBvbGRQcm9kUGFyYW07XG4gICAgICB0aGlzLmNsYXNzU2NvcGUgPSBvbGRDbGFzc1Njb3BlO1xuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUgPSBvbGRFeHByZXNzaW9uU2NvcGU7XG4gICAgfTtcbiAgfVxuXG4gIGVudGVySW5pdGlhbFNjb3BlcygpIHtcbiAgICBsZXQgcGFyYW1GbGFncyA9IFBBUkFNO1xuXG4gICAgaWYgKHRoaXMuaW5Nb2R1bGUpIHtcbiAgICAgIHBhcmFtRmxhZ3MgfD0gUEFSQU1fQVdBSVQ7XG4gICAgfVxuXG4gICAgdGhpcy5zY29wZS5lbnRlcihTQ09QRV9QUk9HUkFNKTtcbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihwYXJhbUZsYWdzKTtcbiAgfVxuXG4gIGNoZWNrRGVzdHJ1Y3R1cmluZ1ByaXZhdGUocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXlMb2NcbiAgICB9ID0gcmVmRXhwcmVzc2lvbkVycm9ycztcblxuICAgIGlmIChwcml2YXRlS2V5TG9jICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImRlc3RydWN0dXJpbmdQcml2YXRlXCIsIHByaXZhdGVLZXlMb2MpO1xuICAgIH1cbiAgfVxuXG59XG5jbGFzcyBFeHByZXNzaW9uRXJyb3JzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zaG9ydGhhbmRBc3NpZ25Mb2MgPSBudWxsO1xuICAgIHRoaXMuZG91YmxlUHJvdG9Mb2MgPSBudWxsO1xuICAgIHRoaXMucHJpdmF0ZUtleUxvYyA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25hbFBhcmFtZXRlcnNMb2MgPSBudWxsO1xuICB9XG5cbn1cblxuY2xhc3MgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgICB0aGlzLnR5cGUgPSBcIlwiO1xuICAgIHRoaXMuc3RhcnQgPSBwb3M7XG4gICAgdGhpcy5lbmQgPSAwO1xuICAgIHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKGxvYyk7XG4gICAgaWYgKHBhcnNlciAhPSBudWxsICYmIHBhcnNlci5vcHRpb25zLnJhbmdlcykgdGhpcy5yYW5nZSA9IFtwb3MsIDBdO1xuICAgIGlmIChwYXJzZXIgIT0gbnVsbCAmJiBwYXJzZXIuZmlsZW5hbWUpIHRoaXMubG9jLmZpbGVuYW1lID0gcGFyc2VyLmZpbGVuYW1lO1xuICB9XG5cbn1cblxuY29uc3QgTm9kZVByb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlO1xue1xuICBOb2RlUHJvdG90eXBlLl9fY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgbmV3Tm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09IFwibGVhZGluZ0NvbW1lbnRzXCIgJiYga2V5ICE9PSBcInRyYWlsaW5nQ29tbWVudHNcIiAmJiBrZXkgIT09IFwiaW5uZXJDb21tZW50c1wiKSB7XG4gICAgICAgIG5ld05vZGVba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xvbmVQbGFjZWhvbGRlcihub2RlKSB7XG4gIHJldHVybiBjbG9uZUlkZW50aWZpZXIobm9kZSk7XG59XG5cbmZ1bmN0aW9uIGNsb25lSWRlbnRpZmllcihub2RlKSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICBsb2MsXG4gICAgcmFuZ2UsXG4gICAgZXh0cmEsXG4gICAgbmFtZVxuICB9ID0gbm9kZTtcbiAgY29uc3QgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShOb2RlUHJvdG90eXBlKTtcbiAgY2xvbmVkLnR5cGUgPSB0eXBlO1xuICBjbG9uZWQuc3RhcnQgPSBzdGFydDtcbiAgY2xvbmVkLmVuZCA9IGVuZDtcbiAgY2xvbmVkLmxvYyA9IGxvYztcbiAgY2xvbmVkLnJhbmdlID0gcmFuZ2U7XG4gIGNsb25lZC5leHRyYSA9IGV4dHJhO1xuICBjbG9uZWQubmFtZSA9IG5hbWU7XG5cbiAgaWYgKHR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIikge1xuICAgIGNsb25lZC5leHBlY3RlZE5vZGUgPSBub2RlLmV4cGVjdGVkTm9kZTtcbiAgfVxuXG4gIHJldHVybiBjbG9uZWQ7XG59XG5mdW5jdGlvbiBjbG9uZVN0cmluZ0xpdGVyYWwobm9kZSkge1xuICBjb25zdCB7XG4gICAgdHlwZSxcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgbG9jLFxuICAgIHJhbmdlLFxuICAgIGV4dHJhXG4gIH0gPSBub2RlO1xuXG4gIGlmICh0eXBlID09PSBcIlBsYWNlaG9sZGVyXCIpIHtcbiAgICByZXR1cm4gY2xvbmVQbGFjZWhvbGRlcihub2RlKTtcbiAgfVxuXG4gIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoTm9kZVByb3RvdHlwZSk7XG4gIGNsb25lZC50eXBlID0gdHlwZTtcbiAgY2xvbmVkLnN0YXJ0ID0gc3RhcnQ7XG4gIGNsb25lZC5lbmQgPSBlbmQ7XG4gIGNsb25lZC5sb2MgPSBsb2M7XG4gIGNsb25lZC5yYW5nZSA9IHJhbmdlO1xuXG4gIGlmIChub2RlLnJhdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvbmVkLnJhdyA9IG5vZGUucmF3O1xuICB9IGVsc2Uge1xuICAgIGNsb25lZC5leHRyYSA9IGV4dHJhO1xuICB9XG5cbiAgY2xvbmVkLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgcmV0dXJuIGNsb25lZDtcbn1cbmNsYXNzIE5vZGVVdGlscyBleHRlbmRzIFV0aWxQYXJzZXIge1xuICBzdGFydE5vZGUoKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuc3RhdGUuc3RhcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICB9XG5cbiAgc3RhcnROb2RlQXQocG9zLCBsb2MpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgcG9zLCBsb2MpO1xuICB9XG5cbiAgc3RhcnROb2RlQXROb2RlKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydE5vZGVBdCh0eXBlLnN0YXJ0LCB0eXBlLmxvYy5zdGFydCk7XG4gIH1cblxuICBmaW5pc2hOb2RlKG5vZGUsIHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgfVxuXG4gIGZpbmlzaE5vZGVBdChub2RlLCB0eXBlLCBlbmRMb2MpIHtcblxuICAgIG5vZGUudHlwZSA9IHR5cGU7XG4gICAgbm9kZS5lbmQgPSBlbmRMb2MuaW5kZXg7XG4gICAgbm9kZS5sb2MuZW5kID0gZW5kTG9jO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSBub2RlLnJhbmdlWzFdID0gZW5kTG9jLmluZGV4O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXR0YWNoQ29tbWVudCkgdGhpcy5wcm9jZXNzQ29tbWVudChub2RlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBzdGFydCwgc3RhcnRMb2MpIHtcbiAgICBub2RlLnN0YXJ0ID0gc3RhcnQ7XG4gICAgbm9kZS5sb2Muc3RhcnQgPSBzdGFydExvYztcbiAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykgbm9kZS5yYW5nZVswXSA9IHN0YXJ0O1xuICB9XG5cbiAgcmVzZXRFbmRMb2NhdGlvbihub2RlLCBlbmRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MpIHtcbiAgICBub2RlLmVuZCA9IGVuZExvYy5pbmRleDtcbiAgICBub2RlLmxvYy5lbmQgPSBlbmRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIG5vZGUucmFuZ2VbMV0gPSBlbmRMb2MuaW5kZXg7XG4gIH1cblxuICByZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShub2RlLCBsb2NhdGlvbk5vZGUpIHtcbiAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBsb2NhdGlvbk5vZGUuc3RhcnQsIGxvY2F0aW9uTm9kZS5sb2Muc3RhcnQpO1xuICB9XG5cbn1cblxuY29uc3QgcmVzZXJ2ZWRUeXBlcyA9IG5ldyBTZXQoW1wiX1wiLCBcImFueVwiLCBcImJvb2xcIiwgXCJib29sZWFuXCIsIFwiZW1wdHlcIiwgXCJleHRlbmRzXCIsIFwiZmFsc2VcIiwgXCJpbnRlcmZhY2VcIiwgXCJtaXhlZFwiLCBcIm51bGxcIiwgXCJudW1iZXJcIiwgXCJzdGF0aWNcIiwgXCJzdHJpbmdcIiwgXCJ0cnVlXCIsIFwidHlwZW9mXCIsIFwidm9pZFwiXSk7XG5jb25zdCBGbG93RXJyb3JzID0gUGFyc2VFcnJvckVudW1gZmxvd2Aoe1xuICBBbWJpZ3VvdXNDb25kaXRpb25hbEFycm93OiBcIkFtYmlndW91cyBleHByZXNzaW9uOiB3cmFwIHRoZSBhcnJvdyBmdW5jdGlvbnMgaW4gcGFyZW50aGVzZXMgdG8gZGlzYW1iaWd1YXRlLlwiLFxuICBBbWJpZ3VvdXNEZWNsYXJlTW9kdWxlS2luZDogXCJGb3VuZCBib3RoIGBkZWNsYXJlIG1vZHVsZS5leHBvcnRzYCBhbmQgYGRlY2xhcmUgZXhwb3J0YCBpbiB0aGUgc2FtZSBtb2R1bGUuIE1vZHVsZXMgY2FuIG9ubHkgaGF2ZSAxIHNpbmNlIHRoZXkgYXJlIGVpdGhlciBhbiBFUyBtb2R1bGUgb3IgdGhleSBhcmUgYSBDb21tb25KUyBtb2R1bGUuXCIsXG4gIEFzc2lnblJlc2VydmVkVHlwZTogKHtcbiAgICByZXNlcnZlZFR5cGVcbiAgfSkgPT4gYENhbm5vdCBvdmVyd3JpdGUgcmVzZXJ2ZWQgdHlwZSAke3Jlc2VydmVkVHlwZX0uYCxcbiAgRGVjbGFyZUNsYXNzRWxlbWVudDogXCJUaGUgYGRlY2xhcmVgIG1vZGlmaWVyIGNhbiBvbmx5IGFwcGVhciBvbiBjbGFzcyBmaWVsZHMuXCIsXG4gIERlY2xhcmVDbGFzc0ZpZWxkSW5pdGlhbGl6ZXI6IFwiSW5pdGlhbGl6ZXJzIGFyZSBub3QgYWxsb3dlZCBpbiBmaWVsZHMgd2l0aCB0aGUgYGRlY2xhcmVgIG1vZGlmaWVyLlwiLFxuICBEdXBsaWNhdGVEZWNsYXJlTW9kdWxlRXhwb3J0czogXCJEdXBsaWNhdGUgYGRlY2xhcmUgbW9kdWxlLmV4cG9ydHNgIHN0YXRlbWVudC5cIixcbiAgRW51bUJvb2xlYW5NZW1iZXJOb3RJbml0aWFsaXplZDogKHtcbiAgICBtZW1iZXJOYW1lLFxuICAgIGVudW1OYW1lXG4gIH0pID0+IGBCb29sZWFuIGVudW0gbWVtYmVycyBuZWVkIHRvIGJlIGluaXRpYWxpemVkLiBVc2UgZWl0aGVyIFxcYCR7bWVtYmVyTmFtZX0gPSB0cnVlLFxcYCBvciBcXGAke21lbWJlck5hbWV9ID0gZmFsc2UsXFxgIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bUR1cGxpY2F0ZU1lbWJlck5hbWU6ICh7XG4gICAgbWVtYmVyTmFtZSxcbiAgICBlbnVtTmFtZVxuICB9KSA9PiBgRW51bSBtZW1iZXIgbmFtZXMgbmVlZCB0byBiZSB1bmlxdWUsIGJ1dCB0aGUgbmFtZSBcXGAke21lbWJlck5hbWV9XFxgIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCBiZWZvcmUgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtSW5jb25zaXN0ZW50TWVtYmVyVmFsdWVzOiAoe1xuICAgIGVudW1OYW1lXG4gIH0pID0+IGBFbnVtIFxcYCR7ZW51bU5hbWV9XFxgIGhhcyBpbmNvbnNpc3RlbnQgbWVtYmVyIGluaXRpYWxpemVycy4gRWl0aGVyIHVzZSBubyBpbml0aWFsaXplcnMsIG9yIGNvbnNpc3RlbnRseSB1c2UgbGl0ZXJhbHMgKGVpdGhlciBib29sZWFucywgbnVtYmVycywgb3Igc3RyaW5ncykgZm9yIGFsbCBtZW1iZXIgaW5pdGlhbGl6ZXJzLmAsXG4gIEVudW1JbnZhbGlkRXhwbGljaXRUeXBlOiAoe1xuICAgIGludmFsaWRFbnVtVHlwZSxcbiAgICBlbnVtTmFtZVxuICB9KSA9PiBgRW51bSB0eXBlIFxcYCR7aW52YWxpZEVudW1UeXBlfVxcYCBpcyBub3QgdmFsaWQuIFVzZSBvbmUgb2YgXFxgYm9vbGVhblxcYCwgXFxgbnVtYmVyXFxgLCBcXGBzdHJpbmdcXGAsIG9yIFxcYHN5bWJvbFxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbnZhbGlkRXhwbGljaXRUeXBlVW5rbm93blN1cHBsaWVkOiAoe1xuICAgIGVudW1OYW1lXG4gIH0pID0+IGBTdXBwbGllZCBlbnVtIHR5cGUgaXMgbm90IHZhbGlkLiBVc2Ugb25lIG9mIFxcYGJvb2xlYW5cXGAsIFxcYG51bWJlclxcYCwgXFxgc3RyaW5nXFxgLCBvciBcXGBzeW1ib2xcXGAgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtSW52YWxpZE1lbWJlckluaXRpYWxpemVyUHJpbWFyeVR5cGU6ICh7XG4gICAgZW51bU5hbWUsXG4gICAgbWVtYmVyTmFtZSxcbiAgICBleHBsaWNpdFR5cGVcbiAgfSkgPT4gYEVudW0gXFxgJHtlbnVtTmFtZX1cXGAgaGFzIHR5cGUgXFxgJHtleHBsaWNpdFR5cGV9XFxgLCBzbyB0aGUgaW5pdGlhbGl6ZXIgb2YgXFxgJHttZW1iZXJOYW1lfVxcYCBuZWVkcyB0byBiZSBhICR7ZXhwbGljaXRUeXBlfSBsaXRlcmFsLmAsXG4gIEVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJTeW1ib2xUeXBlOiAoe1xuICAgIGVudW1OYW1lLFxuICAgIG1lbWJlck5hbWVcbiAgfSkgPT4gYFN5bWJvbCBlbnVtIG1lbWJlcnMgY2Fubm90IGJlIGluaXRpYWxpemVkLiBVc2UgXFxgJHttZW1iZXJOYW1lfSxcXGAgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtSW52YWxpZE1lbWJlckluaXRpYWxpemVyVW5rbm93blR5cGU6ICh7XG4gICAgZW51bU5hbWUsXG4gICAgbWVtYmVyTmFtZVxuICB9KSA9PiBgVGhlIGVudW0gbWVtYmVyIGluaXRpYWxpemVyIGZvciBcXGAke21lbWJlck5hbWV9XFxgIG5lZWRzIHRvIGJlIGEgbGl0ZXJhbCAoZWl0aGVyIGEgYm9vbGVhbiwgbnVtYmVyLCBvciBzdHJpbmcpIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bUludmFsaWRNZW1iZXJOYW1lOiAoe1xuICAgIGVudW1OYW1lLFxuICAgIG1lbWJlck5hbWUsXG4gICAgc3VnZ2VzdGlvblxuICB9KSA9PiBgRW51bSBtZW1iZXIgbmFtZXMgY2Fubm90IHN0YXJ0IHdpdGggbG93ZXJjYXNlICdhJyB0aHJvdWdoICd6Jy4gSW5zdGVhZCBvZiB1c2luZyBcXGAke21lbWJlck5hbWV9XFxgLCBjb25zaWRlciB1c2luZyBcXGAke3N1Z2dlc3Rpb259XFxgLCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1OdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZDogKHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lXG4gIH0pID0+IGBOdW1iZXIgZW51bSBtZW1iZXJzIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQsIGUuZy4gXFxgJHttZW1iZXJOYW1lfSA9IDFcXGAgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0YWlsaXplZDogKHtcbiAgICBlbnVtTmFtZVxuICB9KSA9PiBgU3RyaW5nIGVudW0gbWVtYmVycyBuZWVkIHRvIGNvbnNpc3RlbnRseSBlaXRoZXIgYWxsIHVzZSBpbml0aWFsaXplcnMsIG9yIHVzZSBubyBpbml0aWFsaXplcnMsIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgR2V0dGVyTWF5Tm90SGF2ZVRoaXNQYXJhbTogXCJBIGdldHRlciBjYW5ub3QgaGF2ZSBhIGB0aGlzYCBwYXJhbWV0ZXIuXCIsXG4gIEltcG9ydFR5cGVTaG9ydGhhbmRPbmx5SW5QdXJlSW1wb3J0OiBcIlRoZSBgdHlwZWAgYW5kIGB0eXBlb2ZgIGtleXdvcmRzIG9uIG5hbWVkIGltcG9ydHMgY2FuIG9ubHkgYmUgdXNlZCBvbiByZWd1bGFyIGBpbXBvcnRgIHN0YXRlbWVudHMuIEl0IGNhbm5vdCBiZSB1c2VkIHdpdGggYGltcG9ydCB0eXBlYCBvciBgaW1wb3J0IHR5cGVvZmAgc3RhdGVtZW50cy5cIixcbiAgSW5leGFjdEluc2lkZUV4YWN0OiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IGNhbm5vdCBhcHBlYXIgaW5zaWRlIGFuIGV4cGxpY2l0IGV4YWN0IG9iamVjdCB0eXBlLlwiLFxuICBJbmV4YWN0SW5zaWRlTm9uT2JqZWN0OiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IGNhbm5vdCBhcHBlYXIgaW4gY2xhc3Mgb3IgaW50ZXJmYWNlIGRlZmluaXRpb25zLlwiLFxuICBJbmV4YWN0VmFyaWFuY2U6IFwiRXhwbGljaXQgaW5leGFjdCBzeW50YXggY2Fubm90IGhhdmUgdmFyaWFuY2UuXCIsXG4gIEludmFsaWROb25UeXBlSW1wb3J0SW5EZWNsYXJlTW9kdWxlOiBcIkltcG9ydHMgd2l0aGluIGEgYGRlY2xhcmUgbW9kdWxlYCBib2R5IG11c3QgYWx3YXlzIGJlIGBpbXBvcnQgdHlwZWAgb3IgYGltcG9ydCB0eXBlb2ZgLlwiLFxuICBNaXNzaW5nVHlwZVBhcmFtRGVmYXVsdDogXCJUeXBlIHBhcmFtZXRlciBkZWNsYXJhdGlvbiBuZWVkcyBhIGRlZmF1bHQsIHNpbmNlIGEgcHJlY2VkaW5nIHR5cGUgcGFyYW1ldGVyIGRlY2xhcmF0aW9uIGhhcyBhIGRlZmF1bHQuXCIsXG4gIE5lc3RlZERlY2xhcmVNb2R1bGU6IFwiYGRlY2xhcmUgbW9kdWxlYCBjYW5ub3QgYmUgdXNlZCBpbnNpZGUgYW5vdGhlciBgZGVjbGFyZSBtb2R1bGVgLlwiLFxuICBOZXN0ZWRGbG93Q29tbWVudDogXCJDYW5ub3QgaGF2ZSBhIGZsb3cgY29tbWVudCBpbnNpZGUgYW5vdGhlciBmbG93IGNvbW1lbnQuXCIsXG4gIFBhdHRlcm5Jc09wdGlvbmFsOiBPYmplY3QuYXNzaWduKHtcbiAgICBtZXNzYWdlOiBcIkEgYmluZGluZyBwYXR0ZXJuIHBhcmFtZXRlciBjYW5ub3QgYmUgb3B0aW9uYWwgaW4gYW4gaW1wbGVtZW50YXRpb24gc2lnbmF0dXJlLlwiXG4gIH0sIHtcbiAgICByZWFzb25Db2RlOiBcIk9wdGlvbmFsQmluZGluZ1BhdHRlcm5cIlxuICB9KSxcbiAgU2V0dGVyTWF5Tm90SGF2ZVRoaXNQYXJhbTogXCJBIHNldHRlciBjYW5ub3QgaGF2ZSBhIGB0aGlzYCBwYXJhbWV0ZXIuXCIsXG4gIFNwcmVhZFZhcmlhbmNlOiBcIlNwcmVhZCBwcm9wZXJ0aWVzIGNhbm5vdCBoYXZlIHZhcmlhbmNlLlwiLFxuICBUaGlzUGFyYW1Bbm5vdGF0aW9uUmVxdWlyZWQ6IFwiQSB0eXBlIGFubm90YXRpb24gaXMgcmVxdWlyZWQgZm9yIHRoZSBgdGhpc2AgcGFyYW1ldGVyLlwiLFxuICBUaGlzUGFyYW1CYW5uZWRJbkNvbnN0cnVjdG9yOiBcIkNvbnN0cnVjdG9ycyBjYW5ub3QgaGF2ZSBhIGB0aGlzYCBwYXJhbWV0ZXI7IGNvbnN0cnVjdG9ycyBkb24ndCBiaW5kIGB0aGlzYCBsaWtlIG90aGVyIGZ1bmN0aW9ucy5cIixcbiAgVGhpc1BhcmFtTWF5Tm90QmVPcHRpb25hbDogXCJUaGUgYHRoaXNgIHBhcmFtZXRlciBjYW5ub3QgYmUgb3B0aW9uYWwuXCIsXG4gIFRoaXNQYXJhbU11c3RCZUZpcnN0OiBcIlRoZSBgdGhpc2AgcGFyYW1ldGVyIG11c3QgYmUgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhcmFtZXRlci5cIixcbiAgVGhpc1BhcmFtTm9EZWZhdWx0OiBcIlRoZSBgdGhpc2AgcGFyYW1ldGVyIG1heSBub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWUuXCIsXG4gIFR5cGVCZWZvcmVJbml0aWFsaXplcjogXCJUeXBlIGFubm90YXRpb25zIG11c3QgY29tZSBiZWZvcmUgZGVmYXVsdCBhc3NpZ25tZW50cywgZS5nLiBpbnN0ZWFkIG9mIGBhZ2UgPSAyNTogbnVtYmVyYCB1c2UgYGFnZTogbnVtYmVyID0gMjVgLlwiLFxuICBUeXBlQ2FzdEluUGF0dGVybjogXCJUaGUgdHlwZSBjYXN0IGV4cHJlc3Npb24gaXMgZXhwZWN0ZWQgdG8gYmUgd3JhcHBlZCB3aXRoIHBhcmVudGhlc2lzLlwiLFxuICBVbmV4cGVjdGVkRXhwbGljaXRJbmV4YWN0SW5PYmplY3Q6IFwiRXhwbGljaXQgaW5leGFjdCBzeW50YXggbXVzdCBhcHBlYXIgYXQgdGhlIGVuZCBvZiBhbiBpbmV4YWN0IG9iamVjdC5cIixcbiAgVW5leHBlY3RlZFJlc2VydmVkVHlwZTogKHtcbiAgICByZXNlcnZlZFR5cGVcbiAgfSkgPT4gYFVuZXhwZWN0ZWQgcmVzZXJ2ZWQgdHlwZSAke3Jlc2VydmVkVHlwZX0uYCxcbiAgVW5leHBlY3RlZFJlc2VydmVkVW5kZXJzY29yZTogXCJgX2AgaXMgb25seSBhbGxvd2VkIGFzIGEgdHlwZSBhcmd1bWVudCB0byBjYWxsIG9yIG5ldy5cIixcbiAgVW5leHBlY3RlZFNwYWNlQmV0d2Vlbk1vZHVsb0NoZWNrczogXCJTcGFjZXMgYmV0d2VlbiBgJWAgYW5kIGBjaGVja3NgIGFyZSBub3QgYWxsb3dlZCBoZXJlLlwiLFxuICBVbmV4cGVjdGVkU3ByZWFkVHlwZTogXCJTcHJlYWQgb3BlcmF0b3IgY2Fubm90IGFwcGVhciBpbiBjbGFzcyBvciBpbnRlcmZhY2UgZGVmaW5pdGlvbnMuXCIsXG4gIFVuZXhwZWN0ZWRTdWJ0cmFjdGlvbk9wZXJhbmQ6ICdVbmV4cGVjdGVkIHRva2VuLCBleHBlY3RlZCBcIm51bWJlclwiIG9yIFwiYmlnaW50XCIuJyxcbiAgVW5leHBlY3RlZFRva2VuQWZ0ZXJUeXBlUGFyYW1ldGVyOiBcIkV4cGVjdGVkIGFuIGFycm93IGZ1bmN0aW9uIGFmdGVyIHRoaXMgdHlwZSBwYXJhbWV0ZXIgZGVjbGFyYXRpb24uXCIsXG4gIFVuZXhwZWN0ZWRUeXBlUGFyYW1ldGVyQmVmb3JlQXN5bmNBcnJvd0Z1bmN0aW9uOiBcIlR5cGUgcGFyYW1ldGVycyBtdXN0IGNvbWUgYWZ0ZXIgdGhlIGFzeW5jIGtleXdvcmQsIGUuZy4gaW5zdGVhZCBvZiBgPFQ+IGFzeW5jICgpID0+IHt9YCwgdXNlIGBhc3luYyA8VD4oKSA9PiB7fWAuXCIsXG4gIFVuc3VwcG9ydGVkRGVjbGFyZUV4cG9ydEtpbmQ6ICh7XG4gICAgdW5zdXBwb3J0ZWRFeHBvcnRLaW5kLFxuICAgIHN1Z2dlc3Rpb25cbiAgfSkgPT4gYFxcYGRlY2xhcmUgZXhwb3J0ICR7dW5zdXBwb3J0ZWRFeHBvcnRLaW5kfVxcYCBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgXFxgJHtzdWdnZXN0aW9ufVxcYCBpbnN0ZWFkLmAsXG4gIFVuc3VwcG9ydGVkU3RhdGVtZW50SW5EZWNsYXJlTW9kdWxlOiBcIk9ubHkgZGVjbGFyZXMgYW5kIHR5cGUgaW1wb3J0cyBhcmUgYWxsb3dlZCBpbnNpZGUgZGVjbGFyZSBtb2R1bGUuXCIsXG4gIFVudGVybWluYXRlZEZsb3dDb21tZW50OiBcIlVudGVybWluYXRlZCBmbG93LWNvbW1lbnQuXCJcbn0pO1xuXG5mdW5jdGlvbiBpc0VzTW9kdWxlVHlwZShib2R5RWxlbWVudCkge1xuICByZXR1cm4gYm9keUVsZW1lbnQudHlwZSA9PT0gXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIiB8fCBib2R5RWxlbWVudC50eXBlID09PSBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiICYmICghYm9keUVsZW1lbnQuZGVjbGFyYXRpb24gfHwgYm9keUVsZW1lbnQuZGVjbGFyYXRpb24udHlwZSAhPT0gXCJUeXBlQWxpYXNcIiAmJiBib2R5RWxlbWVudC5kZWNsYXJhdGlvbi50eXBlICE9PSBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpO1xufVxuXG5mdW5jdGlvbiBoYXNUeXBlSW1wb3J0S2luZChub2RlKSB7XG4gIHJldHVybiBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIjtcbn1cblxuZnVuY3Rpb24gaXNNYXliZURlZmF1bHRJbXBvcnQodHlwZSkge1xuICByZXR1cm4gdG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodHlwZSkgJiYgdHlwZSAhPT0gOTc7XG59XG5cbmNvbnN0IGV4cG9ydFN1Z2dlc3Rpb25zID0ge1xuICBjb25zdDogXCJkZWNsYXJlIGV4cG9ydCB2YXJcIixcbiAgbGV0OiBcImRlY2xhcmUgZXhwb3J0IHZhclwiLFxuICB0eXBlOiBcImV4cG9ydCB0eXBlXCIsXG4gIGludGVyZmFjZTogXCJleHBvcnQgaW50ZXJmYWNlXCJcbn07XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbihsaXN0LCB0ZXN0KSB7XG4gIGNvbnN0IGxpc3QxID0gW107XG4gIGNvbnN0IGxpc3QyID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgKHRlc3QobGlzdFtpXSwgaSwgbGlzdCkgPyBsaXN0MSA6IGxpc3QyKS5wdXNoKGxpc3RbaV0pO1xuICB9XG5cbiAgcmV0dXJuIFtsaXN0MSwgbGlzdDJdO1xufVxuXG5jb25zdCBGTE9XX1BSQUdNQV9SRUdFWCA9IC9cXCo/XFxzKkAoKD86bm8pP2Zsb3cpXFxiLztcbnZhciBmbG93ID0gKHN1cGVyQ2xhc3MgPT4gY2xhc3MgRmxvd1BhcnNlck1peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmZsb3dQcmFnbWEgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXRTY29wZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIEZsb3dTY29wZUhhbmRsZXI7XG4gIH1cblxuICBzaG91bGRQYXJzZVR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBsdWdpbk9wdGlvbihcImZsb3dcIiwgXCJhbGxcIikgfHwgdGhpcy5mbG93UHJhZ21hID09PSBcImZsb3dcIjtcbiAgfVxuXG4gIHNob3VsZFBhcnNlRW51bXMoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJmbG93XCIsIFwiZW51bXNcIik7XG4gIH1cblxuICBmaW5pc2hUb2tlbih0eXBlLCB2YWwpIHtcbiAgICBpZiAodHlwZSAhPT0gMTI5ICYmIHR5cGUgIT09IDEzICYmIHR5cGUgIT09IDI4KSB7XG4gICAgICBpZiAodGhpcy5mbG93UHJhZ21hID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5mbG93UHJhZ21hID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuZmluaXNoVG9rZW4odHlwZSwgdmFsKTtcbiAgfVxuXG4gIGFkZENvbW1lbnQoY29tbWVudCkge1xuICAgIGlmICh0aGlzLmZsb3dQcmFnbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IEZMT1dfUFJBR01BX1JFR0VYLmV4ZWMoY29tbWVudC52YWx1ZSk7XG5cbiAgICAgIGlmICghbWF0Y2hlcykgOyBlbHNlIGlmIChtYXRjaGVzWzFdID09PSBcImZsb3dcIikge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBcImZsb3dcIjtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hlc1sxXSA9PT0gXCJub2Zsb3dcIikge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBcIm5vZmxvd1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBmbG93IHByYWdtYVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuYWRkQ29tbWVudChjb21tZW50KTtcbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcih0b2spIHtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QodG9rIHx8IDE0KTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBmbG93UGFyc2VQcmVkaWNhdGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgbW9kdWxvTG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTA3KTtcblxuICAgIGlmICh0aGlzLnN0YXRlLmxhc3RUb2tTdGFydCA+IG1vZHVsb0xvYy5pbmRleCArIDEpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3BhY2VCZXR3ZWVuTW9kdWxvQ2hlY2tzLCB7XG4gICAgICAgIGF0OiBtb2R1bG9Mb2NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVhdCgxMCkpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBzdXBlci5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlZFByZWRpY2F0ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkluZmVycmVkUHJlZGljYXRlXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVBbmRQcmVkaWNhdGVJbml0aWFsaXNlcigpIHtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QoMTQpO1xuICAgIGxldCB0eXBlID0gbnVsbDtcbiAgICBsZXQgcHJlZGljYXRlID0gbnVsbDtcblxuICAgIGlmICh0aGlzLm1hdGNoKDU0KSkge1xuICAgICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgICBwcmVkaWNhdGUgPSB0aGlzLmZsb3dQYXJzZVByZWRpY2F0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcblxuICAgICAgaWYgKHRoaXMubWF0Y2goNTQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHRoaXMuZmxvd1BhcnNlUHJlZGljYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFt0eXBlLCBwcmVkaWNhdGVdO1xuICB9XG5cbiAgZmxvd1BhcnNlRGVjbGFyZUNsYXNzKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUNsYXNzXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlRGVjbGFyZUZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBpZCA9IG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIGNvbnN0IHR5cGVOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCB0eXBlQ29udGFpbmVyID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgdHlwZU5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlTm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIGNvbnN0IHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgdHlwZU5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICB0eXBlTm9kZS5yZXN0ID0gdG1wLnJlc3Q7XG4gICAgdHlwZU5vZGUudGhpcyA9IHRtcC5fdGhpcztcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgW3R5cGVOb2RlLnJldHVyblR5cGUsIG5vZGUucHJlZGljYXRlXSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCk7XG4gICAgdHlwZUNvbnRhaW5lci50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmluaXNoTm9kZSh0eXBlTm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICAgIGlkLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKHR5cGVDb250YWluZXIsIFwiVHlwZUFubm90YXRpb25cIik7XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGlkKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCBCSU5EX0ZMT1dfREVDTEFSRV9GTiwgbm9kZS5pZC5sb2Muc3RhcnQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlRnVuY3Rpb25cIik7XG4gIH1cblxuICBmbG93UGFyc2VEZWNsYXJlKG5vZGUsIGluc2lkZU1vZHVsZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDgwKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUNsYXNzKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCg2OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVGdW5jdGlvbihub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goNzQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlVmFyaWFibGUobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdENvbnRleHR1YWwoMTIzKSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTYpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVNb2R1bGVFeHBvcnRzKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluc2lkZU1vZHVsZSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5OZXN0ZWREZWNsYXJlTW9kdWxlLCB7XG4gICAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVNb2R1bGUobm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjYpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlVHlwZUFsaWFzKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI3KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZU9wYXF1ZVR5cGUobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlSW50ZXJmYWNlKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCg4MikpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihub2RlLCBpbnNpZGVNb2R1bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cblxuICBmbG93UGFyc2VEZWNsYXJlVmFyaWFibGUobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsIEJJTkRfVkFSLCBub2RlLmlkLmxvYy5zdGFydCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZVZhcmlhYmxlXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlRGVjbGFyZU1vZHVsZShub2RlKSB7XG4gICAgdGhpcy5zY29wZS5lbnRlcihTQ09QRV9PVEhFUik7XG5cbiAgICBpZiAodGhpcy5tYXRjaCgxMjkpKSB7XG4gICAgICBub2RlLmlkID0gc3VwZXIucGFyc2VFeHByQXRvbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5Tm9kZSA9IG5vZGUuYm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgYm9keSA9IGJvZHlOb2RlLmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcblxuICAgIHdoaWxlICghdGhpcy5tYXRjaCg4KSkge1xuICAgICAgbGV0IGJvZHlOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgICAgaWYgKHRoaXMubWF0Y2goODMpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoMTI2KSAmJiAhdGhpcy5tYXRjaCg4NykpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuSW52YWxpZE5vblR5cGVJbXBvcnRJbkRlY2xhcmVNb2R1bGUsIHtcbiAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvY1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIucGFyc2VJbXBvcnQoYm9keU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEyMSwgRmxvd0Vycm9ycy5VbnN1cHBvcnRlZFN0YXRlbWVudEluRGVjbGFyZU1vZHVsZSk7XG4gICAgICAgIGJvZHlOb2RlID0gdGhpcy5mbG93UGFyc2VEZWNsYXJlKGJvZHlOb2RlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgYm9keS5wdXNoKGJvZHlOb2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICB0aGlzLmZpbmlzaE5vZGUoYm9keU5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIik7XG4gICAgbGV0IGtpbmQgPSBudWxsO1xuICAgIGxldCBoYXNNb2R1bGVFeHBvcnQgPSBmYWxzZTtcbiAgICBib2R5LmZvckVhY2goYm9keUVsZW1lbnQgPT4ge1xuICAgICAgaWYgKGlzRXNNb2R1bGVUeXBlKGJvZHlFbGVtZW50KSkge1xuICAgICAgICBpZiAoa2luZCA9PT0gXCJDb21tb25KU1wiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkFtYmlndW91c0RlY2xhcmVNb2R1bGVLaW5kLCB7XG4gICAgICAgICAgICBhdDogYm9keUVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtpbmQgPSBcIkVTXCI7XG4gICAgICB9IGVsc2UgaWYgKGJvZHlFbGVtZW50LnR5cGUgPT09IFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIikge1xuICAgICAgICBpZiAoaGFzTW9kdWxlRXhwb3J0KSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkR1cGxpY2F0ZURlY2xhcmVNb2R1bGVFeHBvcnRzLCB7XG4gICAgICAgICAgICBhdDogYm9keUVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChraW5kID09PSBcIkVTXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuQW1iaWd1b3VzRGVjbGFyZU1vZHVsZUtpbmQsIHtcbiAgICAgICAgICAgIGF0OiBib2R5RWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAga2luZCA9IFwiQ29tbW9uSlNcIjtcbiAgICAgICAgaGFzTW9kdWxlRXhwb3J0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBub2RlLmtpbmQgPSBraW5kIHx8IFwiQ29tbW9uSlNcIjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZU1vZHVsZVwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZURlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihub2RlLCBpbnNpZGVNb2R1bGUpIHtcbiAgICB0aGlzLmV4cGVjdCg4Mik7XG5cbiAgICBpZiAodGhpcy5lYXQoNjUpKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg2OCkgfHwgdGhpcy5tYXRjaCg4MCkpIHtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMuZmxvd1BhcnNlRGVjbGFyZSh0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5kZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDc1KSB8fCB0aGlzLmlzTGV0KCkgfHwgKHRoaXMuaXNDb250ZXh0dWFsKDEyNikgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTI1KSkgJiYgIWluc2lkZU1vZHVsZSkge1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbnN1cHBvcnRlZERlY2xhcmVFeHBvcnRLaW5kLCB7XG4gICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2MsXG4gICAgICAgICAgdW5zdXBwb3J0ZWRFeHBvcnRLaW5kOiBsYWJlbCxcbiAgICAgICAgICBzdWdnZXN0aW9uOiBleHBvcnRTdWdnZXN0aW9uc1tsYWJlbF1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1hdGNoKDc0KSB8fCB0aGlzLm1hdGNoKDY4KSB8fCB0aGlzLm1hdGNoKDgwKSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMjcpKSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLmZsb3dQYXJzZURlY2xhcmUodGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICAgIG5vZGUuZGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDU1KSB8fCB0aGlzLm1hdGNoKDUpIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEyNSkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTI2KSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMjcpKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLnBhcnNlRXhwb3J0KG5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgbm9kZS50eXBlID0gXCJFeHBvcnREZWNsYXJhdGlvblwiO1xuICAgICAgICAgIG5vZGUuZGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgIGRlbGV0ZSBub2RlLmV4cG9ydEtpbmQ7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnR5cGUgPSBcIkRlY2xhcmVcIiArIG5vZGUudHlwZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cblxuICBmbG93UGFyc2VEZWNsYXJlTW9kdWxlRXhwb3J0cyhub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEwOCk7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZURlY2xhcmVUeXBlQWxpYXMobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IGZpbmlzaGVkID0gdGhpcy5mbG93UGFyc2VUeXBlQWxpYXMobm9kZSk7XG4gICAgZmluaXNoZWQudHlwZSA9IFwiRGVjbGFyZVR5cGVBbGlhc1wiO1xuICAgIHJldHVybiBmaW5pc2hlZDtcbiAgfVxuXG4gIGZsb3dQYXJzZURlY2xhcmVPcGFxdWVUeXBlKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBmaW5pc2hlZCA9IHRoaXMuZmxvd1BhcnNlT3BhcXVlVHlwZShub2RlLCB0cnVlKTtcbiAgICBmaW5pc2hlZC50eXBlID0gXCJEZWNsYXJlT3BhcXVlVHlwZVwiO1xuICAgIHJldHVybiBmaW5pc2hlZDtcbiAgfVxuXG4gIGZsb3dQYXJzZURlY2xhcmVJbnRlcmZhY2Uobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlaXNoKG5vZGUpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlSW50ZXJmYWNlXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlSW50ZXJmYWNlaXNoKG5vZGUsIGlzQ2xhc3MgPSBmYWxzZSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCFpc0NsYXNzLCB0cnVlKTtcbiAgICB0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKG5vZGUuaWQubmFtZSwgaXNDbGFzcyA/IEJJTkRfRlVOQ1RJT04gOiBCSU5EX0xFWElDQUwsIG5vZGUuaWQubG9jLnN0YXJ0KTtcblxuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cblxuICAgIG5vZGUuZXh0ZW5kcyA9IFtdO1xuICAgIG5vZGUuaW1wbGVtZW50cyA9IFtdO1xuICAgIG5vZGUubWl4aW5zID0gW107XG5cbiAgICBpZiAodGhpcy5lYXQoODEpKSB7XG4gICAgICBkbyB7XG4gICAgICAgIG5vZGUuZXh0ZW5kcy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpKTtcbiAgICAgIH0gd2hpbGUgKCFpc0NsYXNzICYmIHRoaXMuZWF0KDEyKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDExNCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICBkbyB7XG4gICAgICAgIG5vZGUubWl4aW5zLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgICAgfSB3aGlsZSAodGhpcy5lYXQoMTIpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTEwKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbm9kZS5pbXBsZW1lbnRzLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgICAgfSB3aGlsZSAodGhpcy5lYXQoMTIpKTtcbiAgICB9XG5cbiAgICBub2RlLmJvZHkgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGUoe1xuICAgICAgYWxsb3dTdGF0aWM6IGlzQ2xhc3MsXG4gICAgICBhbGxvd0V4YWN0OiBmYWxzZSxcbiAgICAgIGFsbG93U3ByZWFkOiBmYWxzZSxcbiAgICAgIGFsbG93UHJvdG86IGlzQ2xhc3MsXG4gICAgICBhbGxvd0luZXhhY3Q6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICBmbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyKCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcmZhY2VFeHRlbmRzXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlSW50ZXJmYWNlKG5vZGUpIHtcbiAgICB0aGlzLmZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG4gIH1cblxuICBjaGVja05vdFVuZGVyc2NvcmUod29yZCkge1xuICAgIGlmICh3b3JkID09PSBcIl9cIikge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVuZXhwZWN0ZWRSZXNlcnZlZFVuZGVyc2NvcmUsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrUmVzZXJ2ZWRUeXBlKHdvcmQsIHN0YXJ0TG9jLCBkZWNsYXJhdGlvbikge1xuICAgIGlmICghcmVzZXJ2ZWRUeXBlcy5oYXMod29yZCkpIHJldHVybjtcbiAgICB0aGlzLnJhaXNlKGRlY2xhcmF0aW9uID8gRmxvd0Vycm9ycy5Bc3NpZ25SZXNlcnZlZFR5cGUgOiBGbG93RXJyb3JzLlVuZXhwZWN0ZWRSZXNlcnZlZFR5cGUsIHtcbiAgICAgIGF0OiBzdGFydExvYyxcbiAgICAgIHJlc2VydmVkVHlwZTogd29yZFxuICAgIH0pO1xuICB9XG5cbiAgZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIobGliZXJhbCwgZGVjbGFyYXRpb24pIHtcbiAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRUeXBlKHRoaXMuc3RhdGUudmFsdWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIGRlY2xhcmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIobGliZXJhbCk7XG4gIH1cblxuICBmbG93UGFyc2VUeXBlQWxpYXMobm9kZSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKG5vZGUuaWQubmFtZSwgQklORF9MRVhJQ0FMLCBub2RlLmlkLmxvYy5zdGFydCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICB9XG5cbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoMjkpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVBbGlhc1wiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZU9wYXF1ZVR5cGUobm9kZSwgZGVjbGFyZSkge1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMjYpO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUsIHRydWUpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCBCSU5EX0xFWElDQUwsIG5vZGUuaWQubG9jLnN0YXJ0KTtcblxuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cblxuICAgIG5vZGUuc3VwZXJ0eXBlID0gbnVsbDtcblxuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgbm9kZS5zdXBlcnR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigxNCk7XG4gICAgfVxuXG4gICAgbm9kZS5pbXBsdHlwZSA9IG51bGw7XG5cbiAgICBpZiAoIWRlY2xhcmUpIHtcbiAgICAgIG5vZGUuaW1wbHR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigyOSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT3BhcXVlVHlwZVwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVQYXJhbWV0ZXIocmVxdWlyZURlZmF1bHQgPSBmYWxzZSkge1xuICAgIGNvbnN0IG5vZGVTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgdmFyaWFuY2UgPSB0aGlzLmZsb3dQYXJzZVZhcmlhbmNlKCk7XG4gICAgY29uc3QgaWRlbnQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIoKTtcbiAgICBub2RlLm5hbWUgPSBpZGVudC5uYW1lO1xuICAgIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICBub2RlLmJvdW5kID0gaWRlbnQudHlwZUFubm90YXRpb247XG5cbiAgICBpZiAodGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgIHRoaXMuZWF0KDI5KTtcbiAgICAgIG5vZGUuZGVmYXVsdCA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVxdWlyZURlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLk1pc3NpbmdUeXBlUGFyYW1EZWZhdWx0LCB7XG4gICAgICAgICAgYXQ6IG5vZGVTdGFydExvY1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlclwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpIHtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnBhcmFtcyA9IFtdO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDEzOCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICBsZXQgZGVmYXVsdFJlcXVpcmVkID0gZmFsc2U7XG5cbiAgICBkbyB7XG4gICAgICBjb25zdCB0eXBlUGFyYW1ldGVyID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyKGRlZmF1bHRSZXF1aXJlZCk7XG4gICAgICBub2RlLnBhcmFtcy5wdXNoKHR5cGVQYXJhbWV0ZXIpO1xuXG4gICAgICBpZiAodHlwZVBhcmFtZXRlci5kZWZhdWx0KSB7XG4gICAgICAgIGRlZmF1bHRSZXF1aXJlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5tYXRjaCg0OCkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCF0aGlzLm1hdGNoKDQ4KSk7XG5cbiAgICB0aGlzLmV4cGVjdCg0OCk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIG5vZGUucGFyYW1zID0gW107XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KDQ3KTtcbiAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDQ4KSkge1xuICAgICAgbm9kZS5wYXJhbXMucHVzaCh0aGlzLmZsb3dQYXJzZVR5cGUoKSk7XG5cbiAgICAgIGlmICghdGhpcy5tYXRjaCg0OCkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgIHRoaXMuZXhwZWN0KDQ4KTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIik7XG4gIH1cblxuICBmbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbkNhbGxPck5ldygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICBub2RlLnBhcmFtcyA9IFtdO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCg0Nyk7XG5cbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goNDgpKSB7XG4gICAgICBub2RlLnBhcmFtcy5wdXNoKHRoaXMuZmxvd1BhcnNlVHlwZU9ySW1wbGljaXRJbnN0YW50aWF0aW9uKCkpO1xuXG4gICAgICBpZiAoIXRoaXMubWF0Y2goNDgpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdCg0OCk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlSW50ZXJmYWNlVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTI1KTtcbiAgICBub2RlLmV4dGVuZHMgPSBbXTtcblxuICAgIGlmICh0aGlzLmVhdCg4MSkpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgbm9kZS5leHRlbmRzLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgICAgfSB3aGlsZSAodGhpcy5lYXQoMTIpKTtcbiAgICB9XG5cbiAgICBub2RlLmJvZHkgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGUoe1xuICAgICAgYWxsb3dTdGF0aWM6IGZhbHNlLFxuICAgICAgYWxsb3dFeGFjdDogZmFsc2UsXG4gICAgICBhbGxvd1NwcmVhZDogZmFsc2UsXG4gICAgICBhbGxvd1Byb3RvOiBmYWxzZSxcbiAgICAgIGFsbG93SW5leGFjdDogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIik7XG4gIH1cblxuICBmbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxMzApIHx8IHRoaXMubWF0Y2goMTI5KSA/IHN1cGVyLnBhcnNlRXhwckF0b20oKSA6IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICB9XG5cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZUluZGV4ZXIobm9kZSwgaXNTdGF0aWMsIHZhcmlhbmNlKSB7XG4gICAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcblxuICAgIGlmICh0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IDE0KSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgbm9kZS5rZXkgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgIG5vZGUua2V5ID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5leHBlY3QoMyk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gICAgbm9kZS52YXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlSW5kZXhlclwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZU9iamVjdFR5cGVJbnRlcm5hbFNsb3Qobm9kZSwgaXNTdGF0aWMpIHtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgdGhpcy5leHBlY3QoMyk7XG4gICAgdGhpcy5leHBlY3QoMyk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIG5vZGUubWV0aG9kID0gdHJ1ZTtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2godGhpcy5zdGFydE5vZGVBdChub2RlLnN0YXJ0LCBub2RlLmxvYy5zdGFydCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLm1ldGhvZCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICAgIG5vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2gobm9kZSkge1xuICAgIG5vZGUucGFyYW1zID0gW107XG4gICAgbm9kZS5yZXN0ID0gbnVsbDtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICBub2RlLnRoaXMgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdCgxMCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCg3OCkpIHtcbiAgICAgIG5vZGUudGhpcyA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0odHJ1ZSk7XG4gICAgICBub2RlLnRoaXMubmFtZSA9IG51bGw7XG5cbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdoaWxlICghdGhpcy5tYXRjaCgxMSkgJiYgIXRoaXMubWF0Y2goMjEpKSB7XG4gICAgICBub2RlLnBhcmFtcy5wdXNoKHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oZmFsc2UpKTtcblxuICAgICAgaWYgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWF0KDIxKSkge1xuICAgICAgbm9kZS5yZXN0ID0gdGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbShmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gIH1cblxuICBmbG93UGFyc2VPYmplY3RUeXBlQ2FsbFByb3BlcnR5KG5vZGUsIGlzU3RhdGljKSB7XG4gICAgY29uc3QgdmFsdWVOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2godmFsdWVOb2RlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZU9iamVjdFR5cGUoe1xuICAgIGFsbG93U3RhdGljLFxuICAgIGFsbG93RXhhY3QsXG4gICAgYWxsb3dTcHJlYWQsXG4gICAgYWxsb3dQcm90byxcbiAgICBhbGxvd0luZXhhY3RcbiAgfSkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICBjb25zdCBub2RlU3RhcnQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGVTdGFydC5jYWxsUHJvcGVydGllcyA9IFtdO1xuICAgIG5vZGVTdGFydC5wcm9wZXJ0aWVzID0gW107XG4gICAgbm9kZVN0YXJ0LmluZGV4ZXJzID0gW107XG4gICAgbm9kZVN0YXJ0LmludGVybmFsU2xvdHMgPSBbXTtcbiAgICBsZXQgZW5kRGVsaW07XG4gICAgbGV0IGV4YWN0O1xuICAgIGxldCBpbmV4YWN0ID0gZmFsc2U7XG5cbiAgICBpZiAoYWxsb3dFeGFjdCAmJiB0aGlzLm1hdGNoKDYpKSB7XG4gICAgICB0aGlzLmV4cGVjdCg2KTtcbiAgICAgIGVuZERlbGltID0gOTtcbiAgICAgIGV4YWN0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBlY3QoNSk7XG4gICAgICBlbmREZWxpbSA9IDg7XG4gICAgICBleGFjdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIG5vZGVTdGFydC5leGFjdCA9IGV4YWN0O1xuXG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKGVuZERlbGltKSkge1xuICAgICAgbGV0IGlzU3RhdGljID0gZmFsc2U7XG4gICAgICBsZXQgcHJvdG9TdGFydExvYyA9IG51bGw7XG4gICAgICBsZXQgaW5leGFjdFN0YXJ0TG9jID0gbnVsbDtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgICBpZiAoYWxsb3dQcm90byAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMTUpKSB7XG4gICAgICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSAxNCAmJiBsb29rYWhlYWQudHlwZSAhPT0gMTcpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBwcm90b1N0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgICBhbGxvd1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGxvd1N0YXRpYyAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMDQpKSB7XG4gICAgICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG5cbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSAxNCAmJiBsb29rYWhlYWQudHlwZSAhPT0gMTcpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBpc1N0YXRpYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFyaWFuY2UgPSB0aGlzLmZsb3dQYXJzZVZhcmlhbmNlKCk7XG5cbiAgICAgIGlmICh0aGlzLmVhdCgwKSkge1xuICAgICAgICBpZiAocHJvdG9TdGFydExvYyAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHByb3RvU3RhcnRMb2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZWF0KDApKSB7XG4gICAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQodmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2RlU3RhcnQuaW50ZXJuYWxTbG90cy5wdXNoKHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZUludGVybmFsU2xvdChub2RlLCBpc1N0YXRpYykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVTdGFydC5pbmRleGVycy5wdXNoKHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZUluZGV4ZXIobm9kZSwgaXNTdGF0aWMsIHZhcmlhbmNlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCgxMCkgfHwgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgICAgaWYgKHByb3RvU3RhcnRMb2MgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZChwcm90b1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YXJpYW5jZSkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZCh2YXJpYW5jZS5sb2Muc3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZVN0YXJ0LmNhbGxQcm9wZXJ0aWVzLnB1c2godGhpcy5mbG93UGFyc2VPYmplY3RUeXBlQ2FsbFByb3BlcnR5KG5vZGUsIGlzU3RhdGljKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQga2luZCA9IFwiaW5pdFwiO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5OCkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTAzKSkge1xuICAgICAgICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG5cbiAgICAgICAgICBpZiAodG9rZW5Jc0xpdGVyYWxQcm9wZXJ0eU5hbWUobG9va2FoZWFkLnR5cGUpKSB7XG4gICAgICAgICAgICBraW5kID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb3BPckluZXhhY3QgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVQcm9wZXJ0eShub2RlLCBpc1N0YXRpYywgcHJvdG9TdGFydExvYywgdmFyaWFuY2UsIGtpbmQsIGFsbG93U3ByZWFkLCBhbGxvd0luZXhhY3QgIT0gbnVsbCA/IGFsbG93SW5leGFjdCA6ICFleGFjdCk7XG5cbiAgICAgICAgaWYgKHByb3BPckluZXhhY3QgPT09IG51bGwpIHtcbiAgICAgICAgICBpbmV4YWN0ID0gdHJ1ZTtcbiAgICAgICAgICBpbmV4YWN0U3RhcnRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlU3RhcnQucHJvcGVydGllcy5wdXNoKHByb3BPckluZXhhY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmxvd09iamVjdFR5cGVTZW1pY29sb24oKTtcblxuICAgICAgaWYgKGluZXhhY3RTdGFydExvYyAmJiAhdGhpcy5tYXRjaCg4KSAmJiAhdGhpcy5tYXRjaCg5KSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5leHBlY3RlZEV4cGxpY2l0SW5leGFjdEluT2JqZWN0LCB7XG4gICAgICAgICAgYXQ6IGluZXhhY3RTdGFydExvY1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdChlbmREZWxpbSk7XG5cbiAgICBpZiAoYWxsb3dTcHJlYWQpIHtcbiAgICAgIG5vZGVTdGFydC5pbmV4YWN0ID0gaW5leGFjdDtcbiAgICB9XG5cbiAgICBjb25zdCBvdXQgPSB0aGlzLmZpbmlzaE5vZGUobm9kZVN0YXJ0LCBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIpO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBmbG93UGFyc2VPYmplY3RUeXBlUHJvcGVydHkobm9kZSwgaXNTdGF0aWMsIHByb3RvU3RhcnRMb2MsIHZhcmlhbmNlLCBraW5kLCBhbGxvd1NwcmVhZCwgYWxsb3dJbmV4YWN0KSB7XG4gICAgaWYgKHRoaXMuZWF0KDIxKSkge1xuICAgICAgY29uc3QgaXNJbmV4YWN0VG9rZW4gPSB0aGlzLm1hdGNoKDEyKSB8fCB0aGlzLm1hdGNoKDEzKSB8fCB0aGlzLm1hdGNoKDgpIHx8IHRoaXMubWF0Y2goOSk7XG5cbiAgICAgIGlmIChpc0luZXhhY3RUb2tlbikge1xuICAgICAgICBpZiAoIWFsbG93U3ByZWFkKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkluZXhhY3RJbnNpZGVOb25PYmplY3QsIHtcbiAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvY1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd0luZXhhY3QpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuSW5leGFjdEluc2lkZUV4YWN0LCB7XG4gICAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YXJpYW5jZSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbmV4YWN0VmFyaWFuY2UsIHtcbiAgICAgICAgICAgIGF0OiB2YXJpYW5jZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghYWxsb3dTcHJlYWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVuZXhwZWN0ZWRTcHJlYWRUeXBlLCB7XG4gICAgICAgICAgYXQ6IHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG9TdGFydExvYyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChwcm90b1N0YXJ0TG9jKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5TcHJlYWRWYXJpYW5jZSwge1xuICAgICAgICAgIGF0OiB2YXJpYW5jZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5rZXkgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgICAgbm9kZS5wcm90byA9IHByb3RvU3RhcnRMb2MgIT0gbnVsbDtcbiAgICAgIG5vZGUua2luZCA9IGtpbmQ7XG4gICAgICBsZXQgb3B0aW9uYWwgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goMTApKSB7XG4gICAgICAgIG5vZGUubWV0aG9kID0gdHJ1ZTtcblxuICAgICAgICBpZiAocHJvdG9TdGFydExvYyAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHByb3RvU3RhcnRMb2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHZhcmlhbmNlLmxvYy5zdGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHRoaXMuc3RhcnROb2RlQXQobm9kZS5zdGFydCwgbm9kZS5sb2Muc3RhcnQpKTtcblxuICAgICAgICBpZiAoa2luZCA9PT0gXCJnZXRcIiB8fCBraW5kID09PSBcInNldFwiKSB7XG4gICAgICAgICAgdGhpcy5mbG93Q2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFsbG93U3ByZWFkICYmIG5vZGUua2V5Lm5hbWUgPT09IFwiY29uc3RydWN0b3JcIiAmJiBub2RlLnZhbHVlLnRoaXMpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtQmFubmVkSW5Db25zdHJ1Y3Rvciwge1xuICAgICAgICAgICAgYXQ6IG5vZGUudmFsdWUudGhpc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2luZCAhPT0gXCJpbml0XCIpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICBub2RlLm1ldGhvZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgICAgICBvcHRpb25hbCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgICAgICAgbm9kZS52YXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgICAgfVxuXG4gICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZVByb3BlcnR5XCIpO1xuICAgIH1cbiAgfVxuXG4gIGZsb3dDaGVja0dldHRlclNldHRlclBhcmFtcyhwcm9wZXJ0eSkge1xuICAgIGNvbnN0IHBhcmFtQ291bnQgPSBwcm9wZXJ0eS5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgY29uc3QgbGVuZ3RoID0gcHJvcGVydHkudmFsdWUucGFyYW1zLmxlbmd0aCArIChwcm9wZXJ0eS52YWx1ZS5yZXN0ID8gMSA6IDApO1xuXG4gICAgaWYgKHByb3BlcnR5LnZhbHVlLnRoaXMpIHtcbiAgICAgIHRoaXMucmFpc2UocHJvcGVydHkua2luZCA9PT0gXCJnZXRcIiA/IEZsb3dFcnJvcnMuR2V0dGVyTWF5Tm90SGF2ZVRoaXNQYXJhbSA6IEZsb3dFcnJvcnMuU2V0dGVyTWF5Tm90SGF2ZVRoaXNQYXJhbSwge1xuICAgICAgICBhdDogcHJvcGVydHkudmFsdWUudGhpc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgdGhpcy5yYWlzZShwcm9wZXJ0eS5raW5kID09PSBcImdldFwiID8gRXJyb3JzLkJhZEdldHRlckFyaXR5IDogRXJyb3JzLkJhZFNldHRlckFyaXR5LCB7XG4gICAgICAgIGF0OiBwcm9wZXJ0eVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5LmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcGVydHkudmFsdWUucmVzdCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQmFkU2V0dGVyUmVzdFBhcmFtZXRlciwge1xuICAgICAgICBhdDogcHJvcGVydHlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZsb3dPYmplY3RUeXBlU2VtaWNvbG9uKCkge1xuICAgIGlmICghdGhpcy5lYXQoMTMpICYmICF0aGlzLmVhdCgxMikgJiYgIXRoaXMubWF0Y2goOCkgJiYgIXRoaXMubWF0Y2goOSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyKHN0YXJ0UG9zLCBzdGFydExvYywgaWQpIHtcbiAgICBzdGFydFBvcyA9IHN0YXJ0UG9zIHx8IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgc3RhcnRMb2MgPSBzdGFydExvYyB8fCB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCBub2RlID0gaWQgfHwgdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcih0cnVlKTtcblxuICAgIHdoaWxlICh0aGlzLmVhdCgxNikpIHtcbiAgICAgIGNvbnN0IG5vZGUyID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZTIucXVhbGlmaWNhdGlvbiA9IG5vZGU7XG4gICAgICBub2RlMi5pZCA9IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIodHJ1ZSk7XG4gICAgICBub2RlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUyLCBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZmxvd1BhcnNlR2VuZXJpY1R5cGUoc3RhcnRQb3MsIHN0YXJ0TG9jLCBpZCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIoc3RhcnRQb3MsIHN0YXJ0TG9jLCBpZCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVvZlR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoODcpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLmZsb3dQYXJzZVByaW1hcnlUeXBlKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlVHVwbGVUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudHlwZXMgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCgwKTtcblxuICAgIHdoaWxlICh0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoICYmICF0aGlzLm1hdGNoKDMpKSB7XG4gICAgICBub2RlLnR5cGVzLnB1c2godGhpcy5mbG93UGFyc2VUeXBlKCkpO1xuICAgICAgaWYgKHRoaXMubWF0Y2goMykpIGJyZWFrO1xuICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oZmlyc3QpIHtcbiAgICBsZXQgbmFtZSA9IG51bGw7XG4gICAgbGV0IG9wdGlvbmFsID0gZmFsc2U7XG4gICAgbGV0IHR5cGVBbm5vdGF0aW9uID0gbnVsbDtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBsaCA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgY29uc3QgaXNUaGlzID0gdGhpcy5zdGF0ZS50eXBlID09PSA3ODtcblxuICAgIGlmIChsaC50eXBlID09PSAxNCB8fCBsaC50eXBlID09PSAxNykge1xuICAgICAgaWYgKGlzVGhpcyAmJiAhZmlyc3QpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbU11c3RCZUZpcnN0LCB7XG4gICAgICAgICAgYXQ6IG5vZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIG5hbWUgPSB0aGlzLnBhcnNlSWRlbnRpZmllcihpc1RoaXMpO1xuXG4gICAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcblxuICAgICAgICBpZiAoaXNUaGlzKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbU1heU5vdEJlT3B0aW9uYWwsIHtcbiAgICAgICAgICAgIGF0OiBub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH1cblxuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgbm9kZS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlQW5ub3RhdGlvbjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlUGFyYW1cIik7XG4gIH1cblxuICByZWludGVycHJldFR5cGVBc0Z1bmN0aW9uVHlwZVBhcmFtKHR5cGUpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdCh0eXBlLnN0YXJ0LCB0eXBlLmxvYy5zdGFydCk7XG4gICAgbm9kZS5uYW1lID0gbnVsbDtcbiAgICBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZVBhcmFtXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKHBhcmFtcyA9IFtdKSB7XG4gICAgbGV0IHJlc3QgPSBudWxsO1xuICAgIGxldCBfdGhpcyA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5tYXRjaCg3OCkpIHtcbiAgICAgIF90aGlzID0gdGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbSh0cnVlKTtcbiAgICAgIF90aGlzLm5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAoIXRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goMTEpICYmICF0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgcGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbShmYWxzZSkpO1xuXG4gICAgICBpZiAoIXRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5lYXQoMjEpKSB7XG4gICAgICByZXN0ID0gdGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbShmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmFtcyxcbiAgICAgIHJlc3QsXG4gICAgICBfdGhpc1xuICAgIH07XG4gIH1cblxuICBmbG93SWRlbnRUb1R5cGVBbm5vdGF0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbm9kZSwgaWQpIHtcbiAgICBzd2l0Y2ggKGlkLm5hbWUpIHtcbiAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFueVR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSBcIm1peGVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBjYXNlIFwiZW1wdHlcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5VHlwZUFubm90YXRpb25cIik7XG5cbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ltYm9sVHlwZUFubm90YXRpb25cIik7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuY2hlY2tOb3RVbmRlcnNjb3JlKGlkLm5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VHZW5lcmljVHlwZShzdGFydFBvcywgc3RhcnRMb2MsIGlkKTtcbiAgICB9XG4gIH1cblxuICBmbG93UGFyc2VQcmltYXJ5VHlwZSgpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGxldCB0bXA7XG4gICAgbGV0IHR5cGU7XG4gICAgbGV0IGlzR3JvdXBlZFR5cGUgPSBmYWxzZTtcbiAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcblxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGUoe1xuICAgICAgICAgIGFsbG93U3RhdGljOiBmYWxzZSxcbiAgICAgICAgICBhbGxvd0V4YWN0OiBmYWxzZSxcbiAgICAgICAgICBhbGxvd1NwcmVhZDogdHJ1ZSxcbiAgICAgICAgICBhbGxvd1Byb3RvOiBmYWxzZSxcbiAgICAgICAgICBhbGxvd0luZXhhY3Q6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZSh7XG4gICAgICAgICAgYWxsb3dTdGF0aWM6IGZhbHNlLFxuICAgICAgICAgIGFsbG93RXhhY3Q6IHRydWUsXG4gICAgICAgICAgYWxsb3dTcHJlYWQ6IHRydWUsXG4gICAgICAgICAgYWxsb3dQcm90bzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dJbmV4YWN0OiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuICAgICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUdXBsZVR5cGUoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBvbGROb0Fub25GdW5jdGlvblR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICBjYXNlIDQ3OlxuICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMTApO1xuICAgICAgICB0bXAgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcygpO1xuICAgICAgICBub2RlLnBhcmFtcyA9IHRtcC5wYXJhbXM7XG4gICAgICAgIG5vZGUucmVzdCA9IHRtcC5yZXN0O1xuICAgICAgICBub2RlLnRoaXMgPSB0bXAuX3RoaXM7XG4gICAgICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMTkpO1xuICAgICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG5cbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkgJiYgIXRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkgfHwgdGhpcy5tYXRjaCg3OCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5sb29rYWhlYWQoKS50eXBlO1xuICAgICAgICAgICAgaXNHcm91cGVkVHlwZSA9IHRva2VuICE9PSAxNyAmJiB0b2tlbiAhPT0gMTQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzR3JvdXBlZFR5cGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0dyb3VwZWRUeXBlKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBmYWxzZTtcbiAgICAgICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBvbGROb0Fub25GdW5jdGlvblR5cGU7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgfHwgISh0aGlzLm1hdGNoKDEyKSB8fCB0aGlzLm1hdGNoKDExKSAmJiB0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IDE5KSkge1xuICAgICAgICAgICAgdGhpcy5leHBlY3QoMTEpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWF0KDEyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgIHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKFt0aGlzLnJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0odHlwZSldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0bXAgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5wYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgICAgICBub2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICAgICAgbm9kZS50aGlzID0gdG1wLl90aGlzO1xuICAgICAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSAxMjk6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSA4NTpcbiAgICAgIGNhc2UgODY6XG4gICAgICAgIG5vZGUudmFsdWUgPSB0aGlzLm1hdGNoKDg1KTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBjYXNlIDUzOlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCItXCIpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDEzMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbEF0Tm9kZSgtdGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMubWF0Y2goMTMxKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsQXROb2RlKC10aGlzLnN0YXRlLnZhbHVlLCBcIkJpZ0ludExpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCBub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5leHBlY3RlZFN1YnRyYWN0aW9uT3BlcmFuZCwge1xuICAgICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuXG4gICAgICBjYXNlIDEzMDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBjYXNlIDEzMTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiQmlnSW50TGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBjYXNlIDg4OlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZvaWRUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSA4NDpcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuXG4gICAgICBjYXNlIDc4OlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSA1NTpcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiKTtcblxuICAgICAgY2FzZSA4NzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlVHlwZW9mVHlwZSgpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodG9rZW5Jc0tleXdvcmQodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIGNvbnN0IGxhYmVsID0gdG9rZW5MYWJlbE5hbWUodGhpcy5zdGF0ZS50eXBlKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gc3VwZXIuY3JlYXRlSWRlbnRpZmllcihub2RlLCBsYWJlbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2VUeXBlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd0lkZW50VG9UeXBlQW5ub3RhdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIG5vZGUsIHRoaXMucGFyc2VJZGVudGlmaWVyKCkpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuXG4gIGZsb3dQYXJzZVBvc3RmaXhUeXBlKCkge1xuICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbGV0IHR5cGUgPSB0aGlzLmZsb3dQYXJzZVByaW1hcnlUeXBlKCk7XG4gICAgbGV0IHNlZW5PcHRpb25hbEluZGV4ZWRBY2Nlc3MgPSBmYWxzZTtcblxuICAgIHdoaWxlICgodGhpcy5tYXRjaCgwKSB8fCB0aGlzLm1hdGNoKDE4KSkgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBjb25zdCBvcHRpb25hbCA9IHRoaXMuZWF0KDE4KTtcbiAgICAgIHNlZW5PcHRpb25hbEluZGV4ZWRBY2Nlc3MgPSBzZWVuT3B0aW9uYWxJbmRleGVkQWNjZXNzIHx8IG9wdGlvbmFsO1xuICAgICAgdGhpcy5leHBlY3QoMCk7XG5cbiAgICAgIGlmICghb3B0aW9uYWwgJiYgdGhpcy5tYXRjaCgzKSkge1xuICAgICAgICBub2RlLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5vYmplY3RUeXBlID0gdHlwZTtcbiAgICAgICAgbm9kZS5pbmRleFR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMyk7XG5cbiAgICAgICAgaWYgKHNlZW5PcHRpb25hbEluZGV4ZWRBY2Nlc3MpIHtcbiAgICAgICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkluZGV4ZWRBY2Nlc3NUeXBlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBmbG93UGFyc2VQcmVmaXhUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlUHJlZml4VHlwZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVBvc3RmaXhUeXBlKCk7XG4gICAgfVxuICB9XG5cbiAgZmxvd1BhcnNlQW5vbkZ1bmN0aW9uV2l0aG91dFBhcmVucygpIHtcbiAgICBjb25zdCBwYXJhbSA9IHRoaXMuZmxvd1BhcnNlUHJlZml4VHlwZSgpO1xuXG4gICAgaWYgKCF0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSAmJiB0aGlzLmVhdCgxOSkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHBhcmFtLnN0YXJ0LCBwYXJhbS5sb2Muc3RhcnQpO1xuICAgICAgbm9kZS5wYXJhbXMgPSBbdGhpcy5yZWludGVycHJldFR5cGVBc0Z1bmN0aW9uVHlwZVBhcmFtKHBhcmFtKV07XG4gICAgICBub2RlLnJlc3QgPSBudWxsO1xuICAgICAgbm9kZS50aGlzID0gbnVsbDtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW07XG4gIH1cblxuICBmbG93UGFyc2VJbnRlcnNlY3Rpb25UeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZWF0KDQ1KTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5mbG93UGFyc2VBbm9uRnVuY3Rpb25XaXRob3V0UGFyZW5zKCk7XG4gICAgbm9kZS50eXBlcyA9IFt0eXBlXTtcblxuICAgIHdoaWxlICh0aGlzLmVhdCg0NSkpIHtcbiAgICAgIG5vZGUudHlwZXMucHVzaCh0aGlzLmZsb3dQYXJzZUFub25GdW5jdGlvbldpdGhvdXRQYXJlbnMoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGUudHlwZXMubGVuZ3RoID09PSAxID8gdHlwZSA6IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG5cbiAgZmxvd1BhcnNlVW5pb25UeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZWF0KDQzKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5mbG93UGFyc2VJbnRlcnNlY3Rpb25UeXBlKCk7XG4gICAgbm9kZS50eXBlcyA9IFt0eXBlXTtcblxuICAgIHdoaWxlICh0aGlzLmVhdCg0MykpIHtcbiAgICAgIG5vZGUudHlwZXMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyc2VjdGlvblR5cGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGUudHlwZXMubGVuZ3RoID09PSAxID8gdHlwZSA6IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlVuaW9uVHlwZUFubm90YXRpb25cIik7XG4gIH1cblxuICBmbG93UGFyc2VUeXBlKCkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5mbG93UGFyc2VVbmlvblR5cGUoKTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVPckltcGxpY2l0SW5zdGFudGlhdGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS50eXBlID09PSAxMjggJiYgdGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCJfXCIpIHtcbiAgICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlR2VuZXJpY1R5cGUoc3RhcnRQb3MsIHN0YXJ0TG9jLCBub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuXG4gIGZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIoYWxsb3dQcmltaXRpdmVPdmVycmlkZSkge1xuICAgIGNvbnN0IGlkZW50ID0gYWxsb3dQcmltaXRpdmVPdmVycmlkZSA/IHRoaXMucGFyc2VJZGVudGlmaWVyKCkgOiB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGlkZW50LnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGlkZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWRlbnQ7XG4gIH1cblxuICB0eXBlQ2FzdFRvUGFyYW1ldGVyKG5vZGUpIHtcbiAgICBub2RlLmV4cHJlc3Npb24udHlwZUFubm90YXRpb24gPSBub2RlLnR5cGVBbm5vdGF0aW9uO1xuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudHlwZUFubm90YXRpb24ubG9jLmVuZCk7XG4gICAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbjtcbiAgfVxuXG4gIGZsb3dQYXJzZVZhcmlhbmNlKCkge1xuICAgIGxldCB2YXJpYW5jZSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5tYXRjaCg1MykpIHtcbiAgICAgIHZhcmlhbmNlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiK1wiKSB7XG4gICAgICAgIHZhcmlhbmNlLmtpbmQgPSBcInBsdXNcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhcmlhbmNlLmtpbmQgPSBcIm1pbnVzXCI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh2YXJpYW5jZSwgXCJWYXJpYW5jZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFyaWFuY2U7XG4gIH1cblxuICBwYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgaWYgKGFsbG93RXhwcmVzc2lvbkJvZHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcndhcmROb0Fycm93UGFyYW1zQ29udmVyc2lvbkF0KG5vZGUsICgpID0+IHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUsIGlzTWV0aG9kKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCBpc01ldGhvZCk7XG4gIH1cblxuICBwYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCB0eXBlLCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCB0eXBlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBbdHlwZU5vZGUudHlwZUFubm90YXRpb24sIG5vZGUucHJlZGljYXRlXSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCk7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0eXBlTm9kZS50eXBlQW5ub3RhdGlvbiA/IHRoaXMuZmluaXNoTm9kZSh0eXBlTm9kZSwgXCJUeXBlQW5ub3RhdGlvblwiKSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kKTtcbiAgfVxuXG4gIHBhcnNlU3RhdGVtZW50KGNvbnRleHQsIHRvcExldmVsKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIHRoaXMuaXNDb250ZXh0dWFsKDEyNSkpIHtcbiAgICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG5cbiAgICAgIGlmICh0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcihsb29rYWhlYWQudHlwZSkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Uobm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnNob3VsZFBhcnNlRW51bXMoKSAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMjIpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRW51bURlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0bXQgPSBzdXBlci5wYXJzZVN0YXRlbWVudChjb250ZXh0LCB0b3BMZXZlbCk7XG5cbiAgICBpZiAodGhpcy5mbG93UHJhZ21hID09PSB1bmRlZmluZWQgJiYgIXRoaXMuaXNWYWxpZERpcmVjdGl2ZShzdG10KSkge1xuICAgICAgdGhpcy5mbG93UHJhZ21hID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RtdDtcbiAgfVxuXG4gIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSB7XG4gICAgaWYgKGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIGlmIChleHByLm5hbWUgPT09IFwiZGVjbGFyZVwiKSB7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDgwKSB8fCB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpIHx8IHRoaXMubWF0Y2goNjgpIHx8IHRoaXMubWF0Y2goNzQpIHx8IHRoaXMubWF0Y2goODIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIGlmIChleHByLm5hbWUgPT09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Uobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwci5uYW1lID09PSBcInR5cGVcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChleHByLm5hbWUgPT09IFwib3BhcXVlXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcik7XG4gIH1cblxuICBzaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGlmICh0b2tlbklzRmxvd0ludGVyZmFjZU9yVHlwZU9yT3BhcXVlKHR5cGUpIHx8IHRoaXMuc2hvdWxkUGFyc2VFbnVtcygpICYmIHR5cGUgPT09IDEyMikge1xuICAgICAgcmV0dXJuICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5zaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCk7XG4gIH1cblxuICBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKHRva2VuSXNGbG93SW50ZXJmYWNlT3JUeXBlT3JPcGFxdWUodHlwZSkgfHwgdGhpcy5zaG91bGRQYXJzZUVudW1zKCkgJiYgdHlwZSA9PT0gMTIyKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCk7XG4gIH1cblxuICBwYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCkge1xuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlRW51bXMoKSAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMjIpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRW51bURlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCk7XG4gIH1cblxuICBwYXJzZUNvbmRpdGlvbmFsKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmICghdGhpcy5tYXRjaCgxNykpIHJldHVybiBleHByO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycykge1xuICAgICAgY29uc3QgbmV4dENoID0gdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpO1xuXG4gICAgICBpZiAobmV4dENoID09PSA0NCB8fCBuZXh0Q2ggPT09IDYxIHx8IG5leHRDaCA9PT0gNTggfHwgbmV4dENoID09PSA0MSkge1xuICAgICAgICB0aGlzLnNldE9wdGlvbmFsUGFyYW1ldGVyc0Vycm9yKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdCgxNyk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgY29uc3Qgb3JpZ2luYWxOb0Fycm93QXQgPSB0aGlzLnN0YXRlLm5vQXJyb3dBdDtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIGxldCB7XG4gICAgICBjb25zZXF1ZW50LFxuICAgICAgZmFpbGVkXG4gICAgfSA9IHRoaXMudHJ5UGFyc2VDb25kaXRpb25hbENvbnNlcXVlbnQoKTtcbiAgICBsZXQgW3ZhbGlkLCBpbnZhbGlkXSA9IHRoaXMuZ2V0QXJyb3dMaWtlRXhwcmVzc2lvbnMoY29uc2VxdWVudCk7XG5cbiAgICBpZiAoZmFpbGVkIHx8IGludmFsaWQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgbm9BcnJvd0F0ID0gWy4uLm9yaWdpbmFsTm9BcnJvd0F0XTtcblxuICAgICAgaWYgKGludmFsaWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUubm9BcnJvd0F0ID0gbm9BcnJvd0F0O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW52YWxpZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vQXJyb3dBdC5wdXNoKGludmFsaWRbaV0uc3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgKHtcbiAgICAgICAgICBjb25zZXF1ZW50LFxuICAgICAgICAgIGZhaWxlZFxuICAgICAgICB9ID0gdGhpcy50cnlQYXJzZUNvbmRpdGlvbmFsQ29uc2VxdWVudCgpKTtcbiAgICAgICAgW3ZhbGlkLCBpbnZhbGlkXSA9IHRoaXMuZ2V0QXJyb3dMaWtlRXhwcmVzc2lvbnMoY29uc2VxdWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmYWlsZWQgJiYgdmFsaWQubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuQW1iaWd1b3VzQ29uZGl0aW9uYWxBcnJvdywge1xuICAgICAgICAgIGF0OiBzdGF0ZS5zdGFydExvY1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZhaWxlZCAmJiB2YWxpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICBub0Fycm93QXQucHVzaCh2YWxpZFswXS5zdGFydCk7XG4gICAgICAgIHRoaXMuc3RhdGUubm9BcnJvd0F0ID0gbm9BcnJvd0F0O1xuICAgICAgICAoe1xuICAgICAgICAgIGNvbnNlcXVlbnQsXG4gICAgICAgICAgZmFpbGVkXG4gICAgICAgIH0gPSB0aGlzLnRyeVBhcnNlQ29uZGl0aW9uYWxDb25zZXF1ZW50KCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZ2V0QXJyb3dMaWtlRXhwcmVzc2lvbnMoY29uc2VxdWVudCwgdHJ1ZSk7XG4gICAgdGhpcy5zdGF0ZS5ub0Fycm93QXQgPSBvcmlnaW5hbE5vQXJyb3dBdDtcbiAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuICAgIG5vZGUuYWx0ZXJuYXRlID0gdGhpcy5mb3J3YXJkTm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdChub2RlLCAoKSA9PiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24odW5kZWZpbmVkLCB1bmRlZmluZWQpKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgdHJ5UGFyc2VDb25kaXRpb25hbENvbnNlcXVlbnQoKSB7XG4gICAgdGhpcy5zdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LnB1c2godGhpcy5zdGF0ZS5zdGFydCk7XG4gICAgY29uc3QgY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICBjb25zdCBmYWlsZWQgPSAhdGhpcy5tYXRjaCgxNCk7XG4gICAgdGhpcy5zdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LnBvcCgpO1xuICAgIHJldHVybiB7XG4gICAgICBjb25zZXF1ZW50LFxuICAgICAgZmFpbGVkXG4gICAgfTtcbiAgfVxuXG4gIGdldEFycm93TGlrZUV4cHJlc3Npb25zKG5vZGUsIGRpc2FsbG93SW52YWxpZCkge1xuICAgIGNvbnN0IHN0YWNrID0gW25vZGVdO1xuICAgIGNvbnN0IGFycm93cyA9IFtdO1xuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3Qgbm9kZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICBpZiAobm9kZS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZVBhcmFtZXRlcnMgfHwgIW5vZGUucmV0dXJuVHlwZSkge1xuICAgICAgICAgIHRoaXMuZmluaXNoQXJyb3dWYWxpZGF0aW9uKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycm93cy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhY2sucHVzaChub2RlLmJvZHkpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgc3RhY2sucHVzaChub2RlLmNvbnNlcXVlbnQpO1xuICAgICAgICBzdGFjay5wdXNoKG5vZGUuYWx0ZXJuYXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlzYWxsb3dJbnZhbGlkKSB7XG4gICAgICBhcnJvd3MuZm9yRWFjaChub2RlID0+IHRoaXMuZmluaXNoQXJyb3dWYWxpZGF0aW9uKG5vZGUpKTtcbiAgICAgIHJldHVybiBbYXJyb3dzLCBbXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnRpdGlvbihhcnJvd3MsIG5vZGUgPT4gbm9kZS5wYXJhbXMuZXZlcnkocGFyYW0gPT4gdGhpcy5pc0Fzc2lnbmFibGUocGFyYW0sIHRydWUpKSk7XG4gIH1cblxuICBmaW5pc2hBcnJvd1ZhbGlkYXRpb24obm9kZSkge1xuICAgIHZhciBfbm9kZSRleHRyYTtcblxuICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLnBhcmFtcywgKF9ub2RlJGV4dHJhID0gbm9kZS5leHRyYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGV4dHJhLnRyYWlsaW5nQ29tbWFMb2MsIGZhbHNlKTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX0ZVTkNUSU9OIHwgU0NPUEVfQVJST1cpO1xuICAgIHN1cGVyLmNoZWNrUGFyYW1zKG5vZGUsIGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgfVxuXG4gIGZvcndhcmROb0Fycm93UGFyYW1zQ29udmVyc2lvbkF0KG5vZGUsIHBhcnNlKSB7XG4gICAgbGV0IHJlc3VsdDtcblxuICAgIGlmICh0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQuaW5kZXhPZihub2RlLnN0YXJ0KSAhPT0gLTEpIHtcbiAgICAgIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wdXNoKHRoaXMuc3RhdGUuc3RhcnQpO1xuICAgICAgcmVzdWx0ID0gcGFyc2UoKTtcbiAgICAgIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gcGFyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcGFyc2VQYXJlbkl0ZW0obm9kZSwgc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gICAgbm9kZSA9IHN1cGVyLnBhcnNlUGFyZW5JdGVtKG5vZGUsIHN0YXJ0UG9zLCBzdGFydExvYyk7XG5cbiAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihub2RlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGNvbnN0IHR5cGVDYXN0Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIHR5cGVDYXN0Tm9kZS5leHByZXNzaW9uID0gbm9kZTtcbiAgICAgIHR5cGVDYXN0Tm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodHlwZUNhc3ROb2RlLCBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGFzc2VydE1vZHVsZU5vZGVBbGxvd2VkKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkltcG9ydERlY2xhcmF0aW9uXCIgJiYgKG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiKSB8fCBub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiICYmIG5vZGUuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS50eXBlID09PSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIgJiYgbm9kZS5leHBvcnRLaW5kID09PSBcInR5cGVcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1cGVyLmFzc2VydE1vZHVsZU5vZGVBbGxvd2VkKG5vZGUpO1xuICB9XG5cbiAgcGFyc2VFeHBvcnQobm9kZSkge1xuICAgIGNvbnN0IGRlY2wgPSBzdXBlci5wYXJzZUV4cG9ydChub2RlKTtcblxuICAgIGlmIChkZWNsLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiIHx8IGRlY2wudHlwZSA9PT0gXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKSB7XG4gICAgICBkZWNsLmV4cG9ydEtpbmQgPSBkZWNsLmV4cG9ydEtpbmQgfHwgXCJ2YWx1ZVwiO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNsO1xuICB9XG5cbiAgcGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNikpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidHlwZVwiO1xuICAgICAgY29uc3QgZGVjbGFyYXRpb25Ob2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICBpZiAodGhpcy5tYXRjaCg1KSkge1xuICAgICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyh0cnVlKTtcbiAgICAgICAgc3VwZXIucGFyc2VFeHBvcnRGcm9tKG5vZGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhkZWNsYXJhdGlvbk5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI3KSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKGRlY2xhcmF0aW9uTm9kZSwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI1KSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2UoZGVjbGFyYXRpb25Ob2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2hvdWxkUGFyc2VFbnVtcygpICYmIHRoaXMuaXNDb250ZXh0dWFsKDEyMikpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUVudW1EZWNsYXJhdGlvbihkZWNsYXJhdGlvbk5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gIH1cblxuICBlYXRFeHBvcnRTdGFyKG5vZGUpIHtcbiAgICBpZiAoc3VwZXIuZWF0RXhwb3J0U3Rhcihub2RlKSkgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI2KSAmJiB0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IDU1KSB7XG4gICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInR5cGVcIjtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtYXliZVBhcnNlRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydExvY1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGhhc05hbWVzcGFjZSA9IHN1cGVyLm1heWJlUGFyc2VFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSk7XG5cbiAgICBpZiAoaGFzTmFtZXNwYWNlICYmIG5vZGUuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChzdGFydExvYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc05hbWVzcGFjZTtcbiAgfVxuXG4gIHBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIHN1cGVyLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRMb2NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjEpKSB7XG4gICAgICBpZiAoc3VwZXIucGFyc2VDbGFzc01lbWJlckZyb21Nb2RpZmllcihjbGFzc0JvZHksIG1lbWJlcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtZW1iZXIuZGVjbGFyZSA9IHRydWU7XG4gICAgfVxuXG4gICAgc3VwZXIucGFyc2VDbGFzc01lbWJlcihjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUpO1xuXG4gICAgaWYgKG1lbWJlci5kZWNsYXJlKSB7XG4gICAgICBpZiAobWVtYmVyLnR5cGUgIT09IFwiQ2xhc3NQcm9wZXJ0eVwiICYmIG1lbWJlci50eXBlICE9PSBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIgJiYgbWVtYmVyLnR5cGUgIT09IFwiUHJvcGVydHlEZWZpbml0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkRlY2xhcmVDbGFzc0VsZW1lbnQsIHtcbiAgICAgICAgICBhdDogc3RhcnRMb2NcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG1lbWJlci52YWx1ZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRGVjbGFyZUNsYXNzRmllbGRJbml0aWFsaXplciwge1xuICAgICAgICAgIGF0OiBtZW1iZXIudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNJdGVyYXRvcih3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQgPT09IFwiaXRlcmF0b3JcIiB8fCB3b3JkID09PSBcImFzeW5jSXRlcmF0b3JcIjtcbiAgfVxuXG4gIHJlYWRJdGVyYXRvcigpIHtcbiAgICBjb25zdCB3b3JkID0gc3VwZXIucmVhZFdvcmQxKCk7XG4gICAgY29uc3QgZnVsbFdvcmQgPSBcIkBAXCIgKyB3b3JkO1xuXG4gICAgaWYgKCF0aGlzLmlzSXRlcmF0b3Iod29yZCkgfHwgIXRoaXMuc3RhdGUuaW5UeXBlKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkSWRlbnRpZmllciwge1xuICAgICAgICBhdDogdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpLFxuICAgICAgICBpZGVudGlmaWVyTmFtZTogZnVsbFdvcmRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZmluaXNoVG9rZW4oMTI4LCBmdWxsV29yZCk7XG4gIH1cblxuICBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG5cbiAgICBpZiAoY29kZSA9PT0gMTIzICYmIG5leHQgPT09IDEyNCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoNiwgMik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmluVHlwZSAmJiAoY29kZSA9PT0gNjIgfHwgY29kZSA9PT0gNjApKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSA2MiA/IDQ4IDogNDcsIDEpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5pblR5cGUgJiYgY29kZSA9PT0gNjMpIHtcbiAgICAgIGlmIChuZXh0ID09PSA0Nikge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCgxOCwgMik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKDE3LCAxKTtcbiAgICB9IGVsc2UgaWYgKGlzSXRlcmF0b3JTdGFydChjb2RlLCBuZXh0LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAyKSkpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkSXRlcmF0b3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLmdldFRva2VuRnJvbUNvZGUoY29kZSk7XG4gICAgfVxuICB9XG5cbiAgaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZykge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5pc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gIH1cblxuICB0b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMgPSBmYWxzZSkge1xuICAgIGlmICghaXNMSFMgJiYgbm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIgJiYgbm9kZS5sZWZ0LnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgIG5vZGUubGVmdCA9IHRoaXMudHlwZUNhc3RUb1BhcmFtZXRlcihub2RlLmxlZnQpO1xuICAgIH1cblxuICAgIHN1cGVyLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gIH1cblxuICB0b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0LCB0cmFpbGluZ0NvbW1hTG9jLCBpc0xIUykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4cHIgPSBleHByTGlzdFtpXTtcblxuICAgICAgaWYgKChleHByID09IG51bGwgPyB2b2lkIDAgOiBleHByLnR5cGUpID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGV4cHJMaXN0W2ldID0gdGhpcy50eXBlQ2FzdFRvUGFyYW1ldGVyKGV4cHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyLnRvQXNzaWduYWJsZUxpc3QoZXhwckxpc3QsIHRyYWlsaW5nQ29tbWFMb2MsIGlzTEhTKTtcbiAgfVxuXG4gIHRvUmVmZXJlbmNlZExpc3QoZXhwckxpc3QsIGlzUGFyZW50aGVzaXplZEV4cHIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2V4cHIkZXh0cmE7XG5cbiAgICAgIGNvbnN0IGV4cHIgPSBleHByTGlzdFtpXTtcblxuICAgICAgaWYgKGV4cHIgJiYgZXhwci50eXBlID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiICYmICEoKF9leHByJGV4dHJhID0gZXhwci5leHRyYSkgIT0gbnVsbCAmJiBfZXhwciRleHRyYS5wYXJlbnRoZXNpemVkKSAmJiAoZXhwckxpc3QubGVuZ3RoID4gMSB8fCAhaXNQYXJlbnRoZXNpemVkRXhwcikpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlR5cGVDYXN0SW5QYXR0ZXJuLCB7XG4gICAgICAgICAgYXQ6IGV4cHIudHlwZUFubm90YXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHJMaXN0O1xuICB9XG5cbiAgcGFyc2VBcnJheUxpa2UoY2xvc2UsIGNhbkJlUGF0dGVybiwgaXNUdXBsZSwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZUFycmF5TGlrZShjbG9zZSwgY2FuQmVQYXR0ZXJuLCBpc1R1cGxlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcblxuICAgIGlmIChjYW5CZVBhdHRlcm4gJiYgIXRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycykge1xuICAgICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KG5vZGUuZWxlbWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgaXNWYWxpZExWYWwodHlwZSwgaXNQYXJlbnRoZXNpemVkLCBiaW5kaW5nKSB7XG4gICAgcmV0dXJuIHR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgfHwgc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgaXNQYXJlbnRoZXNpemVkLCBiaW5kaW5nKTtcbiAgfVxuXG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZUNsYXNzUHJvcGVydHkobm9kZSk7XG4gIH1cblxuICBwYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSk7XG4gIH1cblxuICBpc0NsYXNzTWV0aG9kKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDQ3KSB8fCBzdXBlci5pc0NsYXNzTWV0aG9kKCk7XG4gIH1cblxuICBpc0NsYXNzUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTQpIHx8IHN1cGVyLmlzQ2xhc3NQcm9wZXJ0eSgpO1xuICB9XG5cbiAgaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICByZXR1cm4gIXRoaXMubWF0Y2goMTQpICYmIHN1cGVyLmlzTm9uc3RhdGljQ29uc3RydWN0b3IobWV0aG9kKTtcbiAgfVxuXG4gIHB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gICAgaWYgKG1ldGhvZC52YXJpYW5jZSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG1ldGhvZC52YXJpYW5jZS5sb2Muc3RhcnQpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBtZXRob2QudmFyaWFuY2U7XG5cbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG1ldGhvZC50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuXG4gICAgc3VwZXIucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIpO1xuXG4gICAgaWYgKG1ldGhvZC5wYXJhbXMgJiYgaXNDb25zdHJ1Y3Rvcikge1xuICAgICAgY29uc3QgcGFyYW1zID0gbWV0aG9kLnBhcmFtcztcblxuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwICYmIHRoaXMuaXNUaGlzUGFyYW0ocGFyYW1zWzBdKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtQmFubmVkSW5Db25zdHJ1Y3Rvciwge1xuICAgICAgICAgIGF0OiBtZXRob2RcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtZXRob2QudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgaXNDb25zdHJ1Y3RvciAmJiBtZXRob2QudmFsdWUucGFyYW1zKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBtZXRob2QudmFsdWUucGFyYW1zO1xuXG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDAgJiYgdGhpcy5pc1RoaXNQYXJhbShwYXJhbXNbMF0pKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1CYW5uZWRJbkNvbnN0cnVjdG9yLCB7XG4gICAgICAgICAgYXQ6IG1ldGhvZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYykge1xuICAgIGlmIChtZXRob2QudmFyaWFuY2UpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChtZXRob2QudmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICB9XG5cbiAgICBkZWxldGUgbWV0aG9kLnZhcmlhbmNlO1xuXG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBtZXRob2QudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cblxuICAgIHN1cGVyLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgfVxuXG4gIHBhcnNlQ2xhc3NTdXBlcihub2RlKSB7XG4gICAgc3VwZXIucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuXG4gICAgaWYgKG5vZGUuc3VwZXJDbGFzcyAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS5zdXBlclR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMTApKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IGltcGxlbWVudGVkID0gbm9kZS5pbXBsZW1lbnRzID0gW107XG5cbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUpO1xuXG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpbXBsZW1lbnRlZC5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNsYXNzSW1wbGVtZW50c1wiKSk7XG4gICAgICB9IHdoaWxlICh0aGlzLmVhdCgxMikpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKG1ldGhvZCkge1xuICAgIHN1cGVyLmNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKG1ldGhvZCk7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRPYmplY3RPckNsYXNzTWV0aG9kUGFyYW1zKG1ldGhvZCk7XG5cbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHBhcmFtID0gcGFyYW1zWzBdO1xuXG4gICAgICBpZiAodGhpcy5pc1RoaXNQYXJhbShwYXJhbSkgJiYgbWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkdldHRlck1heU5vdEhhdmVUaGlzUGFyYW0sIHtcbiAgICAgICAgICBhdDogcGFyYW1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUaGlzUGFyYW0ocGFyYW0pKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5TZXR0ZXJNYXlOb3RIYXZlVGhpc1BhcmFtLCB7XG4gICAgICAgICAgYXQ6IHBhcmFtXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBhcnNlUHJvcGVydHlOYW1lUHJlZml4T3BlcmF0b3Iobm9kZSkge1xuICAgIG5vZGUudmFyaWFuY2UgPSB0aGlzLmZsb3dQYXJzZVZhcmlhbmNlKCk7XG4gIH1cblxuICBwYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAocHJvcC52YXJpYW5jZSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKHByb3AudmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICB9XG5cbiAgICBkZWxldGUgcHJvcC52YXJpYW5jZTtcbiAgICBsZXQgdHlwZVBhcmFtZXRlcnM7XG5cbiAgICBpZiAodGhpcy5tYXRjaCg0NykgJiYgIWlzQWNjZXNzb3IpIHtcbiAgICAgIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMCkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0UG9zLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG5cbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgIChyZXN1bHQudmFsdWUgfHwgcmVzdWx0KS50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwYXJzZUFzc2lnbmFibGVMaXN0SXRlbVR5cGVzKHBhcmFtKSB7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgaWYgKHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5QYXR0ZXJuSXNPcHRpb25hbCwge1xuICAgICAgICAgIGF0OiBwYXJhbVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNUaGlzUGFyYW0ocGFyYW0pKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1NYXlOb3RCZU9wdGlvbmFsLCB7XG4gICAgICAgICAgYXQ6IHBhcmFtXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBwYXJhbS5vcHRpb25hbCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBwYXJhbS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNUaGlzUGFyYW0ocGFyYW0pKSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtQW5ub3RhdGlvblJlcXVpcmVkLCB7XG4gICAgICAgIGF0OiBwYXJhbVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF0Y2goMjkpICYmIHRoaXMuaXNUaGlzUGFyYW0ocGFyYW0pKSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtTm9EZWZhdWx0LCB7XG4gICAgICAgIGF0OiBwYXJhbVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKHBhcmFtKTtcbiAgICByZXR1cm4gcGFyYW07XG4gIH1cblxuICBwYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0KTtcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIiAmJiBub2RlLnR5cGVBbm5vdGF0aW9uICYmIG5vZGUucmlnaHQuc3RhcnQgPCBub2RlLnR5cGVBbm5vdGF0aW9uLnN0YXJ0KSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVHlwZUJlZm9yZUluaXRpYWxpemVyLCB7XG4gICAgICAgIGF0OiBub2RlLnR5cGVBbm5vdGF0aW9uXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHNob3VsZFBhcnNlRGVmYXVsdEltcG9ydChub2RlKSB7XG4gICAgaWYgKCFoYXNUeXBlSW1wb3J0S2luZChub2RlKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLnNob3VsZFBhcnNlRGVmYXVsdEltcG9ydChub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNNYXliZURlZmF1bHRJbXBvcnQodGhpcy5zdGF0ZS50eXBlKTtcbiAgfVxuXG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyTG9jYWwobm9kZSwgc3BlY2lmaWVyLCB0eXBlKSB7XG4gICAgc3BlY2lmaWVyLmxvY2FsID0gaGFzVHlwZUltcG9ydEtpbmQobm9kZSkgPyB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUsIHRydWUpIDogdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaEltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIHR5cGUpKTtcbiAgfVxuXG4gIG1heWJlUGFyc2VEZWZhdWx0SW1wb3J0U3BlY2lmaWVyKG5vZGUpIHtcbiAgICBub2RlLmltcG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgbGV0IGtpbmQgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMubWF0Y2goODcpKSB7XG4gICAgICBraW5kID0gXCJ0eXBlb2ZcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNikpIHtcbiAgICAgIGtpbmQgPSBcInR5cGVcIjtcbiAgICB9XG5cbiAgICBpZiAoa2luZCkge1xuICAgICAgY29uc3QgbGggPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlXG4gICAgICB9ID0gbGg7XG5cbiAgICAgIGlmIChraW5kID09PSBcInR5cGVcIiAmJiB0eXBlID09PSA1NSkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgbGgudHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc01heWJlRGVmYXVsdEltcG9ydCh0eXBlKSB8fCB0eXBlID09PSA1IHx8IHR5cGUgPT09IDU1KSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBub2RlLmltcG9ydEtpbmQgPSBraW5kO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5tYXliZVBhcnNlRGVmYXVsdEltcG9ydFNwZWNpZmllcihub2RlKTtcbiAgfVxuXG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgaXNJblR5cGVPbmx5SW1wb3J0LCBpc01heWJlVHlwZU9ubHkpIHtcbiAgICBjb25zdCBmaXJzdElkZW50ID0gc3BlY2lmaWVyLmltcG9ydGVkO1xuICAgIGxldCBzcGVjaWZpZXJUeXBlS2luZCA9IG51bGw7XG5cbiAgICBpZiAoZmlyc3RJZGVudC50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgaWYgKGZpcnN0SWRlbnQubmFtZSA9PT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgc3BlY2lmaWVyVHlwZUtpbmQgPSBcInR5cGVcIjtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RJZGVudC5uYW1lID09PSBcInR5cGVvZlwiKSB7XG4gICAgICAgIHNwZWNpZmllclR5cGVLaW5kID0gXCJ0eXBlb2ZcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgaXNCaW5kaW5nID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTMpICYmICF0aGlzLmlzTG9va2FoZWFkQ29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICBjb25zdCBhc19pZGVudCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuXG4gICAgICBpZiAoc3BlY2lmaWVyVHlwZUtpbmQgIT09IG51bGwgJiYgIXRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gYXNfaWRlbnQ7XG4gICAgICAgIHNwZWNpZmllci5pbXBvcnRLaW5kID0gc3BlY2lmaWVyVHlwZUtpbmQ7XG4gICAgICAgIHNwZWNpZmllci5sb2NhbCA9IGNsb25lSWRlbnRpZmllcihhc19pZGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSBmaXJzdElkZW50O1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IG51bGw7XG4gICAgICAgIHNwZWNpZmllci5sb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzcGVjaWZpZXJUeXBlS2luZCAhPT0gbnVsbCAmJiB0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIHNwZWNpZmllci5pbXBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IHNwZWNpZmllclR5cGVLaW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGltcG9ydGVkSXNTdHJpbmcpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRCaW5kaW5nSXNTdHJpbmcsIHtcbiAgICAgICAgICAgIGF0OiBzcGVjaWZpZXIsXG4gICAgICAgICAgICBpbXBvcnROYW1lOiBmaXJzdElkZW50LnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSBmaXJzdElkZW50O1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoOTMpKSB7XG4gICAgICAgIHNwZWNpZmllci5sb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0JpbmRpbmcgPSB0cnVlO1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSBjbG9uZUlkZW50aWZpZXIoc3BlY2lmaWVyLmltcG9ydGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzcGVjaWZpZXJJc1R5cGVJbXBvcnQgPSBoYXNUeXBlSW1wb3J0S2luZChzcGVjaWZpZXIpO1xuXG4gICAgaWYgKGlzSW5UeXBlT25seUltcG9ydCAmJiBzcGVjaWZpZXJJc1R5cGVJbXBvcnQpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbXBvcnRUeXBlU2hvcnRoYW5kT25seUluUHVyZUltcG9ydCwge1xuICAgICAgICBhdDogc3BlY2lmaWVyXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNJblR5cGVPbmx5SW1wb3J0IHx8IHNwZWNpZmllcklzVHlwZUltcG9ydCkge1xuICAgICAgdGhpcy5jaGVja1Jlc2VydmVkVHlwZShzcGVjaWZpZXIubG9jYWwubmFtZSwgc3BlY2lmaWVyLmxvY2FsLmxvYy5zdGFydCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQmluZGluZyAmJiAhaXNJblR5cGVPbmx5SW1wb3J0ICYmICFzcGVjaWZpZXJJc1R5cGVJbXBvcnQpIHtcbiAgICAgIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQoc3BlY2lmaWVyLmxvY2FsLm5hbWUsIHNwZWNpZmllci5sb2Muc3RhcnQsIHRydWUsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaEltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpO1xuICB9XG5cbiAgcGFyc2VCaW5kaW5nQXRvbSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSA3ODpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgYWxsb3dNb2RpZmllcnMpIHtcbiAgICBjb25zdCBraW5kID0gbm9kZS5raW5kO1xuXG4gICAgaWYgKGtpbmQgIT09IFwiZ2V0XCIgJiYga2luZCAhPT0gXCJzZXRcIiAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuXG4gICAgc3VwZXIucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBhbGxvd01vZGlmaWVycyk7XG4gIH1cblxuICBwYXJzZVZhcklkKGRlY2wsIGtpbmQpIHtcbiAgICBzdXBlci5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBkZWNsLmlkLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGRlY2wuaWQpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbihub2RlLCBjYWxsKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gdHJ1ZTtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24obm9kZSwgY2FsbCk7XG4gIH1cblxuICBzaG91bGRQYXJzZUFzeW5jQXJyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTQpIHx8IHN1cGVyLnNob3VsZFBhcnNlQXN5bmNBcnJvdygpO1xuICB9XG5cbiAgcGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIHZhciBfanN4O1xuXG4gICAgbGV0IHN0YXRlID0gbnVsbDtcbiAgICBsZXQganN4O1xuXG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwianN4XCIpICYmICh0aGlzLm1hdGNoKDEzOCkgfHwgdGhpcy5tYXRjaCg0NykpKSB7XG4gICAgICBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgIGpzeCA9IHRoaXMudHJ5UGFyc2UoKCkgPT4gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSksIHN0YXRlKTtcbiAgICAgIGlmICghanN4LmVycm9yKSByZXR1cm4ganN4Lm5vZGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgY3VycmVudENvbnRleHQgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChjdXJyZW50Q29udGV4dCA9PT0gdHlwZXMual9vVGFnIHx8IGN1cnJlbnRDb250ZXh0ID09PSB0eXBlcy5qX2V4cHIpIHtcbiAgICAgICAgY29udGV4dC5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKF9qc3ggPSBqc3gpICE9IG51bGwgJiYgX2pzeC5lcnJvciB8fCB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgdmFyIF9qc3gyLCBfanN4MztcblxuICAgICAgc3RhdGUgPSBzdGF0ZSB8fCB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgICBsZXQgdHlwZVBhcmFtZXRlcnM7XG4gICAgICBjb25zdCBhcnJvdyA9IHRoaXMudHJ5UGFyc2UoYWJvcnQgPT4ge1xuICAgICAgICB2YXIgX2Fycm93RXhwcmVzc2lvbiRleHRyO1xuXG4gICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgY29uc3QgYXJyb3dFeHByZXNzaW9uID0gdGhpcy5mb3J3YXJkTm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdCh0eXBlUGFyYW1ldGVycywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpO1xuICAgICAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUocmVzdWx0LCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgoX2Fycm93RXhwcmVzc2lvbiRleHRyID0gYXJyb3dFeHByZXNzaW9uLmV4dHJhKSAhPSBudWxsICYmIF9hcnJvd0V4cHJlc3Npb24kZXh0ci5wYXJlbnRoZXNpemVkKSBhYm9ydCgpO1xuICAgICAgICBjb25zdCBleHByID0gdGhpcy5tYXliZVVud3JhcFR5cGVDYXN0RXhwcmVzc2lvbihhcnJvd0V4cHJlc3Npb24pO1xuICAgICAgICBpZiAoZXhwci50eXBlICE9PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIGFib3J0KCk7XG4gICAgICAgIGV4cHIudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShleHByLCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIHJldHVybiBhcnJvd0V4cHJlc3Npb247XG4gICAgICB9LCBzdGF0ZSk7XG4gICAgICBsZXQgYXJyb3dFeHByZXNzaW9uID0gbnVsbDtcblxuICAgICAgaWYgKGFycm93Lm5vZGUgJiYgdGhpcy5tYXliZVVud3JhcFR5cGVDYXN0RXhwcmVzc2lvbihhcnJvdy5ub2RlKS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgICAgaWYgKCFhcnJvdy5lcnJvciAmJiAhYXJyb3cuYWJvcnRlZCkge1xuICAgICAgICAgIGlmIChhcnJvdy5ub2RlLmFzeW5jKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5leHBlY3RlZFR5cGVQYXJhbWV0ZXJCZWZvcmVBc3luY0Fycm93RnVuY3Rpb24sIHtcbiAgICAgICAgICAgICAgYXQ6IHR5cGVQYXJhbWV0ZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYXJyb3cubm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycm93RXhwcmVzc2lvbiA9IGFycm93Lm5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoX2pzeDIgPSBqc3gpICE9IG51bGwgJiYgX2pzeDIubm9kZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0ganN4LmZhaWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIGpzeC5ub2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJyb3dFeHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBhcnJvdy5mYWlsU3RhdGU7XG4gICAgICAgIHJldHVybiBhcnJvd0V4cHJlc3Npb247XG4gICAgICB9XG5cbiAgICAgIGlmICgoX2pzeDMgPSBqc3gpICE9IG51bGwgJiYgX2pzeDMudGhyb3duKSB0aHJvdyBqc3guZXJyb3I7XG4gICAgICBpZiAoYXJyb3cudGhyb3duKSB0aHJvdyBhcnJvdy5lcnJvcjtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkVG9rZW5BZnRlclR5cGVQYXJhbWV0ZXIsIHtcbiAgICAgICAgYXQ6IHR5cGVQYXJhbWV0ZXJzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSk7XG4gIH1cblxuICBwYXJzZUFycm93KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJ5UGFyc2UoKCkgPT4ge1xuICAgICAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSB0cnVlO1xuICAgICAgICBjb25zdCB0eXBlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIFt0eXBlTm9kZS50eXBlQW5ub3RhdGlvbiwgbm9kZS5wcmVkaWNhdGVdID0gdGhpcy5mbG93UGFyc2VUeXBlQW5kUHJlZGljYXRlSW5pdGlhbGlzZXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBvbGROb0Fub25GdW5jdGlvblR5cGU7XG4gICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoKDE5KSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIHJldHVybiB0eXBlTm9kZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdC50aHJvd24pIHJldHVybiBudWxsO1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhpcy5zdGF0ZSA9IHJlc3VsdC5mYWlsU3RhdGU7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSByZXN1bHQubm9kZS50eXBlQW5ub3RhdGlvbiA/IHRoaXMuZmluaXNoTm9kZShyZXN1bHQubm9kZSwgXCJUeXBlQW5ub3RhdGlvblwiKSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQXJyb3cobm9kZSk7XG4gIH1cblxuICBzaG91bGRQYXJzZUFycm93KHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDE0KSB8fCBzdXBlci5zaG91bGRQYXJzZUFycm93KHBhcmFtcyk7XG4gIH1cblxuICBzZXRBcnJvd0Z1bmN0aW9uUGFyYW1ldGVycyhub2RlLCBwYXJhbXMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LmluZGV4T2Yobm9kZS5zdGFydCkgIT09IC0xKSB7XG4gICAgICBub2RlLnBhcmFtcyA9IHBhcmFtcztcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuc2V0QXJyb3dGdW5jdGlvblBhcmFtZXRlcnMobm9kZSwgcGFyYW1zKTtcbiAgICB9XG4gIH1cblxuICBjaGVja1BhcmFtcyhub2RlLCBhbGxvd0R1cGxpY2F0ZXMsIGlzQXJyb3dGdW5jdGlvbiwgc3RyaWN0TW9kZUNoYW5nZWQgPSB0cnVlKSB7XG4gICAgaWYgKGlzQXJyb3dGdW5jdGlvbiAmJiB0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQuaW5kZXhPZihub2RlLnN0YXJ0KSAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5pc1RoaXNQYXJhbShub2RlLnBhcmFtc1tpXSkgJiYgaSA+IDApIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbU11c3RCZUZpcnN0LCB7XG4gICAgICAgICAgYXQ6IG5vZGUucGFyYW1zW2ldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5jaGVja1BhcmFtcyhub2RlLCBhbGxvd0R1cGxpY2F0ZXMsIGlzQXJyb3dGdW5jdGlvbiwgc3RyaWN0TW9kZUNoYW5nZWQpO1xuICB9XG5cbiAgcGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KSB7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyAmJiB0aGlzLnN0YXRlLm5vQXJyb3dBdC5pbmRleE9mKHRoaXMuc3RhdGUuc3RhcnQpID09PSAtMSk7XG4gIH1cblxuICBwYXJzZVN1YnNjcmlwdHMoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gICAgaWYgKGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5zdGF0ZS5ub0Fycm93QXQuaW5kZXhPZihzdGFydFBvcykgIT09IC0xKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLmNhbGxlZSA9IGJhc2U7XG4gICAgICBub2RlLmFyZ3VtZW50cyA9IHN1cGVyLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoMTEsIGZhbHNlKTtcbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAgY29uc3QgYXJyb3cgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IHRoaXMucGFyc2VBc3luY0Fycm93V2l0aFR5cGVQYXJhbWV0ZXJzKHN0YXJ0UG9zLCBzdGFydExvYykgfHwgYWJvcnQoKSwgc3RhdGUpO1xuICAgICAgaWYgKCFhcnJvdy5lcnJvciAmJiAhYXJyb3cuYWJvcnRlZCkgcmV0dXJuIGFycm93Lm5vZGU7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKCgpID0+IHN1cGVyLnBhcnNlU3Vic2NyaXB0cyhiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMpLCBzdGF0ZSk7XG4gICAgICBpZiAocmVzdWx0Lm5vZGUgJiYgIXJlc3VsdC5lcnJvcikgcmV0dXJuIHJlc3VsdC5ub2RlO1xuXG4gICAgICBpZiAoYXJyb3cubm9kZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gYXJyb3cuZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4gYXJyb3cubm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdC5ub2RlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm5vZGU7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGFycm93LmVycm9yIHx8IHJlc3VsdC5lcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucGFyc2VTdWJzY3JpcHRzKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscyk7XG4gIH1cblxuICBwYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIHN1YnNjcmlwdFN0YXRlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTgpICYmIHRoaXMuaXNMb29rYWhlYWRUb2tlbl9sdCgpKSB7XG4gICAgICBzdWJzY3JpcHRTdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyID0gdHJ1ZTtcblxuICAgICAgaWYgKG5vQ2FsbHMpIHtcbiAgICAgICAgc3Vic2NyaXB0U3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLmNhbGxlZSA9IGJhc2U7XG4gICAgICBub2RlLnR5cGVBcmd1bWVudHMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cygxMSwgZmFsc2UpO1xuICAgICAgbm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hDYWxsRXhwcmVzc2lvbihub2RlLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMuc2hvdWxkUGFyc2VUeXBlcygpICYmIHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5jYWxsZWUgPSBiYXNlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cnlQYXJzZSgoKSA9PiB7XG4gICAgICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25DYWxsT3JOZXcoKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMTApO1xuICAgICAgICBub2RlLmFyZ3VtZW50cyA9IHN1cGVyLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoMTEsIGZhbHNlKTtcblxuICAgICAgICBpZiAoc3Vic2NyaXB0U3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcikge1xuICAgICAgICAgIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaENhbGxFeHByZXNzaW9uKG5vZGUsIHN1YnNjcmlwdFN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXN1bHQubm9kZSkge1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5ub2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIHN1YnNjcmlwdFN0YXRlKTtcbiAgfVxuXG4gIHBhcnNlTmV3Q2FsbGVlKG5vZGUpIHtcbiAgICBzdXBlci5wYXJzZU5ld0NhbGxlZShub2RlKTtcbiAgICBsZXQgdGFyZ3MgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VUeXBlcygpICYmIHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICB0YXJncyA9IHRoaXMudHJ5UGFyc2UoKCkgPT4gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbkNhbGxPck5ldygpKS5ub2RlO1xuICAgIH1cblxuICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRhcmdzO1xuICB9XG5cbiAgcGFyc2VBc3luY0Fycm93V2l0aFR5cGVQYXJhbWV0ZXJzKHN0YXJ0UG9zLCBzdGFydExvYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuICAgIGlmICghdGhpcy5wYXJzZUFycm93KG5vZGUpKSByZXR1cm47XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cblxuICByZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcblxuICAgIGlmIChjb2RlID09PSA0MiAmJiBuZXh0ID09PSA0NyAmJiB0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50KSB7XG4gICAgICB0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdXBlci5yZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSk7XG4gIH1cblxuICByZWFkVG9rZW5fcGlwZV9hbXAoY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcblxuICAgIGlmIChjb2RlID09PSAxMjQgJiYgbmV4dCA9PT0gMTI1KSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDksIDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1cGVyLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKTtcbiAgfVxuXG4gIHBhcnNlVG9wTGV2ZWwoZmlsZSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGZpbGVOb2RlID0gc3VwZXIucGFyc2VUb3BMZXZlbChmaWxlLCBwcm9ncmFtKTtcblxuICAgIGlmICh0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50KSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW50ZXJtaW5hdGVkRmxvd0NvbW1lbnQsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbGVOb2RlO1xuICB9XG5cbiAgc2tpcEJsb2NrQ29tbWVudCgpIHtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmbG93Q29tbWVudHNcIikgJiYgdGhpcy5za2lwRmxvd0NvbW1lbnQoKSkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShGbG93RXJyb3JzLk5lc3RlZEZsb3dDb21tZW50LCB7XG4gICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGFzRmxvd0NvbW1lbnRDb21wbGV0aW9uKCk7XG4gICAgICBjb25zdCBjb21tZW50U2tpcCA9IHRoaXMuc2tpcEZsb3dDb21tZW50KCk7XG5cbiAgICAgIGlmIChjb21tZW50U2tpcCkge1xuICAgICAgICB0aGlzLnN0YXRlLnBvcyArPSBjb21tZW50U2tpcDtcbiAgICAgICAgdGhpcy5zdGF0ZS5oYXNGbG93Q29tbWVudCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5oYXNGbG93Q29tbWVudCkge1xuICAgICAgY29uc3QgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi0vXCIsIHRoaXMuc3RhdGUucG9zICsgMik7XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZENvbW1lbnQsIHtcbiAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXRlLnBvcyA9IGVuZCArIDIgKyAzO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5za2lwQmxvY2tDb21tZW50KCk7XG4gIH1cblxuICBza2lwRmxvd0NvbW1lbnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcG9zXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgPSAyO1xuXG4gICAgd2hpbGUgKFszMiwgOV0uaW5jbHVkZXModGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UpKSkge1xuICAgICAgc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSsrO1xuICAgIH1cblxuICAgIGNvbnN0IGNoMiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgcG9zKTtcbiAgICBjb25zdCBjaDMgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIHBvcyArIDEpO1xuXG4gICAgaWYgKGNoMiA9PT0gNTggJiYgY2gzID09PSA1OCkge1xuICAgICAgcmV0dXJuIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyAyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlucHV0LnNsaWNlKHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyBwb3MsIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyBwb3MgKyAxMikgPT09IFwiZmxvdy1pbmNsdWRlXCIpIHtcbiAgICAgIHJldHVybiBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgMTI7XG4gICAgfVxuXG4gICAgaWYgKGNoMiA9PT0gNTggJiYgY2gzICE9PSA1OCkge1xuICAgICAgcmV0dXJuIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFzRmxvd0NvbW1lbnRDb21wbGV0aW9uKCkge1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMuc3RhdGUucG9zKTtcblxuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRDb21tZW50LCB7XG4gICAgICAgIGF0OiB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZsb3dFbnVtRXJyb3JCb29sZWFuTWVtYmVyTm90SW5pdGlhbGl6ZWQobG9jLCB7XG4gICAgZW51bU5hbWUsXG4gICAgbWVtYmVyTmFtZVxuICB9KSB7XG4gICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkVudW1Cb29sZWFuTWVtYmVyTm90SW5pdGlhbGl6ZWQsIHtcbiAgICAgIGF0OiBsb2MsXG4gICAgICBtZW1iZXJOYW1lLFxuICAgICAgZW51bU5hbWVcbiAgICB9KTtcbiAgfVxuXG4gIGZsb3dFbnVtRXJyb3JJbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXIobG9jLCBlbnVtQ29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLnJhaXNlKCFlbnVtQ29udGV4dC5leHBsaWNpdFR5cGUgPyBGbG93RXJyb3JzLkVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJVbmtub3duVHlwZSA6IGVudW1Db250ZXh0LmV4cGxpY2l0VHlwZSA9PT0gXCJzeW1ib2xcIiA/IEZsb3dFcnJvcnMuRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclN5bWJvbFR5cGUgOiBGbG93RXJyb3JzLkVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJQcmltYXJ5VHlwZSwgT2JqZWN0LmFzc2lnbih7XG4gICAgICBhdDogbG9jXG4gICAgfSwgZW51bUNvbnRleHQpKTtcbiAgfVxuXG4gIGZsb3dFbnVtRXJyb3JOdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZChsb2MsIHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lXG4gIH0pIHtcbiAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bU51bWJlck1lbWJlck5vdEluaXRpYWxpemVkLCB7XG4gICAgICBhdDogbG9jLFxuICAgICAgZW51bU5hbWUsXG4gICAgICBtZW1iZXJOYW1lXG4gICAgfSk7XG4gIH1cblxuICBmbG93RW51bUVycm9yU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0YWlsaXplZChub2RlLCB7XG4gICAgZW51bU5hbWVcbiAgfSkge1xuICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0YWlsaXplZCwge1xuICAgICAgYXQ6IG5vZGUsXG4gICAgICBlbnVtTmFtZVxuICAgIH0pO1xuICB9XG5cbiAgZmxvd0VudW1NZW1iZXJJbml0KCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcblxuICAgIGNvbnN0IGVuZE9mSW5pdCA9ICgpID0+IHRoaXMubWF0Y2goMTIpIHx8IHRoaXMubWF0Y2goOCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSAxMzA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsaXRlcmFsID0gdGhpcy5wYXJzZU51bWVyaWNMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuXG4gICAgICAgICAgaWYgKGVuZE9mSW5pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICBsb2M6IGxpdGVyYWwubG9jLnN0YXJ0LFxuICAgICAgICAgICAgICB2YWx1ZTogbGl0ZXJhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgICBsb2M6IHN0YXJ0TG9jXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIDEyOTpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxpdGVyYWwgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcblxuICAgICAgICAgIGlmIChlbmRPZkluaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgbG9jOiBsaXRlcmFsLmxvYy5zdGFydCxcbiAgICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFwiLFxuICAgICAgICAgICAgbG9jOiBzdGFydExvY1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgY2FzZSA4NTpcbiAgICAgIGNhc2UgODY6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsaXRlcmFsID0gdGhpcy5wYXJzZUJvb2xlYW5MaXRlcmFsKHRoaXMubWF0Y2goODUpKTtcblxuICAgICAgICAgIGlmIChlbmRPZkluaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIGxvYzogbGl0ZXJhbC5sb2Muc3RhcnQsXG4gICAgICAgICAgICAgIHZhbHVlOiBsaXRlcmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICAgIGxvYzogc3RhcnRMb2NcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgbG9jOiBzdGFydExvY1xuICAgICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGZsb3dFbnVtTWVtYmVyUmF3KCkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBjb25zdCBpbml0ID0gdGhpcy5lYXQoMjkpID8gdGhpcy5mbG93RW51bU1lbWJlckluaXQoKSA6IHtcbiAgICAgIHR5cGU6IFwibm9uZVwiLFxuICAgICAgbG9jXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICBpbml0XG4gICAgfTtcbiAgfVxuXG4gIGZsb3dFbnVtQ2hlY2tFeHBsaWNpdFR5cGVNaXNtYXRjaChsb2MsIGNvbnRleHQsIGV4cGVjdGVkVHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGV4cGxpY2l0VHlwZVxuICAgIH0gPSBjb250ZXh0O1xuXG4gICAgaWYgKGV4cGxpY2l0VHlwZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChleHBsaWNpdFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgdGhpcy5mbG93RW51bUVycm9ySW52YWxpZE1lbWJlckluaXRpYWxpemVyKGxvYywgY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgZmxvd0VudW1NZW1iZXJzKHtcbiAgICBlbnVtTmFtZSxcbiAgICBleHBsaWNpdFR5cGVcbiAgfSkge1xuICAgIGNvbnN0IHNlZW5OYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBtZW1iZXJzID0ge1xuICAgICAgYm9vbGVhbk1lbWJlcnM6IFtdLFxuICAgICAgbnVtYmVyTWVtYmVyczogW10sXG4gICAgICBzdHJpbmdNZW1iZXJzOiBbXSxcbiAgICAgIGRlZmF1bHRlZE1lbWJlcnM6IFtdXG4gICAgfTtcbiAgICBsZXQgaGFzVW5rbm93bk1lbWJlcnMgPSBmYWxzZTtcblxuICAgIHdoaWxlICghdGhpcy5tYXRjaCg4KSkge1xuICAgICAgaWYgKHRoaXMuZWF0KDIxKSkge1xuICAgICAgICBoYXNVbmtub3duTWVtYmVycyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtZW1iZXJOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGluaXRcbiAgICAgIH0gPSB0aGlzLmZsb3dFbnVtTWVtYmVyUmF3KCk7XG4gICAgICBjb25zdCBtZW1iZXJOYW1lID0gaWQubmFtZTtcblxuICAgICAgaWYgKG1lbWJlck5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgvXlthLXpdLy50ZXN0KG1lbWJlck5hbWUpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtSW52YWxpZE1lbWJlck5hbWUsIHtcbiAgICAgICAgICBhdDogaWQsXG4gICAgICAgICAgbWVtYmVyTmFtZSxcbiAgICAgICAgICBzdWdnZXN0aW9uOiBtZW1iZXJOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBtZW1iZXJOYW1lLnNsaWNlKDEpLFxuICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2Vlbk5hbWVzLmhhcyhtZW1iZXJOYW1lKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bUR1cGxpY2F0ZU1lbWJlck5hbWUsIHtcbiAgICAgICAgICBhdDogaWQsXG4gICAgICAgICAgbWVtYmVyTmFtZSxcbiAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2Vlbk5hbWVzLmFkZChtZW1iZXJOYW1lKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIGVudW1OYW1lLFxuICAgICAgICBleHBsaWNpdFR5cGUsXG4gICAgICAgIG1lbWJlck5hbWVcbiAgICAgIH07XG4gICAgICBtZW1iZXJOb2RlLmlkID0gaWQ7XG5cbiAgICAgIHN3aXRjaCAoaW5pdC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5mbG93RW51bUNoZWNrRXhwbGljaXRUeXBlTWlzbWF0Y2goaW5pdC5sb2MsIGNvbnRleHQsIFwiYm9vbGVhblwiKTtcbiAgICAgICAgICAgIG1lbWJlck5vZGUuaW5pdCA9IGluaXQudmFsdWU7XG4gICAgICAgICAgICBtZW1iZXJzLmJvb2xlYW5NZW1iZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlck5vZGUsIFwiRW51bUJvb2xlYW5NZW1iZXJcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZsb3dFbnVtQ2hlY2tFeHBsaWNpdFR5cGVNaXNtYXRjaChpbml0LmxvYywgY29udGV4dCwgXCJudW1iZXJcIik7XG4gICAgICAgICAgICBtZW1iZXJOb2RlLmluaXQgPSBpbml0LnZhbHVlO1xuICAgICAgICAgICAgbWVtYmVycy5udW1iZXJNZW1iZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlck5vZGUsIFwiRW51bU51bWJlck1lbWJlclwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZmxvd0VudW1DaGVja0V4cGxpY2l0VHlwZU1pc21hdGNoKGluaXQubG9jLCBjb250ZXh0LCBcInN0cmluZ1wiKTtcbiAgICAgICAgICAgIG1lbWJlck5vZGUuaW5pdCA9IGluaXQudmFsdWU7XG4gICAgICAgICAgICBtZW1iZXJzLnN0cmluZ01lbWJlcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUobWVtYmVyTm9kZSwgXCJFbnVtU3RyaW5nTWVtYmVyXCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFwiaW52YWxpZFwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmxvd0VudW1FcnJvckludmFsaWRNZW1iZXJJbml0aWFsaXplcihpbml0LmxvYywgY29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgc3dpdGNoIChleHBsaWNpdFR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dFbnVtRXJyb3JCb29sZWFuTWVtYmVyTm90SW5pdGlhbGl6ZWQoaW5pdC5sb2MsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dFbnVtRXJyb3JOdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZChpbml0LmxvYywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUobWVtYmVyTm9kZSwgXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5tYXRjaCg4KSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1lbWJlcnMsXG4gICAgICBoYXNVbmtub3duTWVtYmVyc1xuICAgIH07XG4gIH1cblxuICBmbG93RW51bVN0cmluZ01lbWJlcnMoaW5pdGlhbGl6ZWRNZW1iZXJzLCBkZWZhdWx0ZWRNZW1iZXJzLCB7XG4gICAgZW51bU5hbWVcbiAgfSkge1xuICAgIGlmIChpbml0aWFsaXplZE1lbWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdGVkTWVtYmVycztcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRlZE1lbWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbGl6ZWRNZW1iZXJzO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdGVkTWVtYmVycy5sZW5ndGggPiBpbml0aWFsaXplZE1lbWJlcnMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBpbml0aWFsaXplZE1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5mbG93RW51bUVycm9yU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0YWlsaXplZChtZW1iZXIsIHtcbiAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZmF1bHRlZE1lbWJlcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGRlZmF1bHRlZE1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5mbG93RW51bUVycm9yU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0YWlsaXplZChtZW1iZXIsIHtcbiAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluaXRpYWxpemVkTWVtYmVycztcbiAgICB9XG4gIH1cblxuICBmbG93RW51bVBhcnNlRXhwbGljaXRUeXBlKHtcbiAgICBlbnVtTmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmVhdENvbnRleHR1YWwoMTAxKSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoIXRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtSW52YWxpZEV4cGxpY2l0VHlwZVVua25vd25TdXBwbGllZCwge1xuICAgICAgICBhdDogdGhpcy5zdGF0ZS5zdGFydExvYyxcbiAgICAgICAgZW51bU5hbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodmFsdWUgIT09IFwiYm9vbGVhblwiICYmIHZhbHVlICE9PSBcIm51bWJlclwiICYmIHZhbHVlICE9PSBcInN0cmluZ1wiICYmIHZhbHVlICE9PSBcInN5bWJvbFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bUludmFsaWRFeHBsaWNpdFR5cGUsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2MsXG4gICAgICAgIGVudW1OYW1lLFxuICAgICAgICBpbnZhbGlkRW51bVR5cGU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmbG93RW51bUJvZHkobm9kZSwgaWQpIHtcbiAgICBjb25zdCBlbnVtTmFtZSA9IGlkLm5hbWU7XG4gICAgY29uc3QgbmFtZUxvYyA9IGlkLmxvYy5zdGFydDtcbiAgICBjb25zdCBleHBsaWNpdFR5cGUgPSB0aGlzLmZsb3dFbnVtUGFyc2VFeHBsaWNpdFR5cGUoe1xuICAgICAgZW51bU5hbWVcbiAgICB9KTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBjb25zdCB7XG4gICAgICBtZW1iZXJzLFxuICAgICAgaGFzVW5rbm93bk1lbWJlcnNcbiAgICB9ID0gdGhpcy5mbG93RW51bU1lbWJlcnMoe1xuICAgICAgZW51bU5hbWUsXG4gICAgICBleHBsaWNpdFR5cGVcbiAgICB9KTtcbiAgICBub2RlLmhhc1Vua25vd25NZW1iZXJzID0gaGFzVW5rbm93bk1lbWJlcnM7XG5cbiAgICBzd2l0Y2ggKGV4cGxpY2l0VHlwZSkge1xuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgbm9kZS5leHBsaWNpdFR5cGUgPSB0cnVlO1xuICAgICAgICBub2RlLm1lbWJlcnMgPSBtZW1iZXJzLmJvb2xlYW5NZW1iZXJzO1xuICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1Cb29sZWFuQm9keVwiKTtcblxuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBub2RlLmV4cGxpY2l0VHlwZSA9IHRydWU7XG4gICAgICAgIG5vZGUubWVtYmVycyA9IG1lbWJlcnMubnVtYmVyTWVtYmVycztcbiAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtTnVtYmVyQm9keVwiKTtcblxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBub2RlLmV4cGxpY2l0VHlwZSA9IHRydWU7XG4gICAgICAgIG5vZGUubWVtYmVycyA9IHRoaXMuZmxvd0VudW1TdHJpbmdNZW1iZXJzKG1lbWJlcnMuc3RyaW5nTWVtYmVycywgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLCB7XG4gICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bVN0cmluZ0JvZHlcIik7XG5cbiAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzO1xuICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1TeW1ib2xCb2R5XCIpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgZW1wdHkgPSAoKSA9PiB7XG4gICAgICAgICAgICBub2RlLm1lbWJlcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1TdHJpbmdCb2R5XCIpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBub2RlLmV4cGxpY2l0VHlwZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGJvb2xzTGVuID0gbWVtYmVycy5ib29sZWFuTWVtYmVycy5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgbnVtc0xlbiA9IG1lbWJlcnMubnVtYmVyTWVtYmVycy5sZW5ndGg7XG4gICAgICAgICAgY29uc3Qgc3Ryc0xlbiA9IG1lbWJlcnMuc3RyaW5nTWVtYmVycy5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdGVkTGVuID0gbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLmxlbmd0aDtcblxuICAgICAgICAgIGlmICghYm9vbHNMZW4gJiYgIW51bXNMZW4gJiYgIXN0cnNMZW4gJiYgIWRlZmF1bHRlZExlbikge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghYm9vbHNMZW4gJiYgIW51bXNMZW4pIHtcbiAgICAgICAgICAgIG5vZGUubWVtYmVycyA9IHRoaXMuZmxvd0VudW1TdHJpbmdNZW1iZXJzKG1lbWJlcnMuc3RyaW5nTWVtYmVycywgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLCB7XG4gICAgICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1TdHJpbmdCb2R5XCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW51bXNMZW4gJiYgIXN0cnNMZW4gJiYgYm9vbHNMZW4gPj0gZGVmYXVsdGVkTGVuKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5mbG93RW51bUVycm9yQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkKG1lbWJlci5sb2Muc3RhcnQsIHtcbiAgICAgICAgICAgICAgICBlbnVtTmFtZSxcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBtZW1iZXIuaWQubmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5ib29sZWFuTWVtYmVycztcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1Cb29sZWFuQm9keVwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFib29sc0xlbiAmJiAhc3Ryc0xlbiAmJiBudW1zTGVuID49IGRlZmF1bHRlZExlbikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmxvd0VudW1FcnJvck51bWJlck1lbWJlck5vdEluaXRpYWxpemVkKG1lbWJlci5sb2Muc3RhcnQsIHtcbiAgICAgICAgICAgICAgICBlbnVtTmFtZSxcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBtZW1iZXIuaWQubmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5udW1iZXJNZW1iZXJzO1xuICAgICAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bU51bWJlckJvZHlcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtSW5jb25zaXN0ZW50TWVtYmVyVmFsdWVzLCB7XG4gICAgICAgICAgICAgIGF0OiBuYW1lTG9jLFxuICAgICAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmbG93UGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBub2RlLmlkID0gaWQ7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5mbG93RW51bUJvZHkodGhpcy5zdGFydE5vZGUoKSwgaWQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtRGVjbGFyYXRpb25cIik7XG4gIH1cblxuICBpc0xvb2thaGVhZFRva2VuX2x0KCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG5cbiAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpID09PSA2MCkge1xuICAgICAgY29uc3QgYWZ0ZXJOZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQgKyAxKTtcbiAgICAgIHJldHVybiBhZnRlck5leHQgIT09IDYwICYmIGFmdGVyTmV4dCAhPT0gNjE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbWF5YmVVbndyYXBUeXBlQ2FzdEV4cHJlc3Npb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgPyBub2RlLmV4cHJlc3Npb24gOiBub2RlO1xuICB9XG5cbn0pO1xuXG5jb25zdCBlbnRpdGllcyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBxdW90OiBcIlxcdTAwMjJcIixcbiAgYW1wOiBcIiZcIixcbiAgYXBvczogXCJcXHUwMDI3XCIsXG4gIGx0OiBcIjxcIixcbiAgZ3Q6IFwiPlwiLFxuICBuYnNwOiBcIlxcdTAwQTBcIixcbiAgaWV4Y2w6IFwiXFx1MDBBMVwiLFxuICBjZW50OiBcIlxcdTAwQTJcIixcbiAgcG91bmQ6IFwiXFx1MDBBM1wiLFxuICBjdXJyZW46IFwiXFx1MDBBNFwiLFxuICB5ZW46IFwiXFx1MDBBNVwiLFxuICBicnZiYXI6IFwiXFx1MDBBNlwiLFxuICBzZWN0OiBcIlxcdTAwQTdcIixcbiAgdW1sOiBcIlxcdTAwQThcIixcbiAgY29weTogXCJcXHUwMEE5XCIsXG4gIG9yZGY6IFwiXFx1MDBBQVwiLFxuICBsYXF1bzogXCJcXHUwMEFCXCIsXG4gIG5vdDogXCJcXHUwMEFDXCIsXG4gIHNoeTogXCJcXHUwMEFEXCIsXG4gIHJlZzogXCJcXHUwMEFFXCIsXG4gIG1hY3I6IFwiXFx1MDBBRlwiLFxuICBkZWc6IFwiXFx1MDBCMFwiLFxuICBwbHVzbW46IFwiXFx1MDBCMVwiLFxuICBzdXAyOiBcIlxcdTAwQjJcIixcbiAgc3VwMzogXCJcXHUwMEIzXCIsXG4gIGFjdXRlOiBcIlxcdTAwQjRcIixcbiAgbWljcm86IFwiXFx1MDBCNVwiLFxuICBwYXJhOiBcIlxcdTAwQjZcIixcbiAgbWlkZG90OiBcIlxcdTAwQjdcIixcbiAgY2VkaWw6IFwiXFx1MDBCOFwiLFxuICBzdXAxOiBcIlxcdTAwQjlcIixcbiAgb3JkbTogXCJcXHUwMEJBXCIsXG4gIHJhcXVvOiBcIlxcdTAwQkJcIixcbiAgZnJhYzE0OiBcIlxcdTAwQkNcIixcbiAgZnJhYzEyOiBcIlxcdTAwQkRcIixcbiAgZnJhYzM0OiBcIlxcdTAwQkVcIixcbiAgaXF1ZXN0OiBcIlxcdTAwQkZcIixcbiAgQWdyYXZlOiBcIlxcdTAwQzBcIixcbiAgQWFjdXRlOiBcIlxcdTAwQzFcIixcbiAgQWNpcmM6IFwiXFx1MDBDMlwiLFxuICBBdGlsZGU6IFwiXFx1MDBDM1wiLFxuICBBdW1sOiBcIlxcdTAwQzRcIixcbiAgQXJpbmc6IFwiXFx1MDBDNVwiLFxuICBBRWxpZzogXCJcXHUwMEM2XCIsXG4gIENjZWRpbDogXCJcXHUwMEM3XCIsXG4gIEVncmF2ZTogXCJcXHUwMEM4XCIsXG4gIEVhY3V0ZTogXCJcXHUwMEM5XCIsXG4gIEVjaXJjOiBcIlxcdTAwQ0FcIixcbiAgRXVtbDogXCJcXHUwMENCXCIsXG4gIElncmF2ZTogXCJcXHUwMENDXCIsXG4gIElhY3V0ZTogXCJcXHUwMENEXCIsXG4gIEljaXJjOiBcIlxcdTAwQ0VcIixcbiAgSXVtbDogXCJcXHUwMENGXCIsXG4gIEVUSDogXCJcXHUwMEQwXCIsXG4gIE50aWxkZTogXCJcXHUwMEQxXCIsXG4gIE9ncmF2ZTogXCJcXHUwMEQyXCIsXG4gIE9hY3V0ZTogXCJcXHUwMEQzXCIsXG4gIE9jaXJjOiBcIlxcdTAwRDRcIixcbiAgT3RpbGRlOiBcIlxcdTAwRDVcIixcbiAgT3VtbDogXCJcXHUwMEQ2XCIsXG4gIHRpbWVzOiBcIlxcdTAwRDdcIixcbiAgT3NsYXNoOiBcIlxcdTAwRDhcIixcbiAgVWdyYXZlOiBcIlxcdTAwRDlcIixcbiAgVWFjdXRlOiBcIlxcdTAwREFcIixcbiAgVWNpcmM6IFwiXFx1MDBEQlwiLFxuICBVdW1sOiBcIlxcdTAwRENcIixcbiAgWWFjdXRlOiBcIlxcdTAwRERcIixcbiAgVEhPUk46IFwiXFx1MDBERVwiLFxuICBzemxpZzogXCJcXHUwMERGXCIsXG4gIGFncmF2ZTogXCJcXHUwMEUwXCIsXG4gIGFhY3V0ZTogXCJcXHUwMEUxXCIsXG4gIGFjaXJjOiBcIlxcdTAwRTJcIixcbiAgYXRpbGRlOiBcIlxcdTAwRTNcIixcbiAgYXVtbDogXCJcXHUwMEU0XCIsXG4gIGFyaW5nOiBcIlxcdTAwRTVcIixcbiAgYWVsaWc6IFwiXFx1MDBFNlwiLFxuICBjY2VkaWw6IFwiXFx1MDBFN1wiLFxuICBlZ3JhdmU6IFwiXFx1MDBFOFwiLFxuICBlYWN1dGU6IFwiXFx1MDBFOVwiLFxuICBlY2lyYzogXCJcXHUwMEVBXCIsXG4gIGV1bWw6IFwiXFx1MDBFQlwiLFxuICBpZ3JhdmU6IFwiXFx1MDBFQ1wiLFxuICBpYWN1dGU6IFwiXFx1MDBFRFwiLFxuICBpY2lyYzogXCJcXHUwMEVFXCIsXG4gIGl1bWw6IFwiXFx1MDBFRlwiLFxuICBldGg6IFwiXFx1MDBGMFwiLFxuICBudGlsZGU6IFwiXFx1MDBGMVwiLFxuICBvZ3JhdmU6IFwiXFx1MDBGMlwiLFxuICBvYWN1dGU6IFwiXFx1MDBGM1wiLFxuICBvY2lyYzogXCJcXHUwMEY0XCIsXG4gIG90aWxkZTogXCJcXHUwMEY1XCIsXG4gIG91bWw6IFwiXFx1MDBGNlwiLFxuICBkaXZpZGU6IFwiXFx1MDBGN1wiLFxuICBvc2xhc2g6IFwiXFx1MDBGOFwiLFxuICB1Z3JhdmU6IFwiXFx1MDBGOVwiLFxuICB1YWN1dGU6IFwiXFx1MDBGQVwiLFxuICB1Y2lyYzogXCJcXHUwMEZCXCIsXG4gIHV1bWw6IFwiXFx1MDBGQ1wiLFxuICB5YWN1dGU6IFwiXFx1MDBGRFwiLFxuICB0aG9ybjogXCJcXHUwMEZFXCIsXG4gIHl1bWw6IFwiXFx1MDBGRlwiLFxuICBPRWxpZzogXCJcXHUwMTUyXCIsXG4gIG9lbGlnOiBcIlxcdTAxNTNcIixcbiAgU2Nhcm9uOiBcIlxcdTAxNjBcIixcbiAgc2Nhcm9uOiBcIlxcdTAxNjFcIixcbiAgWXVtbDogXCJcXHUwMTc4XCIsXG4gIGZub2Y6IFwiXFx1MDE5MlwiLFxuICBjaXJjOiBcIlxcdTAyQzZcIixcbiAgdGlsZGU6IFwiXFx1MDJEQ1wiLFxuICBBbHBoYTogXCJcXHUwMzkxXCIsXG4gIEJldGE6IFwiXFx1MDM5MlwiLFxuICBHYW1tYTogXCJcXHUwMzkzXCIsXG4gIERlbHRhOiBcIlxcdTAzOTRcIixcbiAgRXBzaWxvbjogXCJcXHUwMzk1XCIsXG4gIFpldGE6IFwiXFx1MDM5NlwiLFxuICBFdGE6IFwiXFx1MDM5N1wiLFxuICBUaGV0YTogXCJcXHUwMzk4XCIsXG4gIElvdGE6IFwiXFx1MDM5OVwiLFxuICBLYXBwYTogXCJcXHUwMzlBXCIsXG4gIExhbWJkYTogXCJcXHUwMzlCXCIsXG4gIE11OiBcIlxcdTAzOUNcIixcbiAgTnU6IFwiXFx1MDM5RFwiLFxuICBYaTogXCJcXHUwMzlFXCIsXG4gIE9taWNyb246IFwiXFx1MDM5RlwiLFxuICBQaTogXCJcXHUwM0EwXCIsXG4gIFJobzogXCJcXHUwM0ExXCIsXG4gIFNpZ21hOiBcIlxcdTAzQTNcIixcbiAgVGF1OiBcIlxcdTAzQTRcIixcbiAgVXBzaWxvbjogXCJcXHUwM0E1XCIsXG4gIFBoaTogXCJcXHUwM0E2XCIsXG4gIENoaTogXCJcXHUwM0E3XCIsXG4gIFBzaTogXCJcXHUwM0E4XCIsXG4gIE9tZWdhOiBcIlxcdTAzQTlcIixcbiAgYWxwaGE6IFwiXFx1MDNCMVwiLFxuICBiZXRhOiBcIlxcdTAzQjJcIixcbiAgZ2FtbWE6IFwiXFx1MDNCM1wiLFxuICBkZWx0YTogXCJcXHUwM0I0XCIsXG4gIGVwc2lsb246IFwiXFx1MDNCNVwiLFxuICB6ZXRhOiBcIlxcdTAzQjZcIixcbiAgZXRhOiBcIlxcdTAzQjdcIixcbiAgdGhldGE6IFwiXFx1MDNCOFwiLFxuICBpb3RhOiBcIlxcdTAzQjlcIixcbiAga2FwcGE6IFwiXFx1MDNCQVwiLFxuICBsYW1iZGE6IFwiXFx1MDNCQlwiLFxuICBtdTogXCJcXHUwM0JDXCIsXG4gIG51OiBcIlxcdTAzQkRcIixcbiAgeGk6IFwiXFx1MDNCRVwiLFxuICBvbWljcm9uOiBcIlxcdTAzQkZcIixcbiAgcGk6IFwiXFx1MDNDMFwiLFxuICByaG86IFwiXFx1MDNDMVwiLFxuICBzaWdtYWY6IFwiXFx1MDNDMlwiLFxuICBzaWdtYTogXCJcXHUwM0MzXCIsXG4gIHRhdTogXCJcXHUwM0M0XCIsXG4gIHVwc2lsb246IFwiXFx1MDNDNVwiLFxuICBwaGk6IFwiXFx1MDNDNlwiLFxuICBjaGk6IFwiXFx1MDNDN1wiLFxuICBwc2k6IFwiXFx1MDNDOFwiLFxuICBvbWVnYTogXCJcXHUwM0M5XCIsXG4gIHRoZXRhc3ltOiBcIlxcdTAzRDFcIixcbiAgdXBzaWg6IFwiXFx1MDNEMlwiLFxuICBwaXY6IFwiXFx1MDNENlwiLFxuICBlbnNwOiBcIlxcdTIwMDJcIixcbiAgZW1zcDogXCJcXHUyMDAzXCIsXG4gIHRoaW5zcDogXCJcXHUyMDA5XCIsXG4gIHp3bmo6IFwiXFx1MjAwQ1wiLFxuICB6d2o6IFwiXFx1MjAwRFwiLFxuICBscm06IFwiXFx1MjAwRVwiLFxuICBybG06IFwiXFx1MjAwRlwiLFxuICBuZGFzaDogXCJcXHUyMDEzXCIsXG4gIG1kYXNoOiBcIlxcdTIwMTRcIixcbiAgbHNxdW86IFwiXFx1MjAxOFwiLFxuICByc3F1bzogXCJcXHUyMDE5XCIsXG4gIHNicXVvOiBcIlxcdTIwMUFcIixcbiAgbGRxdW86IFwiXFx1MjAxQ1wiLFxuICByZHF1bzogXCJcXHUyMDFEXCIsXG4gIGJkcXVvOiBcIlxcdTIwMUVcIixcbiAgZGFnZ2VyOiBcIlxcdTIwMjBcIixcbiAgRGFnZ2VyOiBcIlxcdTIwMjFcIixcbiAgYnVsbDogXCJcXHUyMDIyXCIsXG4gIGhlbGxpcDogXCJcXHUyMDI2XCIsXG4gIHBlcm1pbDogXCJcXHUyMDMwXCIsXG4gIHByaW1lOiBcIlxcdTIwMzJcIixcbiAgUHJpbWU6IFwiXFx1MjAzM1wiLFxuICBsc2FxdW86IFwiXFx1MjAzOVwiLFxuICByc2FxdW86IFwiXFx1MjAzQVwiLFxuICBvbGluZTogXCJcXHUyMDNFXCIsXG4gIGZyYXNsOiBcIlxcdTIwNDRcIixcbiAgZXVybzogXCJcXHUyMEFDXCIsXG4gIGltYWdlOiBcIlxcdTIxMTFcIixcbiAgd2VpZXJwOiBcIlxcdTIxMThcIixcbiAgcmVhbDogXCJcXHUyMTFDXCIsXG4gIHRyYWRlOiBcIlxcdTIxMjJcIixcbiAgYWxlZnN5bTogXCJcXHUyMTM1XCIsXG4gIGxhcnI6IFwiXFx1MjE5MFwiLFxuICB1YXJyOiBcIlxcdTIxOTFcIixcbiAgcmFycjogXCJcXHUyMTkyXCIsXG4gIGRhcnI6IFwiXFx1MjE5M1wiLFxuICBoYXJyOiBcIlxcdTIxOTRcIixcbiAgY3JhcnI6IFwiXFx1MjFCNVwiLFxuICBsQXJyOiBcIlxcdTIxRDBcIixcbiAgdUFycjogXCJcXHUyMUQxXCIsXG4gIHJBcnI6IFwiXFx1MjFEMlwiLFxuICBkQXJyOiBcIlxcdTIxRDNcIixcbiAgaEFycjogXCJcXHUyMUQ0XCIsXG4gIGZvcmFsbDogXCJcXHUyMjAwXCIsXG4gIHBhcnQ6IFwiXFx1MjIwMlwiLFxuICBleGlzdDogXCJcXHUyMjAzXCIsXG4gIGVtcHR5OiBcIlxcdTIyMDVcIixcbiAgbmFibGE6IFwiXFx1MjIwN1wiLFxuICBpc2luOiBcIlxcdTIyMDhcIixcbiAgbm90aW46IFwiXFx1MjIwOVwiLFxuICBuaTogXCJcXHUyMjBCXCIsXG4gIHByb2Q6IFwiXFx1MjIwRlwiLFxuICBzdW06IFwiXFx1MjIxMVwiLFxuICBtaW51czogXCJcXHUyMjEyXCIsXG4gIGxvd2FzdDogXCJcXHUyMjE3XCIsXG4gIHJhZGljOiBcIlxcdTIyMUFcIixcbiAgcHJvcDogXCJcXHUyMjFEXCIsXG4gIGluZmluOiBcIlxcdTIyMUVcIixcbiAgYW5nOiBcIlxcdTIyMjBcIixcbiAgYW5kOiBcIlxcdTIyMjdcIixcbiAgb3I6IFwiXFx1MjIyOFwiLFxuICBjYXA6IFwiXFx1MjIyOVwiLFxuICBjdXA6IFwiXFx1MjIyQVwiLFxuICBpbnQ6IFwiXFx1MjIyQlwiLFxuICB0aGVyZTQ6IFwiXFx1MjIzNFwiLFxuICBzaW06IFwiXFx1MjIzQ1wiLFxuICBjb25nOiBcIlxcdTIyNDVcIixcbiAgYXN5bXA6IFwiXFx1MjI0OFwiLFxuICBuZTogXCJcXHUyMjYwXCIsXG4gIGVxdWl2OiBcIlxcdTIyNjFcIixcbiAgbGU6IFwiXFx1MjI2NFwiLFxuICBnZTogXCJcXHUyMjY1XCIsXG4gIHN1YjogXCJcXHUyMjgyXCIsXG4gIHN1cDogXCJcXHUyMjgzXCIsXG4gIG5zdWI6IFwiXFx1MjI4NFwiLFxuICBzdWJlOiBcIlxcdTIyODZcIixcbiAgc3VwZTogXCJcXHUyMjg3XCIsXG4gIG9wbHVzOiBcIlxcdTIyOTVcIixcbiAgb3RpbWVzOiBcIlxcdTIyOTdcIixcbiAgcGVycDogXCJcXHUyMkE1XCIsXG4gIHNkb3Q6IFwiXFx1MjJDNVwiLFxuICBsY2VpbDogXCJcXHUyMzA4XCIsXG4gIHJjZWlsOiBcIlxcdTIzMDlcIixcbiAgbGZsb29yOiBcIlxcdTIzMEFcIixcbiAgcmZsb29yOiBcIlxcdTIzMEJcIixcbiAgbGFuZzogXCJcXHUyMzI5XCIsXG4gIHJhbmc6IFwiXFx1MjMyQVwiLFxuICBsb3o6IFwiXFx1MjVDQVwiLFxuICBzcGFkZXM6IFwiXFx1MjY2MFwiLFxuICBjbHViczogXCJcXHUyNjYzXCIsXG4gIGhlYXJ0czogXCJcXHUyNjY1XCIsXG4gIGRpYW1zOiBcIlxcdTI2NjZcIlxufTtcblxuY29uc3QgSnN4RXJyb3JzID0gUGFyc2VFcnJvckVudW1ganN4YCh7XG4gIEF0dHJpYnV0ZUlzRW1wdHk6IFwiSlNYIGF0dHJpYnV0ZXMgbXVzdCBvbmx5IGJlIGFzc2lnbmVkIGEgbm9uLWVtcHR5IGV4cHJlc3Npb24uXCIsXG4gIE1pc3NpbmdDbG9zaW5nVGFnRWxlbWVudDogKHtcbiAgICBvcGVuaW5nVGFnTmFtZVxuICB9KSA9PiBgRXhwZWN0ZWQgY29ycmVzcG9uZGluZyBKU1ggY2xvc2luZyB0YWcgZm9yIDwke29wZW5pbmdUYWdOYW1lfT4uYCxcbiAgTWlzc2luZ0Nsb3NpbmdUYWdGcmFnbWVudDogXCJFeHBlY3RlZCBjb3JyZXNwb25kaW5nIEpTWCBjbG9zaW5nIHRhZyBmb3IgPD4uXCIsXG4gIFVuZXhwZWN0ZWRTZXF1ZW5jZUV4cHJlc3Npb246IFwiU2VxdWVuY2UgZXhwcmVzc2lvbnMgY2Fubm90IGJlIGRpcmVjdGx5IG5lc3RlZCBpbnNpZGUgSlNYLiBEaWQgeW91IG1lYW4gdG8gd3JhcCBpdCBpbiBwYXJlbnRoZXNlcyAoLi4uKT9cIixcbiAgVW5leHBlY3RlZFRva2VuOiAoe1xuICAgIHVuZXhwZWN0ZWQsXG4gICAgSFRNTEVudGl0eVxuICB9KSA9PiBgVW5leHBlY3RlZCB0b2tlbiBcXGAke3VuZXhwZWN0ZWR9XFxgLiBEaWQgeW91IG1lYW4gXFxgJHtIVE1MRW50aXR5fVxcYCBvciBcXGB7JyR7dW5leHBlY3RlZH0nfVxcYD9gLFxuICBVbnN1cHBvcnRlZEpzeFZhbHVlOiBcIkpTWCB2YWx1ZSBzaG91bGQgYmUgZWl0aGVyIGFuIGV4cHJlc3Npb24gb3IgYSBxdW90ZWQgSlNYIHRleHQuXCIsXG4gIFVudGVybWluYXRlZEpzeENvbnRlbnQ6IFwiVW50ZXJtaW5hdGVkIEpTWCBjb250ZW50cy5cIixcbiAgVW53cmFwcGVkQWRqYWNlbnRKU1hFbGVtZW50czogXCJBZGphY2VudCBKU1ggZWxlbWVudHMgbXVzdCBiZSB3cmFwcGVkIGluIGFuIGVuY2xvc2luZyB0YWcuIERpZCB5b3Ugd2FudCBhIEpTWCBmcmFnbWVudCA8Pi4uLjwvPj9cIlxufSk7XG5cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPyBvYmplY3QudHlwZSA9PT0gXCJKU1hPcGVuaW5nRnJhZ21lbnRcIiB8fCBvYmplY3QudHlwZSA9PT0gXCJKU1hDbG9zaW5nRnJhZ21lbnRcIiA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdCkge1xuICBpZiAob2JqZWN0LnR5cGUgPT09IFwiSlNYSWRlbnRpZmllclwiKSB7XG4gICAgcmV0dXJuIG9iamVjdC5uYW1lO1xuICB9XG5cbiAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIpIHtcbiAgICByZXR1cm4gb2JqZWN0Lm5hbWVzcGFjZS5uYW1lICsgXCI6XCIgKyBvYmplY3QubmFtZS5uYW1lO1xuICB9XG5cbiAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIHJldHVybiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5vYmplY3QpICsgXCIuXCIgKyBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5wcm9wZXJ0eSk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGhhZCB1bmV4cGVjdGVkIHR5cGU6IFwiICsgb2JqZWN0LnR5cGUpO1xufVxuXG52YXIganN4ID0gKHN1cGVyQ2xhc3MgPT4gY2xhc3MgSlNYUGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAganN4UmVhZFRva2VuKCkge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGxldCBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShKc3hFcnJvcnMuVW50ZXJtaW5hdGVkSnN4Q29udGVudCwge1xuICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG5cbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUucG9zID09PSB0aGlzLnN0YXRlLnN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDYwICYmIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50KSB7XG4gICAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKDEzOCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdXBlci5nZXRUb2tlbkZyb21Db2RlKGNoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4oMTM3LCBvdXQpO1xuXG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICAgIG91dCArPSB0aGlzLmpzeFJlYWRFbnRpdHkoKTtcbiAgICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgY2FzZSAxMjU6XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuanN4UmVhZE5ld0xpbmUodHJ1ZSk7XG4gICAgICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAganN4UmVhZE5ld0xpbmUobm9ybWFsaXplQ1JMRikge1xuICAgIGNvbnN0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICBsZXQgb3V0O1xuICAgICsrdGhpcy5zdGF0ZS5wb3M7XG5cbiAgICBpZiAoY2ggPT09IDEzICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcykgPT09IDEwKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgb3V0ID0gbm9ybWFsaXplQ1JMRiA/IFwiXFxuXCIgOiBcIlxcclxcblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICB9XG5cbiAgICArK3RoaXMuc3RhdGUuY3VyTGluZTtcbiAgICB0aGlzLnN0YXRlLmxpbmVTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBqc3hSZWFkU3RyaW5nKHF1b3RlKSB7XG4gICAgbGV0IG91dCA9IFwiXCI7XG4gICAgbGV0IGNodW5rU3RhcnQgPSArK3RoaXMuc3RhdGUucG9zO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucG9zID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZFN0cmluZywge1xuICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IHF1b3RlKSBicmVhaztcblxuICAgICAgaWYgKGNoID09PSAzOCkge1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLmpzeFJlYWRFbnRpdHkoKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgb3V0ICs9IHRoaXMuanN4UmVhZE5ld0xpbmUoZmFsc2UpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuICAgIH1cblxuICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKyspO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKDEyOSwgb3V0KTtcbiAgfVxuXG4gIGpzeFJlYWRFbnRpdHkoKSB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSArK3RoaXMuc3RhdGUucG9zO1xuXG4gICAgaWYgKHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpID09PSAzNSkge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIGxldCByYWRpeCA9IDEwO1xuXG4gICAgICBpZiAodGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykgPT09IDEyMCkge1xuICAgICAgICByYWRpeCA9IDE2O1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb2RlUG9pbnQgPSB0aGlzLnJlYWRJbnQocmFkaXgsIHVuZGVmaW5lZCwgZmFsc2UsIFwiYmFpbFwiKTtcblxuICAgICAgaWYgKGNvZGVQb2ludCAhPT0gbnVsbCAmJiB0aGlzLmNvZGVQb2ludEF0UG9zKHRoaXMuc3RhdGUucG9zKSA9PT0gNTkpIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICBsZXQgc2VtaSA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSAoY291bnQrKyA8IDEwICYmIHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGggJiYgIShzZW1pID0gdGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykgPT0gNTkpKSB7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZW1pKSB7XG4gICAgICAgIGNvbnN0IGRlc2MgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0UG9zLCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIGNvbnN0IGVudGl0eSA9IGVudGl0aWVzW2Rlc2NdO1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuXG4gICAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBzdGFydFBvcztcbiAgICByZXR1cm4gXCImXCI7XG4gIH1cblxuICBqc3hSZWFkV29yZCgpIHtcbiAgICBsZXQgY2g7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcblxuICAgIGRvIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5zdGF0ZS5wb3MpO1xuICAgIH0gd2hpbGUgKGlzSWRlbnRpZmllckNoYXIoY2gpIHx8IGNoID09PSA0NSk7XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbigxMzYsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMuc3RhdGUucG9zKSk7XG4gIH1cblxuICBqc3hQYXJzZUlkZW50aWZpZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCgxMzYpKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAodG9rZW5Jc0tleXdvcmQodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgbm9kZS5uYW1lID0gdG9rZW5MYWJlbE5hbWUodGhpcy5zdGF0ZS50eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWElkZW50aWZpZXJcIik7XG4gIH1cblxuICBqc3hQYXJzZU5hbWVzcGFjZWROYW1lKCkge1xuICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7XG4gICAgaWYgKCF0aGlzLmVhdCgxNCkpIHJldHVybiBuYW1lO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5uYW1lc3BhY2UgPSBuYW1lO1xuICAgIG5vZGUubmFtZSA9IHRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIpO1xuICB9XG5cbiAganN4UGFyc2VFbGVtZW50TmFtZSgpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCBub2RlID0gdGhpcy5qc3hQYXJzZU5hbWVzcGFjZWROYW1lKCk7XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHdoaWxlICh0aGlzLmVhdCgxNikpIHtcbiAgICAgIGNvbnN0IG5ld05vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBuZXdOb2RlLm9iamVjdCA9IG5vZGU7XG4gICAgICBuZXdOb2RlLnByb3BlcnR5ID0gdGhpcy5qc3hQYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIG5vZGUgPSB0aGlzLmZpbmlzaE5vZGUobmV3Tm9kZSwgXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAganN4UGFyc2VBdHRyaWJ1dGVWYWx1ZSgpIHtcbiAgICBsZXQgbm9kZTtcblxuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLnNldENvbnRleHQodHlwZXMuYnJhY2UpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgbm9kZSA9IHRoaXMuanN4UGFyc2VFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUsIHR5cGVzLmpfb1RhZyk7XG5cbiAgICAgICAgaWYgKG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSBcIkpTWEVtcHR5RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShKc3hFcnJvcnMuQXR0cmlidXRlSXNFbXB0eSwge1xuICAgICAgICAgICAgYXQ6IG5vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICBjYXNlIDEzODpcbiAgICAgIGNhc2UgMTI5OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoSnN4RXJyb3JzLlVuc3VwcG9ydGVkSnN4VmFsdWUsIHtcbiAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5zdGFydExvY1xuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBqc3hQYXJzZUVtcHR5RXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdCh0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MuaW5kZXgsIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KG5vZGUsIFwiSlNYRW1wdHlFeHByZXNzaW9uXCIsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICB9XG5cbiAganN4UGFyc2VTcHJlYWRDaGlsZChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLnNldENvbnRleHQodHlwZXMual9vVGFnKTtcbiAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWFNwcmVhZENoaWxkXCIpO1xuICB9XG5cbiAganN4UGFyc2VFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUsIHByZXZpb3VzQ29udGV4dCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDgpKSB7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLmpzeFBhcnNlRW1wdHlFeHByZXNzaW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB9XG5cbiAgICB0aGlzLnNldENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIik7XG4gIH1cblxuICBqc3hQYXJzZUF0dHJpYnV0ZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIGlmICh0aGlzLm1hdGNoKDUpKSB7XG4gICAgICB0aGlzLnNldENvbnRleHQodHlwZXMuYnJhY2UpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdCgyMSk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgICAgdGhpcy5zZXRDb250ZXh0KHR5cGVzLmpfb1RhZyk7XG4gICAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IHRydWU7XG4gICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIik7XG4gICAgfVxuXG4gICAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZU5hbWVzcGFjZWROYW1lKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMuZWF0KDI5KSA/IHRoaXMuanN4UGFyc2VBdHRyaWJ1dGVWYWx1ZSgpIDogbnVsbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYQXR0cmlidXRlXCIpO1xuICB9XG5cbiAganN4UGFyc2VPcGVuaW5nRWxlbWVudEF0KHN0YXJ0UG9zLCBzdGFydExvYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG5cbiAgICBpZiAodGhpcy5lYXQoMTM5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWE9wZW5pbmdGcmFnbWVudFwiKTtcbiAgICB9XG5cbiAgICBub2RlLm5hbWUgPSB0aGlzLmpzeFBhcnNlRWxlbWVudE5hbWUoKTtcbiAgICByZXR1cm4gdGhpcy5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpO1xuICB9XG5cbiAganN4UGFyc2VPcGVuaW5nRWxlbWVudEFmdGVyTmFtZShub2RlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xuXG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDU2KSAmJiAhdGhpcy5tYXRjaCgxMzkpKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2godGhpcy5qc3hQYXJzZUF0dHJpYnV0ZSgpKTtcbiAgICB9XG5cbiAgICBub2RlLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgIG5vZGUuc2VsZkNsb3NpbmcgPSB0aGlzLmVhdCg1Nik7XG4gICAgdGhpcy5leHBlY3QoMTM5KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYT3BlbmluZ0VsZW1lbnRcIik7XG4gIH1cblxuICBqc3hQYXJzZUNsb3NpbmdFbGVtZW50QXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcblxuICAgIGlmICh0aGlzLmVhdCgxMzkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIpO1xuICAgIH1cblxuICAgIG5vZGUubmFtZSA9IHRoaXMuanN4UGFyc2VFbGVtZW50TmFtZSgpO1xuICAgIHRoaXMuZXhwZWN0KDEzOSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWENsb3NpbmdFbGVtZW50XCIpO1xuICB9XG5cbiAganN4UGFyc2VFbGVtZW50QXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgIGNvbnN0IG9wZW5pbmdFbGVtZW50ID0gdGhpcy5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBsZXQgY2xvc2luZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgaWYgKCFvcGVuaW5nRWxlbWVudC5zZWxmQ2xvc2luZykge1xuICAgICAgY29udGVudHM6IGZvciAoOzspIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIDEzODpcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgICAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5lYXQoNTYpKSB7XG4gICAgICAgICAgICAgIGNsb3NpbmdFbGVtZW50ID0gdGhpcy5qc3hQYXJzZUNsb3NpbmdFbGVtZW50QXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgICAgICAgICAgYnJlYWsgY29udGVudHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5qc3hQYXJzZUVsZW1lbnRBdChzdGFydFBvcywgc3RhcnRMb2MpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMzc6XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMucGFyc2VFeHByQXRvbSgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5zZXRDb250ZXh0KHR5cGVzLmJyYWNlKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmpzeFBhcnNlU3ByZWFkQ2hpbGQobm9kZSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5qc3hQYXJzZUV4cHJlc3Npb25Db250YWluZXIobm9kZSwgdHlwZXMual9leHByKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkgJiYgIWlzRnJhZ21lbnQoY2xvc2luZ0VsZW1lbnQpICYmIGNsb3NpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmFpc2UoSnN4RXJyb3JzLk1pc3NpbmdDbG9zaW5nVGFnRnJhZ21lbnQsIHtcbiAgICAgICAgICBhdDogY2xvc2luZ0VsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0ZyYWdtZW50KG9wZW5pbmdFbGVtZW50KSAmJiBpc0ZyYWdtZW50KGNsb3NpbmdFbGVtZW50KSkge1xuICAgICAgICB0aGlzLnJhaXNlKEpzeEVycm9ycy5NaXNzaW5nQ2xvc2luZ1RhZ0VsZW1lbnQsIHtcbiAgICAgICAgICBhdDogY2xvc2luZ0VsZW1lbnQsXG4gICAgICAgICAgb3BlbmluZ1RhZ05hbWU6IGdldFF1YWxpZmllZEpTWE5hbWUob3BlbmluZ0VsZW1lbnQubmFtZSlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0ZyYWdtZW50KG9wZW5pbmdFbGVtZW50KSAmJiAhaXNGcmFnbWVudChjbG9zaW5nRWxlbWVudCkpIHtcbiAgICAgICAgaWYgKGdldFF1YWxpZmllZEpTWE5hbWUoY2xvc2luZ0VsZW1lbnQubmFtZSkgIT09IGdldFF1YWxpZmllZEpTWE5hbWUob3BlbmluZ0VsZW1lbnQubmFtZSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEpzeEVycm9ycy5NaXNzaW5nQ2xvc2luZ1RhZ0VsZW1lbnQsIHtcbiAgICAgICAgICAgIGF0OiBjbG9zaW5nRWxlbWVudCxcbiAgICAgICAgICAgIG9wZW5pbmdUYWdOYW1lOiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9wZW5pbmdFbGVtZW50Lm5hbWUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkpIHtcbiAgICAgIG5vZGUub3BlbmluZ0ZyYWdtZW50ID0gb3BlbmluZ0VsZW1lbnQ7XG4gICAgICBub2RlLmNsb3NpbmdGcmFnbWVudCA9IGNsb3NpbmdFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLm9wZW5pbmdFbGVtZW50ID0gb3BlbmluZ0VsZW1lbnQ7XG4gICAgICBub2RlLmNsb3NpbmdFbGVtZW50ID0gY2xvc2luZ0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgbm9kZS5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEpzeEVycm9ycy5VbndyYXBwZWRBZGphY2VudEpTWEVsZW1lbnRzLCB7XG4gICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkgPyB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hGcmFnbWVudFwiKSA6IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWEVsZW1lbnRcIik7XG4gIH1cblxuICBqc3hQYXJzZUVsZW1lbnQoKSB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5qc3hQYXJzZUVsZW1lbnRBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICB9XG5cbiAgc2V0Q29udGV4dChuZXdDb250ZXh0KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXSA9IG5ld0NvbnRleHQ7XG4gIH1cblxuICBwYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxMzcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSwgXCJKU1hUZXh0XCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCgxMzgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5qc3hQYXJzZUVsZW1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goNDcpICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcykgIT09IDMzKSB7XG4gICAgICB0aGlzLnJlcGxhY2VUb2tlbigxMzgpO1xuICAgICAgcmV0dXJuIHRoaXMuanN4UGFyc2VFbGVtZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5wYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIH1cbiAgfVxuXG4gIHNraXBTcGFjZSgpIHtcbiAgICBjb25zdCBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKCFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHN1cGVyLnNraXBTcGFjZSgpO1xuICB9XG5cbiAgZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuXG4gICAgaWYgKGNvbnRleHQgPT09IHR5cGVzLmpfZXhwcikge1xuICAgICAgcmV0dXJuIHRoaXMuanN4UmVhZFRva2VuKCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgPT09IHR5cGVzLmpfb1RhZyB8fCBjb250ZXh0ID09PSB0eXBlcy5qX2NUYWcpIHtcbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc3hSZWFkV29yZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4oMTM5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKChjb2RlID09PSAzNCB8fCBjb2RlID09PSAzOSkgJiYgY29udGV4dCA9PT0gdHlwZXMual9vVGFnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpzeFJlYWRTdHJpbmcoY29kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDYwICYmIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpICE9PSAzMykge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKDEzOCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmdldFRva2VuRnJvbUNvZGUoY29kZSk7XG4gIH1cblxuICB1cGRhdGVDb250ZXh0KHByZXZUeXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGlmICh0eXBlID09PSA1NiAmJiBwcmV2VHlwZSA9PT0gMTM4KSB7XG4gICAgICBjb250ZXh0LnNwbGljZSgtMiwgMiwgdHlwZXMual9jVGFnKTtcbiAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAxMzgpIHtcbiAgICAgIGNvbnRleHQucHVzaCh0eXBlcy5qX29UYWcpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMTM5KSB7XG4gICAgICBjb25zdCBvdXQgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChvdXQgPT09IHR5cGVzLmpfb1RhZyAmJiBwcmV2VHlwZSA9PT0gNTYgfHwgb3V0ID09PSB0eXBlcy5qX2NUYWcpIHtcbiAgICAgICAgY29udGV4dC5wb3AoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV0gPT09IHR5cGVzLmpfZXhwcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dCh0eXBlcy5qX2V4cHIpO1xuICAgICAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gdG9rZW5Db21lc0JlZm9yZUV4cHJlc3Npb24odHlwZSk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5jbGFzcyBUeXBlU2NyaXB0U2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLnR5cGVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuZW51bXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5jb25zdEVudW1zID0gbmV3IFNldCgpO1xuICAgIHRoaXMuY2xhc3NlcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmV4cG9ydE9ubHlCaW5kaW5ncyA9IG5ldyBTZXQoKTtcbiAgfVxuXG59XG5cbmNsYXNzIFR5cGVTY3JpcHRTY29wZUhhbmRsZXIgZXh0ZW5kcyBTY29wZUhhbmRsZXIge1xuICBjcmVhdGVTY29wZShmbGFncykge1xuICAgIHJldHVybiBuZXcgVHlwZVNjcmlwdFNjb3BlKGZsYWdzKTtcbiAgfVxuXG4gIGRlY2xhcmVOYW1lKG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpIHtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG5cbiAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX0ZMQUdTX1RTX0VYUE9SVF9PTkxZKSB7XG4gICAgICB0aGlzLm1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSk7XG4gICAgICBzY29wZS5leHBvcnRPbmx5QmluZGluZ3MuYWRkKG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1cGVyLmRlY2xhcmVOYW1lKG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpO1xuXG4gICAgaWYgKGJpbmRpbmdUeXBlICYgQklORF9LSU5EX1RZUEUpIHtcbiAgICAgIGlmICghKGJpbmRpbmdUeXBlICYgQklORF9LSU5EX1ZBTFVFKSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVkZWNsYXJhdGlvbkluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpO1xuICAgICAgICB0aGlzLm1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHNjb3BlLnR5cGVzLmFkZChuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX0ZMQUdTX1RTX0VOVU0pIHNjb3BlLmVudW1zLmFkZChuYW1lKTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX0ZMQUdTX1RTX0NPTlNUX0VOVU0pIHNjb3BlLmNvbnN0RW51bXMuYWRkKG5hbWUpO1xuICAgIGlmIChiaW5kaW5nVHlwZSAmIEJJTkRfRkxBR1NfQ0xBU1MpIHNjb3BlLmNsYXNzZXMuYWRkKG5hbWUpO1xuICB9XG5cbiAgaXNSZWRlY2xhcmVkSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUpIHtcbiAgICBpZiAoc2NvcGUuZW51bXMuaGFzKG5hbWUpKSB7XG4gICAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX0ZMQUdTX1RTX0VOVU0pIHtcbiAgICAgICAgY29uc3QgaXNDb25zdCA9ICEhKGJpbmRpbmdUeXBlICYgQklORF9GTEFHU19UU19DT05TVF9FTlVNKTtcbiAgICAgICAgY29uc3Qgd2FzQ29uc3QgPSBzY29wZS5jb25zdEVudW1zLmhhcyhuYW1lKTtcbiAgICAgICAgcmV0dXJuIGlzQ29uc3QgIT09IHdhc0NvbnN0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX0ZMQUdTX0NMQVNTICYmIHNjb3BlLmNsYXNzZXMuaGFzKG5hbWUpKSB7XG4gICAgICBpZiAoc2NvcGUubGV4aWNhbC5oYXMobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuICEhKGJpbmRpbmdUeXBlICYgQklORF9LSU5EX1ZBTFVFKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmluZGluZ1R5cGUgJiBCSU5EX0tJTkRfVFlQRSAmJiBzY29wZS50eXBlcy5oYXMobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5pc1JlZGVjbGFyZWRJblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSk7XG4gIH1cblxuICBjaGVja0xvY2FsRXhwb3J0KGlkKSB7XG4gICAgY29uc3QgdG9wTGV2ZWxTY29wZSA9IHRoaXMuc2NvcGVTdGFja1swXTtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lXG4gICAgfSA9IGlkO1xuXG4gICAgaWYgKCF0b3BMZXZlbFNjb3BlLnR5cGVzLmhhcyhuYW1lKSAmJiAhdG9wTGV2ZWxTY29wZS5leHBvcnRPbmx5QmluZGluZ3MuaGFzKG5hbWUpKSB7XG4gICAgICBzdXBlci5jaGVja0xvY2FsRXhwb3J0KGlkKTtcbiAgICB9XG4gIH1cblxufVxuXG5jb25zdCBnZXRPd24kMSA9IChvYmplY3QsIGtleSkgPT4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIG9iamVjdFtrZXldO1xuXG5mdW5jdGlvbiBub25OdWxsKHgpIHtcbiAgaWYgKHggPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCAke3h9IHZhbHVlLmApO1xuICB9XG5cbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIGFzc2VydCh4KSB7XG4gIGlmICgheCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydCBmYWlsXCIpO1xuICB9XG59XG5cbmNvbnN0IFRTRXJyb3JzID0gUGFyc2VFcnJvckVudW1gdHlwZXNjcmlwdGAoe1xuICBBYnN0cmFjdE1ldGhvZEhhc0ltcGxlbWVudGF0aW9uOiAoe1xuICAgIG1ldGhvZE5hbWVcbiAgfSkgPT4gYE1ldGhvZCAnJHttZXRob2ROYW1lfScgY2Fubm90IGhhdmUgYW4gaW1wbGVtZW50YXRpb24gYmVjYXVzZSBpdCBpcyBtYXJrZWQgYWJzdHJhY3QuYCxcbiAgQWJzdHJhY3RQcm9wZXJ0eUhhc0luaXRpYWxpemVyOiAoe1xuICAgIHByb3BlcnR5TmFtZVxuICB9KSA9PiBgUHJvcGVydHkgJyR7cHJvcGVydHlOYW1lfScgY2Fubm90IGhhdmUgYW4gaW5pdGlhbGl6ZXIgYmVjYXVzZSBpdCBpcyBtYXJrZWQgYWJzdHJhY3QuYCxcbiAgQWNjZXNvckNhbm5vdERlY2xhcmVUaGlzUGFyYW1ldGVyOiBcIidnZXQnIGFuZCAnc2V0JyBhY2Nlc3NvcnMgY2Fubm90IGRlY2xhcmUgJ3RoaXMnIHBhcmFtZXRlcnMuXCIsXG4gIEFjY2Vzb3JDYW5ub3RIYXZlVHlwZVBhcmFtZXRlcnM6IFwiQW4gYWNjZXNzb3IgY2Fubm90IGhhdmUgdHlwZSBwYXJhbWV0ZXJzLlwiLFxuICBDYW5ub3RGaW5kTmFtZTogKHtcbiAgICBuYW1lXG4gIH0pID0+IGBDYW5ub3QgZmluZCBuYW1lICcke25hbWV9Jy5gLFxuICBDbGFzc01ldGhvZEhhc0RlY2xhcmU6IFwiQ2xhc3MgbWV0aG9kcyBjYW5ub3QgaGF2ZSB0aGUgJ2RlY2xhcmUnIG1vZGlmaWVyLlwiLFxuICBDbGFzc01ldGhvZEhhc1JlYWRvbmx5OiBcIkNsYXNzIG1ldGhvZHMgY2Fubm90IGhhdmUgdGhlICdyZWFkb25seScgbW9kaWZpZXIuXCIsXG4gIENvbnN0SW5pdGlhaWxpemVyTXVzdEJlU3RyaW5nT3JOdW1lcmljTGl0ZXJhbE9yTGl0ZXJhbEVudW1SZWZlcmVuY2U6IFwiQSAnY29uc3QnIGluaXRpYWxpemVyIGluIGFuIGFtYmllbnQgY29udGV4dCBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWVyaWMgbGl0ZXJhbCBvciBsaXRlcmFsIGVudW0gcmVmZXJlbmNlLlwiLFxuICBDb25zdHJ1Y3Rvckhhc1R5cGVQYXJhbWV0ZXJzOiBcIlR5cGUgcGFyYW1ldGVycyBjYW5ub3QgYXBwZWFyIG9uIGEgY29uc3RydWN0b3IgZGVjbGFyYXRpb24uXCIsXG4gIERlY2xhcmVBY2Nlc3NvcjogKHtcbiAgICBraW5kXG4gIH0pID0+IGAnZGVjbGFyZScgaXMgbm90IGFsbG93ZWQgaW4gJHtraW5kfXRlcnMuYCxcbiAgRGVjbGFyZUNsYXNzRmllbGRIYXNJbml0aWFsaXplcjogXCJJbml0aWFsaXplcnMgYXJlIG5vdCBhbGxvd2VkIGluIGFtYmllbnQgY29udGV4dHMuXCIsXG4gIERlY2xhcmVGdW5jdGlvbkhhc0ltcGxlbWVudGF0aW9uOiBcIkFuIGltcGxlbWVudGF0aW9uIGNhbm5vdCBiZSBkZWNsYXJlZCBpbiBhbWJpZW50IGNvbnRleHRzLlwiLFxuICBEdXBsaWNhdGVBY2Nlc3NpYmlsaXR5TW9kaWZpZXI6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYEFjY2Vzc2liaWxpdHkgbW9kaWZpZXIgYWxyZWFkeSBzZWVuLmAsXG4gIER1cGxpY2F0ZU1vZGlmaWVyOiAoe1xuICAgIG1vZGlmaWVyXG4gIH0pID0+IGBEdXBsaWNhdGUgbW9kaWZpZXI6ICcke21vZGlmaWVyfScuYCxcbiAgRW1wdHlIZXJpdGFnZUNsYXVzZVR5cGU6ICh7XG4gICAgdG9rZW5cbiAgfSkgPT4gYCcke3Rva2VufScgbGlzdCBjYW5ub3QgYmUgZW1wdHkuYCxcbiAgRW1wdHlUeXBlQXJndW1lbnRzOiBcIlR5cGUgYXJndW1lbnQgbGlzdCBjYW5ub3QgYmUgZW1wdHkuXCIsXG4gIEVtcHR5VHlwZVBhcmFtZXRlcnM6IFwiVHlwZSBwYXJhbWV0ZXIgbGlzdCBjYW5ub3QgYmUgZW1wdHkuXCIsXG4gIEV4cGVjdGVkQW1iaWVudEFmdGVyRXhwb3J0RGVjbGFyZTogXCInZXhwb3J0IGRlY2xhcmUnIG11c3QgYmUgZm9sbG93ZWQgYnkgYW4gYW1iaWVudCBkZWNsYXJhdGlvbi5cIixcbiAgSW1wb3J0QWxpYXNIYXNJbXBvcnRUeXBlOiBcIkFuIGltcG9ydCBhbGlhcyBjYW4gbm90IHVzZSAnaW1wb3J0IHR5cGUnLlwiLFxuICBJbmNvbXBhdGlibGVNb2RpZmllcnM6ICh7XG4gICAgbW9kaWZpZXJzXG4gIH0pID0+IGAnJHttb2RpZmllcnNbMF19JyBtb2RpZmllciBjYW5ub3QgYmUgdXNlZCB3aXRoICcke21vZGlmaWVyc1sxXX0nIG1vZGlmaWVyLmAsXG4gIEluZGV4U2lnbmF0dXJlSGFzQWJzdHJhY3Q6IFwiSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSB0aGUgJ2Fic3RyYWN0JyBtb2RpZmllci5cIixcbiAgSW5kZXhTaWduYXR1cmVIYXNBY2Nlc3NpYmlsaXR5OiAoe1xuICAgIG1vZGlmaWVyXG4gIH0pID0+IGBJbmRleCBzaWduYXR1cmVzIGNhbm5vdCBoYXZlIGFuIGFjY2Vzc2liaWxpdHkgbW9kaWZpZXIgKCcke21vZGlmaWVyfScpLmAsXG4gIEluZGV4U2lnbmF0dXJlSGFzRGVjbGFyZTogXCJJbmRleCBzaWduYXR1cmVzIGNhbm5vdCBoYXZlIHRoZSAnZGVjbGFyZScgbW9kaWZpZXIuXCIsXG4gIEluZGV4U2lnbmF0dXJlSGFzT3ZlcnJpZGU6IFwiJ292ZXJyaWRlJyBtb2RpZmllciBjYW5ub3QgYXBwZWFyIG9uIGFuIGluZGV4IHNpZ25hdHVyZS5cIixcbiAgSW5kZXhTaWduYXR1cmVIYXNTdGF0aWM6IFwiSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSB0aGUgJ3N0YXRpYycgbW9kaWZpZXIuXCIsXG4gIEluaXRpYWxpemVyTm90QWxsb3dlZEluQW1iaWVudENvbnRleHQ6IFwiSW5pdGlhbGl6ZXJzIGFyZSBub3QgYWxsb3dlZCBpbiBhbWJpZW50IGNvbnRleHRzLlwiLFxuICBJbnZhbGlkTW9kaWZpZXJPblR5cGVNZW1iZXI6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYCcke21vZGlmaWVyfScgbW9kaWZpZXIgY2Fubm90IGFwcGVhciBvbiBhIHR5cGUgbWVtYmVyLmAsXG4gIEludmFsaWRNb2RpZmllck9uVHlwZVBhcmFtZXRlcjogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgJyR7bW9kaWZpZXJ9JyBtb2RpZmllciBjYW5ub3QgYXBwZWFyIG9uIGEgdHlwZSBwYXJhbWV0ZXIuYCxcbiAgSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyUG9zaXRpb25zOiAoe1xuICAgIG1vZGlmaWVyXG4gIH0pID0+IGAnJHttb2RpZmllcn0nIG1vZGlmaWVyIGNhbiBvbmx5IGFwcGVhciBvbiBhIHR5cGUgcGFyYW1ldGVyIG9mIGEgY2xhc3MsIGludGVyZmFjZSBvciB0eXBlIGFsaWFzLmAsXG4gIEludmFsaWRNb2RpZmllcnNPcmRlcjogKHtcbiAgICBvcmRlcmVkTW9kaWZpZXJzXG4gIH0pID0+IGAnJHtvcmRlcmVkTW9kaWZpZXJzWzBdfScgbW9kaWZpZXIgbXVzdCBwcmVjZWRlICcke29yZGVyZWRNb2RpZmllcnNbMV19JyBtb2RpZmllci5gLFxuICBJbnZhbGlkUHJvcGVydHlBY2Nlc3NBZnRlckluc3RhbnRpYXRpb25FeHByZXNzaW9uOiBcIkludmFsaWQgcHJvcGVydHkgYWNjZXNzIGFmdGVyIGFuIGluc3RhbnRpYXRpb24gZXhwcmVzc2lvbi4gXCIgKyBcIllvdSBjYW4gZWl0aGVyIHdyYXAgdGhlIGluc3RhbnRpYXRpb24gZXhwcmVzc2lvbiBpbiBwYXJlbnRoZXNlcywgb3IgZGVsZXRlIHRoZSB0eXBlIGFyZ3VtZW50cy5cIixcbiAgSW52YWxpZFR1cGxlTWVtYmVyTGFiZWw6IFwiVHVwbGUgbWVtYmVycyBtdXN0IGJlIGxhYmVsZWQgd2l0aCBhIHNpbXBsZSBpZGVudGlmaWVyLlwiLFxuICBNaXNzaW5nSW50ZXJmYWNlTmFtZTogXCInaW50ZXJmYWNlJyBkZWNsYXJhdGlvbnMgbXVzdCBiZSBmb2xsb3dlZCBieSBhbiBpZGVudGlmaWVyLlwiLFxuICBNaXhlZExhYmVsZWRBbmRVbmxhYmVsZWRFbGVtZW50czogXCJUdXBsZSBtZW1iZXJzIG11c3QgYWxsIGhhdmUgbmFtZXMgb3IgYWxsIG5vdCBoYXZlIG5hbWVzLlwiLFxuICBOb25BYnN0cmFjdENsYXNzSGFzQWJzdHJhY3RNZXRob2Q6IFwiQWJzdHJhY3QgbWV0aG9kcyBjYW4gb25seSBhcHBlYXIgd2l0aGluIGFuIGFic3RyYWN0IGNsYXNzLlwiLFxuICBOb25DbGFzc01ldGhvZFByb3BlcnR5SGFzQWJzdHJhY3RNb2RpZmVyOiBcIidhYnN0cmFjdCcgbW9kaWZpZXIgY2FuIG9ubHkgYXBwZWFyIG9uIGEgY2xhc3MsIG1ldGhvZCwgb3IgcHJvcGVydHkgZGVjbGFyYXRpb24uXCIsXG4gIE9wdGlvbmFsVHlwZUJlZm9yZVJlcXVpcmVkOiBcIkEgcmVxdWlyZWQgZWxlbWVudCBjYW5ub3QgZm9sbG93IGFuIG9wdGlvbmFsIGVsZW1lbnQuXCIsXG4gIE92ZXJyaWRlTm90SW5TdWJDbGFzczogXCJUaGlzIG1lbWJlciBjYW5ub3QgaGF2ZSBhbiAnb3ZlcnJpZGUnIG1vZGlmaWVyIGJlY2F1c2UgaXRzIGNvbnRhaW5pbmcgY2xhc3MgZG9lcyBub3QgZXh0ZW5kIGFub3RoZXIgY2xhc3MuXCIsXG4gIFBhdHRlcm5Jc09wdGlvbmFsOiBcIkEgYmluZGluZyBwYXR0ZXJuIHBhcmFtZXRlciBjYW5ub3QgYmUgb3B0aW9uYWwgaW4gYW4gaW1wbGVtZW50YXRpb24gc2lnbmF0dXJlLlwiLFxuICBQcml2YXRlRWxlbWVudEhhc0Fic3RyYWN0OiBcIlByaXZhdGUgZWxlbWVudHMgY2Fubm90IGhhdmUgdGhlICdhYnN0cmFjdCcgbW9kaWZpZXIuXCIsXG4gIFByaXZhdGVFbGVtZW50SGFzQWNjZXNzaWJpbGl0eTogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgUHJpdmF0ZSBlbGVtZW50cyBjYW5ub3QgaGF2ZSBhbiBhY2Nlc3NpYmlsaXR5IG1vZGlmaWVyICgnJHttb2RpZmllcn0nKS5gLFxuICBSZWFkb25seUZvck1ldGhvZFNpZ25hdHVyZTogXCIncmVhZG9ubHknIG1vZGlmaWVyIGNhbiBvbmx5IGFwcGVhciBvbiBhIHByb3BlcnR5IGRlY2xhcmF0aW9uIG9yIGluZGV4IHNpZ25hdHVyZS5cIixcbiAgUmVzZXJ2ZWRBcnJvd1R5cGVQYXJhbTogXCJUaGlzIHN5bnRheCBpcyByZXNlcnZlZCBpbiBmaWxlcyB3aXRoIHRoZSAubXRzIG9yIC5jdHMgZXh0ZW5zaW9uLiBBZGQgYSB0cmFpbGluZyBjb21tYSwgYXMgaW4gYDxULD4oKSA9PiAuLi5gLlwiLFxuICBSZXNlcnZlZFR5cGVBc3NlcnRpb246IFwiVGhpcyBzeW50YXggaXMgcmVzZXJ2ZWQgaW4gZmlsZXMgd2l0aCB0aGUgLm10cyBvciAuY3RzIGV4dGVuc2lvbi4gVXNlIGFuIGBhc2AgZXhwcmVzc2lvbiBpbnN0ZWFkLlwiLFxuICBTZXRBY2Nlc29yQ2Fubm90SGF2ZU9wdGlvbmFsUGFyYW1ldGVyOiBcIkEgJ3NldCcgYWNjZXNzb3IgY2Fubm90IGhhdmUgYW4gb3B0aW9uYWwgcGFyYW1ldGVyLlwiLFxuICBTZXRBY2Nlc29yQ2Fubm90SGF2ZVJlc3RQYXJhbWV0ZXI6IFwiQSAnc2V0JyBhY2Nlc3NvciBjYW5ub3QgaGF2ZSByZXN0IHBhcmFtZXRlci5cIixcbiAgU2V0QWNjZXNvckNhbm5vdEhhdmVSZXR1cm5UeXBlOiBcIkEgJ3NldCcgYWNjZXNzb3IgY2Fubm90IGhhdmUgYSByZXR1cm4gdHlwZSBhbm5vdGF0aW9uLlwiLFxuICBTaW5nbGVUeXBlUGFyYW1ldGVyV2l0aG91dFRyYWlsaW5nQ29tbWE6ICh7XG4gICAgdHlwZVBhcmFtZXRlck5hbWVcbiAgfSkgPT4gYFNpbmdsZSB0eXBlIHBhcmFtZXRlciAke3R5cGVQYXJhbWV0ZXJOYW1lfSBzaG91bGQgaGF2ZSBhIHRyYWlsaW5nIGNvbW1hLiBFeGFtcGxlIHVzYWdlOiA8JHt0eXBlUGFyYW1ldGVyTmFtZX0sPi5gLFxuICBTdGF0aWNCbG9ja0Nhbm5vdEhhdmVNb2RpZmllcjogXCJTdGF0aWMgY2xhc3MgYmxvY2tzIGNhbm5vdCBoYXZlIGFueSBtb2RpZmllci5cIixcbiAgVHlwZUFubm90YXRpb25BZnRlckFzc2lnbjogXCJUeXBlIGFubm90YXRpb25zIG11c3QgY29tZSBiZWZvcmUgZGVmYXVsdCBhc3NpZ25tZW50cywgZS5nLiBpbnN0ZWFkIG9mIGBhZ2UgPSAyNTogbnVtYmVyYCB1c2UgYGFnZTogbnVtYmVyID0gMjVgLlwiLFxuICBUeXBlSW1wb3J0Q2Fubm90U3BlY2lmeURlZmF1bHRBbmROYW1lZDogXCJBIHR5cGUtb25seSBpbXBvcnQgY2FuIHNwZWNpZnkgYSBkZWZhdWx0IGltcG9ydCBvciBuYW1lZCBiaW5kaW5ncywgYnV0IG5vdCBib3RoLlwiLFxuICBUeXBlTW9kaWZpZXJJc1VzZWRJblR5cGVFeHBvcnRzOiBcIlRoZSAndHlwZScgbW9kaWZpZXIgY2Fubm90IGJlIHVzZWQgb24gYSBuYW1lZCBleHBvcnQgd2hlbiAnZXhwb3J0IHR5cGUnIGlzIHVzZWQgb24gaXRzIGV4cG9ydCBzdGF0ZW1lbnQuXCIsXG4gIFR5cGVNb2RpZmllcklzVXNlZEluVHlwZUltcG9ydHM6IFwiVGhlICd0eXBlJyBtb2RpZmllciBjYW5ub3QgYmUgdXNlZCBvbiBhIG5hbWVkIGltcG9ydCB3aGVuICdpbXBvcnQgdHlwZScgaXMgdXNlZCBvbiBpdHMgaW1wb3J0IHN0YXRlbWVudC5cIixcbiAgVW5leHBlY3RlZFBhcmFtZXRlck1vZGlmaWVyOiBcIkEgcGFyYW1ldGVyIHByb3BlcnR5IGlzIG9ubHkgYWxsb3dlZCBpbiBhIGNvbnN0cnVjdG9yIGltcGxlbWVudGF0aW9uLlwiLFxuICBVbmV4cGVjdGVkUmVhZG9ubHk6IFwiJ3JlYWRvbmx5JyB0eXBlIG1vZGlmaWVyIGlzIG9ubHkgcGVybWl0dGVkIG9uIGFycmF5IGFuZCB0dXBsZSBsaXRlcmFsIHR5cGVzLlwiLFxuICBVbmV4cGVjdGVkVHlwZUFubm90YXRpb246IFwiRGlkIG5vdCBleHBlY3QgYSB0eXBlIGFubm90YXRpb24gaGVyZS5cIixcbiAgVW5leHBlY3RlZFR5cGVDYXN0SW5QYXJhbWV0ZXI6IFwiVW5leHBlY3RlZCB0eXBlIGNhc3QgaW4gcGFyYW1ldGVyIHBvc2l0aW9uLlwiLFxuICBVbnN1cHBvcnRlZEltcG9ydFR5cGVBcmd1bWVudDogXCJBcmd1bWVudCBpbiBhIHR5cGUgaW1wb3J0IG11c3QgYmUgYSBzdHJpbmcgbGl0ZXJhbC5cIixcbiAgVW5zdXBwb3J0ZWRQYXJhbWV0ZXJQcm9wZXJ0eUtpbmQ6IFwiQSBwYXJhbWV0ZXIgcHJvcGVydHkgbWF5IG5vdCBiZSBkZWNsYXJlZCB1c2luZyBhIGJpbmRpbmcgcGF0dGVybi5cIixcbiAgVW5zdXBwb3J0ZWRTaWduYXR1cmVQYXJhbWV0ZXJLaW5kOiAoe1xuICAgIHR5cGVcbiAgfSkgPT4gYE5hbWUgaW4gYSBzaWduYXR1cmUgbXVzdCBiZSBhbiBJZGVudGlmaWVyLCBPYmplY3RQYXR0ZXJuIG9yIEFycmF5UGF0dGVybiwgaW5zdGVhZCBnb3QgJHt0eXBlfS5gXG59KTtcblxuZnVuY3Rpb24ga2V5d29yZFR5cGVGcm9tTmFtZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBcImFueVwiOlxuICAgICAgcmV0dXJuIFwiVFNBbnlLZXl3b3JkXCI7XG5cbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIFwiVFNCb29sZWFuS2V5d29yZFwiO1xuXG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuIFwiVFNCaWdJbnRLZXl3b3JkXCI7XG5cbiAgICBjYXNlIFwibmV2ZXJcIjpcbiAgICAgIHJldHVybiBcIlRTTmV2ZXJLZXl3b3JkXCI7XG5cbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gXCJUU051bWJlcktleXdvcmRcIjtcblxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBcIlRTT2JqZWN0S2V5d29yZFwiO1xuXG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIFwiVFNTdHJpbmdLZXl3b3JkXCI7XG5cbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICByZXR1cm4gXCJUU1N5bWJvbEtleXdvcmRcIjtcblxuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiBcIlRTVW5kZWZpbmVkS2V5d29yZFwiO1xuXG4gICAgY2FzZSBcInVua25vd25cIjpcbiAgICAgIHJldHVybiBcIlRTVW5rbm93bktleXdvcmRcIjtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRzSXNBY2Nlc3NNb2RpZmllcihtb2RpZmllcikge1xuICByZXR1cm4gbW9kaWZpZXIgPT09IFwicHJpdmF0ZVwiIHx8IG1vZGlmaWVyID09PSBcInB1YmxpY1wiIHx8IG1vZGlmaWVyID09PSBcInByb3RlY3RlZFwiO1xufVxuXG5mdW5jdGlvbiB0c0lzVmFyaWFuY2VBbm5vdGF0aW9ucyhtb2RpZmllcikge1xuICByZXR1cm4gbW9kaWZpZXIgPT09IFwiaW5cIiB8fCBtb2RpZmllciA9PT0gXCJvdXRcIjtcbn1cblxudmFyIHR5cGVzY3JpcHQgPSAoc3VwZXJDbGFzcyA9PiBjbGFzcyBUeXBlU2NyaXB0UGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgZ2V0U2NvcGVIYW5kbGVyKCkge1xuICAgIHJldHVybiBUeXBlU2NyaXB0U2NvcGVIYW5kbGVyO1xuICB9XG5cbiAgdHNJc0lkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSk7XG4gIH1cblxuICB0c1Rva2VuQ2FuRm9sbG93TW9kaWZpZXIoKSB7XG4gICAgcmV0dXJuICh0aGlzLm1hdGNoKDApIHx8IHRoaXMubWF0Y2goNSkgfHwgdGhpcy5tYXRjaCg1NSkgfHwgdGhpcy5tYXRjaCgyMSkgfHwgdGhpcy5tYXRjaCgxMzQpIHx8IHRoaXMuaXNMaXRlcmFsUHJvcGVydHlOYW1lKCkpICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpO1xuICB9XG5cbiAgdHNOZXh0VG9rZW5DYW5Gb2xsb3dNb2RpZmllcigpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy50c1Rva2VuQ2FuRm9sbG93TW9kaWZpZXIoKTtcbiAgfVxuXG4gIHRzUGFyc2VNb2RpZmllcihhbGxvd2VkTW9kaWZpZXJzLCBzdG9wT25TdGFydE9mQ2xhc3NTdGF0aWNCbG9jaykge1xuICAgIGlmICghdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSAmJiB0aGlzLnN0YXRlLnR5cGUgIT09IDU4KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZGlmaWVyID0gdGhpcy5zdGF0ZS52YWx1ZTtcblxuICAgIGlmIChhbGxvd2VkTW9kaWZpZXJzLmluZGV4T2YobW9kaWZpZXIpICE9PSAtMSkge1xuICAgICAgaWYgKHN0b3BPblN0YXJ0T2ZDbGFzc1N0YXRpY0Jsb2NrICYmIHRoaXMudHNJc1N0YXJ0T2ZTdGF0aWNCbG9ja3MoKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50c1RyeVBhcnNlKHRoaXMudHNOZXh0VG9rZW5DYW5Gb2xsb3dNb2RpZmllci5iaW5kKHRoaXMpKSkge1xuICAgICAgICByZXR1cm4gbW9kaWZpZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRzUGFyc2VNb2RpZmllcnMoe1xuICAgIG1vZGlmaWVkLFxuICAgIGFsbG93ZWRNb2RpZmllcnMsXG4gICAgZGlzYWxsb3dlZE1vZGlmaWVycyxcbiAgICBzdG9wT25TdGFydE9mQ2xhc3NTdGF0aWNCbG9jayxcbiAgICBlcnJvclRlbXBsYXRlID0gVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlTWVtYmVyXG4gIH0pIHtcbiAgICBjb25zdCBlbmZvcmNlT3JkZXIgPSAobG9jLCBtb2RpZmllciwgYmVmb3JlLCBhZnRlcikgPT4ge1xuICAgICAgaWYgKG1vZGlmaWVyID09PSBiZWZvcmUgJiYgbW9kaWZpZWRbYWZ0ZXJdKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyc09yZGVyLCB7XG4gICAgICAgICAgYXQ6IGxvYyxcbiAgICAgICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbYmVmb3JlLCBhZnRlcl1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGluY29tcGF0aWJsZSA9IChsb2MsIG1vZGlmaWVyLCBtb2QxLCBtb2QyKSA9PiB7XG4gICAgICBpZiAobW9kaWZpZWRbbW9kMV0gJiYgbW9kaWZpZXIgPT09IG1vZDIgfHwgbW9kaWZpZWRbbW9kMl0gJiYgbW9kaWZpZXIgPT09IG1vZDEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbmNvbXBhdGlibGVNb2RpZmllcnMsIHtcbiAgICAgICAgICBhdDogbG9jLFxuICAgICAgICAgIG1vZGlmaWVyczogW21vZDEsIG1vZDJdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0TG9jXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IG1vZGlmaWVyID0gdGhpcy50c1BhcnNlTW9kaWZpZXIoYWxsb3dlZE1vZGlmaWVycy5jb25jYXQoZGlzYWxsb3dlZE1vZGlmaWVycyAhPSBudWxsID8gZGlzYWxsb3dlZE1vZGlmaWVycyA6IFtdKSwgc3RvcE9uU3RhcnRPZkNsYXNzU3RhdGljQmxvY2spO1xuICAgICAgaWYgKCFtb2RpZmllcikgYnJlYWs7XG5cbiAgICAgIGlmICh0c0lzQWNjZXNzTW9kaWZpZXIobW9kaWZpZXIpKSB7XG4gICAgICAgIGlmIChtb2RpZmllZC5hY2Nlc3NpYmlsaXR5KSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EdXBsaWNhdGVBY2Nlc3NpYmlsaXR5TW9kaWZpZXIsIHtcbiAgICAgICAgICAgIGF0OiBzdGFydExvYyxcbiAgICAgICAgICAgIG1vZGlmaWVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgbW9kaWZpZXIsIFwib3ZlcnJpZGVcIik7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgbW9kaWZpZXIsIFwic3RhdGljXCIpO1xuICAgICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIG1vZGlmaWVyLCBcInJlYWRvbmx5XCIpO1xuICAgICAgICAgIG1vZGlmaWVkLmFjY2Vzc2liaWxpdHkgPSBtb2RpZmllcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0c0lzVmFyaWFuY2VBbm5vdGF0aW9ucyhtb2RpZmllcikpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVkW21vZGlmaWVyXSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRHVwbGljYXRlTW9kaWZpZXIsIHtcbiAgICAgICAgICAgIGF0OiBzdGFydExvYyxcbiAgICAgICAgICAgIG1vZGlmaWVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RpZmllZFttb2RpZmllcl0gPSB0cnVlO1xuICAgICAgICBlbmZvcmNlT3JkZXIoc3RhcnRMb2MsIG1vZGlmaWVyLCBcImluXCIsIFwib3V0XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZGlmaWVkLCBtb2RpZmllcikpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkR1cGxpY2F0ZU1vZGlmaWVyLCB7XG4gICAgICAgICAgICBhdDogc3RhcnRMb2MsXG4gICAgICAgICAgICBtb2RpZmllclxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIFwic3RhdGljXCIsIFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJzdGF0aWNcIiwgXCJvdmVycmlkZVwiKTtcbiAgICAgICAgICBlbmZvcmNlT3JkZXIoc3RhcnRMb2MsIG1vZGlmaWVyLCBcIm92ZXJyaWRlXCIsIFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJhYnN0cmFjdFwiLCBcIm92ZXJyaWRlXCIpO1xuICAgICAgICAgIGluY29tcGF0aWJsZShzdGFydExvYywgbW9kaWZpZXIsIFwiZGVjbGFyZVwiLCBcIm92ZXJyaWRlXCIpO1xuICAgICAgICAgIGluY29tcGF0aWJsZShzdGFydExvYywgbW9kaWZpZXIsIFwic3RhdGljXCIsIFwiYWJzdHJhY3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RpZmllZFttb2RpZmllcl0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlzYWxsb3dlZE1vZGlmaWVycyAhPSBudWxsICYmIGRpc2FsbG93ZWRNb2RpZmllcnMuaW5jbHVkZXMobW9kaWZpZXIpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoZXJyb3JUZW1wbGF0ZSwge1xuICAgICAgICAgIGF0OiBzdGFydExvYyxcbiAgICAgICAgICBtb2RpZmllclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0c0lzTGlzdFRlcm1pbmF0b3Ioa2luZCkge1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBcIkVudW1NZW1iZXJzXCI6XG4gICAgICBjYXNlIFwiVHlwZU1lbWJlcnNcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goOCk7XG5cbiAgICAgIGNhc2UgXCJIZXJpdGFnZUNsYXVzZUVsZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goNSk7XG5cbiAgICAgIGNhc2UgXCJUdXBsZUVsZW1lbnRUeXBlc1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCgzKTtcblxuICAgICAgY2FzZSBcIlR5cGVQYXJhbWV0ZXJzT3JBcmd1bWVudHNcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goNDgpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlXCIpO1xuICB9XG5cbiAgdHNQYXJzZUxpc3Qoa2luZCwgcGFyc2VFbGVtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoIXRoaXMudHNJc0xpc3RUZXJtaW5hdG9yKGtpbmQpKSB7XG4gICAgICByZXN1bHQucHVzaChwYXJzZUVsZW1lbnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHRzUGFyc2VEZWxpbWl0ZWRMaXN0KGtpbmQsIHBhcnNlRWxlbWVudCwgcmVmVHJhaWxpbmdDb21tYVBvcykge1xuICAgIHJldHVybiBub25OdWxsKHRoaXMudHNQYXJzZURlbGltaXRlZExpc3RXb3JrZXIoa2luZCwgcGFyc2VFbGVtZW50LCB0cnVlLCByZWZUcmFpbGluZ0NvbW1hUG9zKSk7XG4gIH1cblxuICB0c1BhcnNlRGVsaW1pdGVkTGlzdFdvcmtlcihraW5kLCBwYXJzZUVsZW1lbnQsIGV4cGVjdFN1Y2Nlc3MsIHJlZlRyYWlsaW5nQ29tbWFQb3MpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgdHJhaWxpbmdDb21tYVBvcyA9IC0xO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMudHNJc0xpc3RUZXJtaW5hdG9yKGtpbmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0cmFpbGluZ0NvbW1hUG9zID0gLTE7XG4gICAgICBjb25zdCBlbGVtZW50ID0gcGFyc2VFbGVtZW50KCk7XG5cbiAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgIGlmICh0aGlzLmVhdCgxMikpIHtcbiAgICAgICAgdHJhaWxpbmdDb21tYVBvcyA9IHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHNJc0xpc3RUZXJtaW5hdG9yKGtpbmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhwZWN0U3VjY2Vzcykge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHJlZlRyYWlsaW5nQ29tbWFQb3MpIHtcbiAgICAgIHJlZlRyYWlsaW5nQ29tbWFQb3MudmFsdWUgPSB0cmFpbGluZ0NvbW1hUG9zO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB0c1BhcnNlQnJhY2tldGVkTGlzdChraW5kLCBwYXJzZUVsZW1lbnQsIGJyYWNrZXQsIHNraXBGaXJzdFRva2VuLCByZWZUcmFpbGluZ0NvbW1hUG9zKSB7XG4gICAgaWYgKCFza2lwRmlyc3RUb2tlbikge1xuICAgICAgaWYgKGJyYWNrZXQpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCg0Nyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy50c1BhcnNlRGVsaW1pdGVkTGlzdChraW5kLCBwYXJzZUVsZW1lbnQsIHJlZlRyYWlsaW5nQ29tbWFQb3MpO1xuXG4gICAgaWYgKGJyYWNrZXQpIHtcbiAgICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdCg0OCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHRzUGFyc2VJbXBvcnRUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0KDgzKTtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG5cbiAgICBpZiAoIXRoaXMubWF0Y2goMTI5KSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbnN1cHBvcnRlZEltcG9ydFR5cGVBcmd1bWVudCwge1xuICAgICAgICBhdDogdGhpcy5zdGF0ZS5zdGFydExvY1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbm9kZS5hcmd1bWVudCA9IHN1cGVyLnBhcnNlRXhwckF0b20oKTtcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG5cbiAgICBpZiAodGhpcy5lYXQoMTYpKSB7XG4gICAgICBub2RlLnF1YWxpZmllciA9IHRoaXMudHNQYXJzZUVudGl0eU5hbWUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW1wb3J0VHlwZVwiKTtcbiAgfVxuXG4gIHRzUGFyc2VFbnRpdHlOYW1lKGFsbG93UmVzZXJ2ZWRXb3JkcyA9IHRydWUpIHtcbiAgICBsZXQgZW50aXR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoYWxsb3dSZXNlcnZlZFdvcmRzKTtcblxuICAgIHdoaWxlICh0aGlzLmVhdCgxNikpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShlbnRpdHkpO1xuICAgICAgbm9kZS5sZWZ0ID0gZW50aXR5O1xuICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKGFsbG93UmVzZXJ2ZWRXb3Jkcyk7XG4gICAgICBlbnRpdHkgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1F1YWxpZmllZE5hbWVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudGl0eTtcbiAgfVxuXG4gIHRzUGFyc2VUeXBlUmVmZXJlbmNlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudHlwZU5hbWUgPSB0aGlzLnRzUGFyc2VFbnRpdHlOYW1lKCk7XG5cbiAgICBpZiAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVJlZmVyZW5jZVwiKTtcbiAgfVxuXG4gIHRzUGFyc2VUaGlzVHlwZVByZWRpY2F0ZShsaHMpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUobGhzKTtcbiAgICBub2RlLnBhcmFtZXRlck5hbWUgPSBsaHM7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKGZhbHNlKTtcbiAgICBub2RlLmFzc2VydHMgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICB9XG5cbiAgdHNQYXJzZVRoaXNUeXBlTm9kZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUaGlzVHlwZVwiKTtcbiAgfVxuXG4gIHRzUGFyc2VUeXBlUXVlcnkoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoODcpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2goODMpKSB7XG4gICAgICBub2RlLmV4cHJOYW1lID0gdGhpcy50c1BhcnNlSW1wb3J0VHlwZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmV4cHJOYW1lID0gdGhpcy50c1BhcnNlRW50aXR5TmFtZSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUXVlcnlcIik7XG4gIH1cblxuICB0c1BhcnNlSW5PdXRNb2RpZmllcnMobm9kZSkge1xuICAgIHRoaXMudHNQYXJzZU1vZGlmaWVycyh7XG4gICAgICBtb2RpZmllZDogbm9kZSxcbiAgICAgIGFsbG93ZWRNb2RpZmllcnM6IFtcImluXCIsIFwib3V0XCJdLFxuICAgICAgZGlzYWxsb3dlZE1vZGlmaWVyczogW1wicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInJlYWRvbmx5XCIsIFwiZGVjbGFyZVwiLCBcImFic3RyYWN0XCIsIFwib3ZlcnJpZGVcIl0sXG4gICAgICBlcnJvclRlbXBsYXRlOiBUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPblR5cGVQYXJhbWV0ZXJcbiAgICB9KTtcbiAgfVxuXG4gIHRzUGFyc2VOb25lTW9kaWZpZXJzKG5vZGUpIHtcbiAgICB0aGlzLnRzUGFyc2VNb2RpZmllcnMoe1xuICAgICAgbW9kaWZpZWQ6IG5vZGUsXG4gICAgICBhbGxvd2VkTW9kaWZpZXJzOiBbXSxcbiAgICAgIGRpc2FsbG93ZWRNb2RpZmllcnM6IFtcImluXCIsIFwib3V0XCJdLFxuICAgICAgZXJyb3JUZW1wbGF0ZTogVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyUG9zaXRpb25zXG4gICAgfSk7XG4gIH1cblxuICB0c1BhcnNlVHlwZVBhcmFtZXRlcihwYXJzZU1vZGlmaWVycyA9IHRoaXMudHNQYXJzZU5vbmVNb2RpZmllcnMuYmluZCh0aGlzKSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHBhcnNlTW9kaWZpZXJzKG5vZGUpO1xuICAgIG5vZGUubmFtZSA9IHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXJOYW1lKCk7XG4gICAgbm9kZS5jb25zdHJhaW50ID0gdGhpcy50c0VhdFRoZW5QYXJzZVR5cGUoODEpO1xuICAgIG5vZGUuZGVmYXVsdCA9IHRoaXMudHNFYXRUaGVuUGFyc2VUeXBlKDI5KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUGFyYW1ldGVyXCIpO1xuICB9XG5cbiAgdHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHBhcnNlTW9kaWZpZXJzKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlcnMocGFyc2VNb2RpZmllcnMpO1xuICAgIH1cbiAgfVxuXG4gIHRzUGFyc2VUeXBlUGFyYW1ldGVycyhwYXJzZU1vZGlmaWVycykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goMTM4KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZlRyYWlsaW5nQ29tbWFQb3MgPSB7XG4gICAgICB2YWx1ZTogLTFcbiAgICB9O1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy50c1BhcnNlQnJhY2tldGVkTGlzdChcIlR5cGVQYXJhbWV0ZXJzT3JBcmd1bWVudHNcIiwgdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlci5iaW5kKHRoaXMsIHBhcnNlTW9kaWZpZXJzKSwgZmFsc2UsIHRydWUsIHJlZlRyYWlsaW5nQ29tbWFQb3MpO1xuXG4gICAgaWYgKG5vZGUucGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5FbXB0eVR5cGVQYXJhbWV0ZXJzLCB7XG4gICAgICAgIGF0OiBub2RlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVmVHJhaWxpbmdDb21tYVBvcy52YWx1ZSAhPT0gLTEpIHtcbiAgICAgIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJ0cmFpbGluZ0NvbW1hXCIsIHJlZlRyYWlsaW5nQ29tbWFQb3MudmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKTtcbiAgfVxuXG4gIHRzVHJ5TmV4dFBhcnNlQ29uc3RhbnRDb250ZXh0KCkge1xuICAgIGlmICh0aGlzLmxvb2thaGVhZCgpLnR5cGUgIT09IDc1KSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCB0eXBlUmVmZXJlbmNlID0gdGhpcy50c1BhcnNlVHlwZVJlZmVyZW5jZSgpO1xuXG4gICAgaWYgKHR5cGVSZWZlcmVuY2UudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQ2Fubm90RmluZE5hbWUsIHtcbiAgICAgICAgYXQ6IHR5cGVSZWZlcmVuY2UudHlwZU5hbWUsXG4gICAgICAgIG5hbWU6IFwiY29uc3RcIlxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVSZWZlcmVuY2U7XG4gIH1cblxuICB0c0ZpbGxTaWduYXR1cmUocmV0dXJuVG9rZW4sIHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHJldHVyblRva2VuUmVxdWlyZWQgPSByZXR1cm5Ub2tlbiA9PT0gMTk7XG4gICAgY29uc3QgcGFyYW1zS2V5ID0gXCJwYXJhbWV0ZXJzXCI7XG4gICAgY29uc3QgcmV0dXJuVHlwZUtleSA9IFwidHlwZUFubm90YXRpb25cIjtcbiAgICBzaWduYXR1cmUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycygpO1xuICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICBzaWduYXR1cmVbcGFyYW1zS2V5XSA9IHRoaXMudHNQYXJzZUJpbmRpbmdMaXN0Rm9yU2lnbmF0dXJlKCk7XG5cbiAgICBpZiAocmV0dXJuVG9rZW5SZXF1aXJlZCkge1xuICAgICAgc2lnbmF0dXJlW3JldHVyblR5cGVLZXldID0gdGhpcy50c1BhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24ocmV0dXJuVG9rZW4pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaChyZXR1cm5Ub2tlbikpIHtcbiAgICAgIHNpZ25hdHVyZVtyZXR1cm5UeXBlS2V5XSA9IHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKHJldHVyblRva2VuKTtcbiAgICB9XG4gIH1cblxuICB0c1BhcnNlQmluZGluZ0xpc3RGb3JTaWduYXR1cmUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQmluZGluZ0xpc3QoMTEsIDQxKS5tYXAocGF0dGVybiA9PiB7XG4gICAgICBpZiAocGF0dGVybi50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiBwYXR0ZXJuLnR5cGUgIT09IFwiUmVzdEVsZW1lbnRcIiAmJiBwYXR0ZXJuLnR5cGUgIT09IFwiT2JqZWN0UGF0dGVyblwiICYmIHBhdHRlcm4udHlwZSAhPT0gXCJBcnJheVBhdHRlcm5cIikge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlVuc3VwcG9ydGVkU2lnbmF0dXJlUGFyYW1ldGVyS2luZCwge1xuICAgICAgICAgIGF0OiBwYXR0ZXJuLFxuICAgICAgICAgIHR5cGU6IHBhdHRlcm4udHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfSk7XG4gIH1cblxuICB0c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpIHtcbiAgICBpZiAoIXRoaXMuZWF0KDEyKSAmJiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0KDEzKTtcbiAgICB9XG4gIH1cblxuICB0c1BhcnNlU2lnbmF0dXJlTWVtYmVyKGtpbmQsIG5vZGUpIHtcbiAgICB0aGlzLnRzRmlsbFNpZ25hdHVyZSgxNCwgbm9kZSk7XG4gICAgdGhpcy50c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwga2luZCk7XG4gIH1cblxuICB0c0lzVW5hbWJpZ3VvdXNseUluZGV4U2lnbmF0dXJlKCkge1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMubWF0Y2goMTQpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRzVHJ5UGFyc2VJbmRleFNpZ25hdHVyZShub2RlKSB7XG4gICAgaWYgKCEodGhpcy5tYXRjaCgwKSAmJiB0aGlzLnRzTG9va0FoZWFkKHRoaXMudHNJc1VuYW1iaWd1b3VzbHlJbmRleFNpZ25hdHVyZS5iaW5kKHRoaXMpKSkpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5leHBlY3QoMCk7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIGlkLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oaWQpO1xuICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIG5vZGUucGFyYW1ldGVycyA9IFtpZF07XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgaWYgKHR5cGUpIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgIHRoaXMudHNQYXJzZVR5cGVNZW1iZXJTZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNJbmRleFNpZ25hdHVyZVwiKTtcbiAgfVxuXG4gIHRzUGFyc2VQcm9wZXJ0eU9yTWV0aG9kU2lnbmF0dXJlKG5vZGUsIHJlYWRvbmx5KSB7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkgbm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgY29uc3Qgbm9kZUFueSA9IG5vZGU7XG5cbiAgICBpZiAodGhpcy5tYXRjaCgxMCkgfHwgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIGlmIChyZWFkb25seSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlJlYWRvbmx5Rm9yTWV0aG9kU2lnbmF0dXJlLCB7XG4gICAgICAgICAgYXQ6IG5vZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1ldGhvZCA9IG5vZGVBbnk7XG5cbiAgICAgIGlmIChtZXRob2Qua2luZCAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkFjY2Vzb3JDYW5ub3RIYXZlVHlwZVBhcmFtZXRlcnMsIHtcbiAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRzRmlsbFNpZ25hdHVyZSgxNCwgbWV0aG9kKTtcbiAgICAgIHRoaXMudHNQYXJzZVR5cGVNZW1iZXJTZW1pY29sb24oKTtcbiAgICAgIGNvbnN0IHBhcmFtc0tleSA9IFwicGFyYW1ldGVyc1wiO1xuICAgICAgY29uc3QgcmV0dXJuVHlwZUtleSA9IFwidHlwZUFubm90YXRpb25cIjtcblxuICAgICAgaWYgKG1ldGhvZC5raW5kID09PSBcImdldFwiKSB7XG4gICAgICAgIGlmIChtZXRob2RbcGFyYW1zS2V5XS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQmFkR2V0dGVyQXJpdHksIHtcbiAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0aGlzLmlzVGhpc1BhcmFtKG1ldGhvZFtwYXJhbXNLZXldWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5BY2Nlc29yQ2Fubm90RGVjbGFyZVRoaXNQYXJhbWV0ZXIsIHtcbiAgICAgICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiKSB7XG4gICAgICAgIGlmIChtZXRob2RbcGFyYW1zS2V5XS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5CYWRTZXR0ZXJBcml0eSwge1xuICAgICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGZpcnN0UGFyYW1ldGVyID0gbWV0aG9kW3BhcmFtc0tleV1bMF07XG5cbiAgICAgICAgICBpZiAodGhpcy5pc1RoaXNQYXJhbShmaXJzdFBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQWNjZXNvckNhbm5vdERlY2xhcmVUaGlzUGFyYW1ldGVyLCB7XG4gICAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmaXJzdFBhcmFtZXRlci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBmaXJzdFBhcmFtZXRlci5vcHRpb25hbCkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5TZXRBY2Nlc29yQ2Fubm90SGF2ZU9wdGlvbmFsUGFyYW1ldGVyLCB7XG4gICAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmaXJzdFBhcmFtZXRlci50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuU2V0QWNjZXNvckNhbm5vdEhhdmVSZXN0UGFyYW1ldGVyLCB7XG4gICAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRob2RbcmV0dXJuVHlwZUtleV0pIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlNldEFjY2Vzb3JDYW5ub3RIYXZlUmV0dXJuVHlwZSwge1xuICAgICAgICAgICAgYXQ6IG1ldGhvZFtyZXR1cm5UeXBlS2V5XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIlRTTWV0aG9kU2lnbmF0dXJlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IG5vZGVBbnk7XG4gICAgICBpZiAocmVhZG9ubHkpIHByb3BlcnR5LnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgaWYgKHR5cGUpIHByb3BlcnR5LnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICAgIHRoaXMudHNQYXJzZVR5cGVNZW1iZXJTZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcGVydHksIFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiKTtcbiAgICB9XG4gIH1cblxuICB0c1BhcnNlVHlwZU1lbWJlcigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIGlmICh0aGlzLm1hdGNoKDEwKSB8fCB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVNpZ25hdHVyZU1lbWJlcihcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIG5vZGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGNoKDc3KSkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSB8fCB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlU2lnbmF0dXJlTWVtYmVyKFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUua2V5ID0gdGhpcy5jcmVhdGVJZGVudGlmaWVyKGlkLCBcIm5ld1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVByb3BlcnR5T3JNZXRob2RTaWduYXR1cmUobm9kZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudHNQYXJzZU1vZGlmaWVycyh7XG4gICAgICBtb2RpZmllZDogbm9kZSxcbiAgICAgIGFsbG93ZWRNb2RpZmllcnM6IFtcInJlYWRvbmx5XCJdLFxuICAgICAgZGlzYWxsb3dlZE1vZGlmaWVyczogW1wiZGVjbGFyZVwiLCBcImFic3RyYWN0XCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiLCBcInN0YXRpY1wiLCBcIm92ZXJyaWRlXCJdXG4gICAgfSk7XG4gICAgY29uc3QgaWR4ID0gdGhpcy50c1RyeVBhcnNlSW5kZXhTaWduYXR1cmUobm9kZSk7XG5cbiAgICBpZiAoaWR4KSB7XG4gICAgICByZXR1cm4gaWR4O1xuICAgIH1cblxuICAgIHN1cGVyLnBhcnNlUHJvcGVydHlOYW1lKG5vZGUpO1xuXG4gICAgaWYgKCFub2RlLmNvbXB1dGVkICYmIG5vZGUua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChub2RlLmtleS5uYW1lID09PSBcImdldFwiIHx8IG5vZGUua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmIHRoaXMudHNUb2tlbkNhbkZvbGxvd01vZGlmaWVyKCkpIHtcbiAgICAgIG5vZGUua2luZCA9IG5vZGUua2V5Lm5hbWU7XG4gICAgICBzdXBlci5wYXJzZVByb3BlcnR5TmFtZShub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50c1BhcnNlUHJvcGVydHlPck1ldGhvZFNpZ25hdHVyZShub2RlLCAhIW5vZGUucmVhZG9ubHkpO1xuICB9XG5cbiAgdHNQYXJzZVR5cGVMaXRlcmFsKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubWVtYmVycyA9IHRoaXMudHNQYXJzZU9iamVjdFR5cGVNZW1iZXJzKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUxpdGVyYWxcIik7XG4gIH1cblxuICB0c1BhcnNlT2JqZWN0VHlwZU1lbWJlcnMoKSB7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgY29uc3QgbWVtYmVycyA9IHRoaXMudHNQYXJzZUxpc3QoXCJUeXBlTWVtYmVyc1wiLCB0aGlzLnRzUGFyc2VUeXBlTWVtYmVyLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgIHJldHVybiBtZW1iZXJzO1xuICB9XG5cbiAgdHNJc1N0YXJ0T2ZNYXBwZWRUeXBlKCkge1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKHRoaXMuZWF0KDUzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKDExOCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDExOCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5tYXRjaCgwKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKCF0aGlzLnRzSXNJZGVudGlmaWVyKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCg1OCk7XG4gIH1cblxuICB0c1BhcnNlTWFwcGVkVHlwZVBhcmFtZXRlcigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLm5hbWUgPSB0aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVyTmFtZSgpO1xuICAgIG5vZGUuY29uc3RyYWludCA9IHRoaXMudHNFeHBlY3RUaGVuUGFyc2VUeXBlKDU4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUGFyYW1ldGVyXCIpO1xuICB9XG5cbiAgdHNQYXJzZU1hcHBlZFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoNSk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCg1MykpIHtcbiAgICAgIG5vZGUucmVhZG9ubHkgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTE4KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCgxMTgpKSB7XG4gICAgICBub2RlLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdCgwKTtcbiAgICBub2RlLnR5cGVQYXJhbWV0ZXIgPSB0aGlzLnRzUGFyc2VNYXBwZWRUeXBlUGFyYW1ldGVyKCk7XG4gICAgbm9kZS5uYW1lVHlwZSA9IHRoaXMuZWF0Q29udGV4dHVhbCg5MykgPyB0aGlzLnRzUGFyc2VUeXBlKCkgOiBudWxsO1xuICAgIHRoaXMuZXhwZWN0KDMpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2goNTMpKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5leHBlY3QoMTcpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1RyeVBhcnNlVHlwZSgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTWFwcGVkVHlwZVwiKTtcbiAgfVxuXG4gIHRzUGFyc2VUdXBsZVR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5lbGVtZW50VHlwZXMgPSB0aGlzLnRzUGFyc2VCcmFja2V0ZWRMaXN0KFwiVHVwbGVFbGVtZW50VHlwZXNcIiwgdGhpcy50c1BhcnNlVHVwbGVFbGVtZW50VHlwZS5iaW5kKHRoaXMpLCB0cnVlLCBmYWxzZSk7XG4gICAgbGV0IHNlZW5PcHRpb25hbEVsZW1lbnQgPSBmYWxzZTtcbiAgICBsZXQgbGFiZWxlZEVsZW1lbnRzID0gbnVsbDtcbiAgICBub2RlLmVsZW1lbnRUeXBlcy5mb3JFYWNoKGVsZW1lbnROb2RlID0+IHtcbiAgICAgIHZhciBfbGFiZWxlZEVsZW1lbnRzO1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBlbGVtZW50Tm9kZTtcblxuICAgICAgaWYgKHNlZW5PcHRpb25hbEVsZW1lbnQgJiYgdHlwZSAhPT0gXCJUU1Jlc3RUeXBlXCIgJiYgdHlwZSAhPT0gXCJUU09wdGlvbmFsVHlwZVwiICYmICEodHlwZSA9PT0gXCJUU05hbWVkVHVwbGVNZW1iZXJcIiAmJiBlbGVtZW50Tm9kZS5vcHRpb25hbCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5PcHRpb25hbFR5cGVCZWZvcmVSZXF1aXJlZCwge1xuICAgICAgICAgIGF0OiBlbGVtZW50Tm9kZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2Vlbk9wdGlvbmFsRWxlbWVudCB8fCAoc2Vlbk9wdGlvbmFsRWxlbWVudCA9IHR5cGUgPT09IFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIgJiYgZWxlbWVudE5vZGUub3B0aW9uYWwgfHwgdHlwZSA9PT0gXCJUU09wdGlvbmFsVHlwZVwiKTtcbiAgICAgIGxldCBjaGVja1R5cGUgPSB0eXBlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJUU1Jlc3RUeXBlXCIpIHtcbiAgICAgICAgZWxlbWVudE5vZGUgPSBlbGVtZW50Tm9kZS50eXBlQW5ub3RhdGlvbjtcbiAgICAgICAgY2hlY2tUeXBlID0gZWxlbWVudE5vZGUudHlwZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNMYWJlbGVkID0gY2hlY2tUeXBlID09PSBcIlRTTmFtZWRUdXBsZU1lbWJlclwiO1xuICAgICAgKF9sYWJlbGVkRWxlbWVudHMgPSBsYWJlbGVkRWxlbWVudHMpICE9IG51bGwgPyBfbGFiZWxlZEVsZW1lbnRzIDogbGFiZWxlZEVsZW1lbnRzID0gaXNMYWJlbGVkO1xuXG4gICAgICBpZiAobGFiZWxlZEVsZW1lbnRzICE9PSBpc0xhYmVsZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5NaXhlZExhYmVsZWRBbmRVbmxhYmVsZWRFbGVtZW50cywge1xuICAgICAgICAgIGF0OiBlbGVtZW50Tm9kZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUdXBsZVR5cGVcIik7XG4gIH1cblxuICB0c1BhcnNlVHVwbGVFbGVtZW50VHlwZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydDogc3RhcnRQb3MsXG4gICAgICBzdGFydExvY1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHJlc3QgPSB0aGlzLmVhdCgyMSk7XG4gICAgbGV0IHR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSB0aGlzLmVhdCgxNyk7XG4gICAgY29uc3QgbGFiZWxlZCA9IHRoaXMuZWF0KDE0KTtcblxuICAgIGlmIChsYWJlbGVkKSB7XG4gICAgICBjb25zdCBsYWJlbGVkTm9kZSA9IHRoaXMuc3RhcnROb2RlQXROb2RlKHR5cGUpO1xuICAgICAgbGFiZWxlZE5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcblxuICAgICAgaWYgKHR5cGUudHlwZSA9PT0gXCJUU1R5cGVSZWZlcmVuY2VcIiAmJiAhdHlwZS50eXBlUGFyYW1ldGVycyAmJiB0eXBlLnR5cGVOYW1lLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIGxhYmVsZWROb2RlLmxhYmVsID0gdHlwZS50eXBlTmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW52YWxpZFR1cGxlTWVtYmVyTGFiZWwsIHtcbiAgICAgICAgICBhdDogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgbGFiZWxlZE5vZGUubGFiZWwgPSB0eXBlO1xuICAgICAgfVxuXG4gICAgICBsYWJlbGVkTm9kZS5lbGVtZW50VHlwZSA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUobGFiZWxlZE5vZGUsIFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIpO1xuICAgIH0gZWxzZSBpZiAob3B0aW9uYWwpIHtcbiAgICAgIGNvbnN0IG9wdGlvbmFsVHlwZU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZSh0eXBlKTtcbiAgICAgIG9wdGlvbmFsVHlwZU5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShvcHRpb25hbFR5cGVOb2RlLCBcIlRTT3B0aW9uYWxUeXBlXCIpO1xuICAgIH1cblxuICAgIGlmIChyZXN0KSB7XG4gICAgICBjb25zdCByZXN0Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIHJlc3ROb2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUocmVzdE5vZGUsIFwiVFNSZXN0VHlwZVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHRzUGFyc2VQYXJlbnRoZXNpemVkVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTUGFyZW50aGVzaXplZFR5cGVcIik7XG4gIH1cblxuICB0c1BhcnNlRnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZSh0eXBlLCBhYnN0cmFjdCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgaWYgKHR5cGUgPT09IFwiVFNDb25zdHJ1Y3RvclR5cGVcIikge1xuICAgICAgbm9kZS5hYnN0cmFjdCA9ICEhYWJzdHJhY3Q7XG4gICAgICBpZiAoYWJzdHJhY3QpIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuXG4gICAgdGhpcy50c0luQWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzRmlsbFNpZ25hdHVyZSgxOSwgbm9kZSkpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gIH1cblxuICB0c1BhcnNlTGl0ZXJhbFR5cGVOb2RlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgbm9kZS5saXRlcmFsID0gKCgpID0+IHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMTMwOlxuICAgICAgICBjYXNlIDEzMTpcbiAgICAgICAgY2FzZSAxMjk6XG4gICAgICAgIGNhc2UgODU6XG4gICAgICAgIGNhc2UgODY6XG4gICAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwckF0b20oKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfVxuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNMaXRlcmFsVHlwZVwiKTtcbiAgfVxuXG4gIHRzUGFyc2VUZW1wbGF0ZUxpdGVyYWxUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubGl0ZXJhbCA9IHN1cGVyLnBhcnNlVGVtcGxhdGUoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0xpdGVyYWxUeXBlXCIpO1xuICB9XG5cbiAgcGFyc2VUZW1wbGF0ZVN1YnN0aXR1dGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pblR5cGUpIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKTtcbiAgfVxuXG4gIHRzUGFyc2VUaGlzVHlwZU9yVGhpc1R5cGVQcmVkaWNhdGUoKSB7XG4gICAgY29uc3QgdGhpc0tleXdvcmQgPSB0aGlzLnRzUGFyc2VUaGlzVHlwZU5vZGUoKTtcblxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMTMpICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVGhpc1R5cGVQcmVkaWNhdGUodGhpc0tleXdvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpc0tleXdvcmQ7XG4gICAgfVxuICB9XG5cbiAgdHNQYXJzZU5vbkFycmF5VHlwZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSAxMjk6XG4gICAgICBjYXNlIDEzMDpcbiAgICAgIGNhc2UgMTMxOlxuICAgICAgY2FzZSA4NTpcbiAgICAgIGNhc2UgODY6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VMaXRlcmFsVHlwZU5vZGUoKTtcblxuICAgICAgY2FzZSA1MzpcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiLVwiKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5sb29rYWhlYWQoKTtcblxuICAgICAgICAgIGlmIChuZXh0VG9rZW4udHlwZSAhPT0gMTMwICYmIG5leHRUb2tlbi50eXBlICE9PSAxMzEpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUubGl0ZXJhbCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTGl0ZXJhbFR5cGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA3ODpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVRoaXNUeXBlT3JUaGlzVHlwZVByZWRpY2F0ZSgpO1xuXG4gICAgICBjYXNlIDg3OlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZVF1ZXJ5KCk7XG5cbiAgICAgIGNhc2UgODM6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VJbXBvcnRUeXBlKCk7XG5cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNMb29rQWhlYWQodGhpcy50c0lzU3RhcnRPZk1hcHBlZFR5cGUuYmluZCh0aGlzKSkgPyB0aGlzLnRzUGFyc2VNYXBwZWRUeXBlKCkgOiB0aGlzLnRzUGFyc2VUeXBlTGl0ZXJhbCgpO1xuXG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUdXBsZVR5cGUoKTtcblxuICAgICAgY2FzZSAxMDpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVBhcmVudGhlc2l6ZWRUeXBlKCk7XG5cbiAgICAgIGNhc2UgMjU6XG4gICAgICBjYXNlIDI0OlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVGVtcGxhdGVMaXRlcmFsVHlwZSgpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHR5cGUpIHx8IHR5cGUgPT09IDg4IHx8IHR5cGUgPT09IDg0KSB7XG4gICAgICAgICAgICBjb25zdCBub2RlVHlwZSA9IHR5cGUgPT09IDg4ID8gXCJUU1ZvaWRLZXl3b3JkXCIgOiB0eXBlID09PSA4NCA/IFwiVFNOdWxsS2V5d29yZFwiIDoga2V5d29yZFR5cGVGcm9tTmFtZSh0aGlzLnN0YXRlLnZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKG5vZGVUeXBlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpICE9PSA0Nikge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbm9kZVR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZVJlZmVyZW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG5cbiAgdHNQYXJzZUFycmF5VHlwZU9ySGlnaGVyKCkge1xuICAgIGxldCB0eXBlID0gdGhpcy50c1BhcnNlTm9uQXJyYXlUeXBlKCk7XG5cbiAgICB3aGlsZSAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5lYXQoMCkpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDMpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZSh0eXBlKTtcbiAgICAgICAgbm9kZS5lbGVtZW50VHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNBcnJheVR5cGVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUodHlwZSk7XG4gICAgICAgIG5vZGUub2JqZWN0VHlwZSA9IHR5cGU7XG4gICAgICAgIG5vZGUuaW5kZXhUeXBlID0gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICB0c1BhcnNlVHlwZU9wZXJhdG9yKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGVPcGVyYXRvck9ySGlnaGVyKCk7XG5cbiAgICBpZiAob3BlcmF0b3IgPT09IFwicmVhZG9ubHlcIikge1xuICAgICAgdGhpcy50c0NoZWNrVHlwZUFubm90YXRpb25Gb3JSZWFkT25seShub2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlT3BlcmF0b3JcIik7XG4gIH1cblxuICB0c0NoZWNrVHlwZUFubm90YXRpb25Gb3JSZWFkT25seShub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGVBbm5vdGF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJUU1R1cGxlVHlwZVwiOlxuICAgICAgY2FzZSBcIlRTQXJyYXlUeXBlXCI6XG4gICAgICAgIHJldHVybjtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbmV4cGVjdGVkUmVhZG9ubHksIHtcbiAgICAgICAgICBhdDogbm9kZVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB0c1BhcnNlSW5mZXJUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMTIpO1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHR5cGVQYXJhbWV0ZXIubmFtZSA9IHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXJOYW1lKCk7XG4gICAgdHlwZVBhcmFtZXRlci5jb25zdHJhaW50ID0gdGhpcy50c1RyeVBhcnNlKCgpID0+IHRoaXMudHNQYXJzZUNvbnN0cmFpbnRGb3JJbmZlclR5cGUoKSk7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVyID0gdGhpcy5maW5pc2hOb2RlKHR5cGVQYXJhbWV0ZXIsIFwiVFNUeXBlUGFyYW1ldGVyXCIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0luZmVyVHlwZVwiKTtcbiAgfVxuXG4gIHRzUGFyc2VDb25zdHJhaW50Rm9ySW5mZXJUeXBlKCkge1xuICAgIGlmICh0aGlzLmVhdCg4MSkpIHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnQgPSB0aGlzLnRzSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCgpID0+IHRoaXMudHNQYXJzZVR5cGUoKSk7XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLmluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCB8fCAhdGhpcy5tYXRjaCgxNykpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdHNQYXJzZVR5cGVPcGVyYXRvck9ySGlnaGVyKCkge1xuICAgIGNvbnN0IGlzVHlwZU9wZXJhdG9yID0gdG9rZW5Jc1RTVHlwZU9wZXJhdG9yKHRoaXMuc3RhdGUudHlwZSkgJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgcmV0dXJuIGlzVHlwZU9wZXJhdG9yID8gdGhpcy50c1BhcnNlVHlwZU9wZXJhdG9yKCkgOiB0aGlzLmlzQ29udGV4dHVhbCgxMTIpID8gdGhpcy50c1BhcnNlSW5mZXJUeXBlKCkgOiB0aGlzLnRzSW5BbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCgpID0+IHRoaXMudHNQYXJzZUFycmF5VHlwZU9ySGlnaGVyKCkpO1xuICB9XG5cbiAgdHNQYXJzZVVuaW9uT3JJbnRlcnNlY3Rpb25UeXBlKGtpbmQsIHBhcnNlQ29uc3RpdHVlbnRUeXBlLCBvcGVyYXRvcikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IGhhc0xlYWRpbmdPcGVyYXRvciA9IHRoaXMuZWF0KG9wZXJhdG9yKTtcbiAgICBjb25zdCB0eXBlcyA9IFtdO1xuXG4gICAgZG8ge1xuICAgICAgdHlwZXMucHVzaChwYXJzZUNvbnN0aXR1ZW50VHlwZSgpKTtcbiAgICB9IHdoaWxlICh0aGlzLmVhdChvcGVyYXRvcikpO1xuXG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSAmJiAhaGFzTGVhZGluZ09wZXJhdG9yKSB7XG4gICAgICByZXR1cm4gdHlwZXNbMF07XG4gICAgfVxuXG4gICAgbm9kZS50eXBlcyA9IHR5cGVzO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwga2luZCk7XG4gIH1cblxuICB0c1BhcnNlSW50ZXJzZWN0aW9uVHlwZU9ySGlnaGVyKCkge1xuICAgIHJldHVybiB0aGlzLnRzUGFyc2VVbmlvbk9ySW50ZXJzZWN0aW9uVHlwZShcIlRTSW50ZXJzZWN0aW9uVHlwZVwiLCB0aGlzLnRzUGFyc2VUeXBlT3BlcmF0b3JPckhpZ2hlci5iaW5kKHRoaXMpLCA0NSk7XG4gIH1cblxuICB0c1BhcnNlVW5pb25UeXBlT3JIaWdoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZVVuaW9uT3JJbnRlcnNlY3Rpb25UeXBlKFwiVFNVbmlvblR5cGVcIiwgdGhpcy50c1BhcnNlSW50ZXJzZWN0aW9uVHlwZU9ySGlnaGVyLmJpbmQodGhpcyksIDQzKTtcbiAgfVxuXG4gIHRzSXNTdGFydE9mRnVuY3Rpb25UeXBlKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTApICYmIHRoaXMudHNMb29rQWhlYWQodGhpcy50c0lzVW5hbWJpZ3VvdXNseVN0YXJ0T2ZGdW5jdGlvblR5cGUuYmluZCh0aGlzKSk7XG4gIH1cblxuICB0c1NraXBQYXJhbWV0ZXJTdGFydCgpIHtcbiAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSB8fCB0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCg1KSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlcnJvcnNcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgcHJldmlvdXNFcnJvckNvdW50ID0gZXJyb3JzLmxlbmd0aDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5wYXJzZU9iamVjdExpa2UoOCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID09PSBwcmV2aW91c0Vycm9yQ291bnQ7XG4gICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCgwKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVycm9yc1xuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBwcmV2aW91c0Vycm9yQ291bnQgPSBlcnJvcnMubGVuZ3RoO1xuXG4gICAgICB0cnkge1xuICAgICAgICBzdXBlci5wYXJzZUJpbmRpbmdMaXN0KDMsIDkzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPT09IHByZXZpb3VzRXJyb3JDb3VudDtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0c0lzVW5hbWJpZ3VvdXNseVN0YXJ0T2ZGdW5jdGlvblR5cGUoKSB7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCgxMSkgfHwgdGhpcy5tYXRjaCgyMSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRzU2tpcFBhcmFtZXRlclN0YXJ0KCkpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDE0KSB8fCB0aGlzLm1hdGNoKDEyKSB8fCB0aGlzLm1hdGNoKDE3KSB8fCB0aGlzLm1hdGNoKDI5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDE5KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKHJldHVyblRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLmV4cGVjdChyZXR1cm5Ub2tlbik7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IGFzc2VydHMgPSAhIXRoaXMudHNUcnlQYXJzZSh0aGlzLnRzUGFyc2VUeXBlUHJlZGljYXRlQXNzZXJ0cy5iaW5kKHRoaXMpKTtcblxuICAgICAgaWYgKGFzc2VydHMgJiYgdGhpcy5tYXRjaCg3OCkpIHtcbiAgICAgICAgbGV0IHRoaXNUeXBlUHJlZGljYXRlID0gdGhpcy50c1BhcnNlVGhpc1R5cGVPclRoaXNUeXBlUHJlZGljYXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXNUeXBlUHJlZGljYXRlLnR5cGUgPT09IFwiVFNUaGlzVHlwZVwiKSB7XG4gICAgICAgICAgbm9kZS5wYXJhbWV0ZXJOYW1lID0gdGhpc1R5cGVQcmVkaWNhdGU7XG4gICAgICAgICAgbm9kZS5hc3NlcnRzID0gdHJ1ZTtcbiAgICAgICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gbnVsbDtcbiAgICAgICAgICB0aGlzVHlwZVByZWRpY2F0ZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVByZWRpY2F0ZVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKHRoaXNUeXBlUHJlZGljYXRlLCBub2RlKTtcbiAgICAgICAgICB0aGlzVHlwZVByZWRpY2F0ZS5hc3NlcnRzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHQudHlwZUFubm90YXRpb24gPSB0aGlzVHlwZVByZWRpY2F0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh0LCBcIlRTVHlwZUFubm90YXRpb25cIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR5cGVQcmVkaWNhdGVWYXJpYWJsZSA9IHRoaXMudHNJc0lkZW50aWZpZXIoKSAmJiB0aGlzLnRzVHJ5UGFyc2UodGhpcy50c1BhcnNlVHlwZVByZWRpY2F0ZVByZWZpeC5iaW5kKHRoaXMpKTtcblxuICAgICAgaWYgKCF0eXBlUHJlZGljYXRlVmFyaWFibGUpIHtcbiAgICAgICAgaWYgKCFhc3NlcnRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKGZhbHNlLCB0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUucGFyYW1ldGVyTmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgIG5vZGUuYXNzZXJ0cyA9IGFzc2VydHM7XG4gICAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSBudWxsO1xuICAgICAgICB0LnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHlwZSA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKGZhbHNlKTtcbiAgICAgIG5vZGUucGFyYW1ldGVyTmFtZSA9IHR5cGVQcmVkaWNhdGVWYXJpYWJsZTtcbiAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgbm9kZS5hc3NlcnRzID0gYXNzZXJ0cztcbiAgICAgIHQudHlwZUFubm90YXRpb24gPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQcmVkaWNhdGVcIik7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICB9KTtcbiAgfVxuXG4gIHRzVHJ5UGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNCkgPyB0aGlzLnRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbigxNCkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICB0c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTQpID8gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRzVHJ5UGFyc2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnRzRWF0VGhlblBhcnNlVHlwZSgxNCk7XG4gIH1cblxuICB0c1BhcnNlVHlwZVByZWRpY2F0ZVByZWZpeCgpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG5cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTEzKSAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICB9XG5cbiAgdHNQYXJzZVR5cGVQcmVkaWNhdGVBc3NlcnRzKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgIT09IDEwNikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRhaW5zRXNjID0gdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmICghdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSAmJiAhdGhpcy5tYXRjaCg3OCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbnNFc2MpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRFc2NhcGVkUmVzZXJ2ZWRXb3JkLCB7XG4gICAgICAgIGF0OiB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyxcbiAgICAgICAgcmVzZXJ2ZWRXb3JkOiBcImFzc2VydHNcIlxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB0c1BhcnNlVHlwZUFubm90YXRpb24oZWF0Q29sb24gPSB0cnVlLCB0ID0gdGhpcy5zdGFydE5vZGUoKSkge1xuICAgIHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgaWYgKGVhdENvbG9uKSB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICB0LnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodCwgXCJUU1R5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG5cbiAgdHNQYXJzZVR5cGUoKSB7XG4gICAgYXNzZXJ0KHRoaXMuc3RhdGUuaW5UeXBlKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1BhcnNlTm9uQ29uZGl0aW9uYWxUeXBlKCk7XG5cbiAgICBpZiAodGhpcy5zdGF0ZS5pbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQgfHwgdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSB8fCAhdGhpcy5lYXQoODEpKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUodHlwZSk7XG4gICAgbm9kZS5jaGVja1R5cGUgPSB0eXBlO1xuICAgIG5vZGUuZXh0ZW5kc1R5cGUgPSB0aGlzLnRzSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCgpID0+IHRoaXMudHNQYXJzZU5vbkNvbmRpdGlvbmFsVHlwZSgpKTtcbiAgICB0aGlzLmV4cGVjdCgxNyk7XG4gICAgbm9kZS50cnVlVHlwZSA9IHRoaXMudHNJbkFsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQoKCkgPT4gdGhpcy50c1BhcnNlVHlwZSgpKTtcbiAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgbm9kZS5mYWxzZVR5cGUgPSB0aGlzLnRzSW5BbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCgpID0+IHRoaXMudHNQYXJzZVR5cGUoKSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTQ29uZGl0aW9uYWxUeXBlXCIpO1xuICB9XG5cbiAgaXNBYnN0cmFjdENvbnN0cnVjdG9yU2lnbmF0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLmlzQ29udGV4dHVhbCgxMjApICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gNzc7XG4gIH1cblxuICB0c1BhcnNlTm9uQ29uZGl0aW9uYWxUeXBlKCkge1xuICAgIGlmICh0aGlzLnRzSXNTdGFydE9mRnVuY3Rpb25UeXBlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKFwiVFNGdW5jdGlvblR5cGVcIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF0Y2goNzcpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlRnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZShcIlRTQ29uc3RydWN0b3JUeXBlXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0Fic3RyYWN0Q29uc3RydWN0b3JTaWduYXR1cmUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUZ1bmN0aW9uT3JDb25zdHJ1Y3RvclR5cGUoXCJUU0NvbnN0cnVjdG9yVHlwZVwiLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50c1BhcnNlVW5pb25UeXBlT3JIaWdoZXIoKTtcbiAgfVxuXG4gIHRzUGFyc2VUeXBlQXNzZXJ0aW9uKCkge1xuICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInR5cGVzY3JpcHRcIiwgXCJkaXNhbGxvd0FtYmlndW91c0pTWExpa2VcIikpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuUmVzZXJ2ZWRUeXBlQXNzZXJ0aW9uLCB7XG4gICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIGNvbnN0IF9jb25zdCA9IHRoaXMudHNUcnlOZXh0UGFyc2VDb25zdGFudENvbnRleHQoKTtcblxuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSBfY29uc3QgfHwgdGhpcy50c05leHRUaGVuUGFyc2VUeXBlKCk7XG4gICAgdGhpcy5leHBlY3QoNDgpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUFzc2VydGlvblwiKTtcbiAgfVxuXG4gIHRzUGFyc2VIZXJpdGFnZUNsYXVzZSh0b2tlbikge1xuICAgIGNvbnN0IG9yaWdpbmFsU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGRlbGltaXRlZExpc3QgPSB0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KFwiSGVyaXRhZ2VDbGF1c2VFbGVtZW50XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy50c1BhcnNlRW50aXR5TmFtZSgpO1xuXG4gICAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFkZWxpbWl0ZWRMaXN0Lmxlbmd0aCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5FbXB0eUhlcml0YWdlQ2xhdXNlVHlwZSwge1xuICAgICAgICBhdDogb3JpZ2luYWxTdGFydExvYyxcbiAgICAgICAgdG9rZW5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBkZWxpbWl0ZWRMaXN0O1xuICB9XG5cbiAgdHNQYXJzZUludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUsIHByb3BlcnRpZXMgPSB7fSkge1xuICAgIGlmICh0aGlzLmhhc0ZvbGxvd2luZ0xpbmVCcmVhaygpKSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTI1KTtcbiAgICBpZiAocHJvcGVydGllcy5kZWNsYXJlKSBub2RlLmRlY2xhcmUgPSB0cnVlO1xuXG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgQklORF9UU19JTlRFUkZBQ0UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuTWlzc2luZ0ludGVyZmFjZU5hbWUsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VJbk91dE1vZGlmaWVycy5iaW5kKHRoaXMpKTtcblxuICAgIGlmICh0aGlzLmVhdCg4MSkpIHtcbiAgICAgIG5vZGUuZXh0ZW5kcyA9IHRoaXMudHNQYXJzZUhlcml0YWdlQ2xhdXNlKFwiZXh0ZW5kc1wiKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBib2R5LmJvZHkgPSB0aGlzLnRzSW5UeXBlKHRoaXMudHNQYXJzZU9iamVjdFR5cGVNZW1iZXJzLmJpbmQodGhpcykpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMuZmluaXNoTm9kZShib2R5LCBcIlRTSW50ZXJmYWNlQm9keVwiKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiKTtcbiAgfVxuXG4gIHRzUGFyc2VUeXBlQWxpYXNEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgQklORF9UU19UWVBFKTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c0luVHlwZSgoKSA9PiB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlSW5PdXRNb2RpZmllcnMuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmV4cGVjdCgyOSk7XG5cbiAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMTEpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSAhPT0gMTYpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNJbnRyaW5zaWNLZXl3b3JkXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIik7XG4gIH1cblxuICB0c0luTm9Db250ZXh0KGNiKSB7XG4gICAgY29uc3Qgb2xkQ29udGV4dCA9IHRoaXMuc3RhdGUuY29udGV4dDtcbiAgICB0aGlzLnN0YXRlLmNvbnRleHQgPSBbb2xkQ29udGV4dFswXV07XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuY29udGV4dCA9IG9sZENvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgdHNJblR5cGUoY2IpIHtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIH1cbiAgfVxuXG4gIHRzSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KGNiKSB7XG4gICAgY29uc3Qgb2xkSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gdGhpcy5zdGF0ZS5pbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQ7XG4gICAgdGhpcy5zdGF0ZS5pbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQgPSB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnN0YXRlLmluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IG9sZEluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICB0c0luQWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dChjYikge1xuICAgIGNvbnN0IG9sZEluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0O1xuICAgIHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gb2xkSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIHRzRWF0VGhlblBhcnNlVHlwZSh0b2tlbikge1xuICAgIHJldHVybiAhdGhpcy5tYXRjaCh0b2tlbikgPyB1bmRlZmluZWQgOiB0aGlzLnRzTmV4dFRoZW5QYXJzZVR5cGUoKTtcbiAgfVxuXG4gIHRzRXhwZWN0VGhlblBhcnNlVHlwZSh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLnRzRG9UaGVuUGFyc2VUeXBlKCgpID0+IHRoaXMuZXhwZWN0KHRva2VuKSk7XG4gIH1cblxuICB0c05leHRUaGVuUGFyc2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnRzRG9UaGVuUGFyc2VUeXBlKCgpID0+IHRoaXMubmV4dCgpKTtcbiAgfVxuXG4gIHRzRG9UaGVuUGFyc2VUeXBlKGNiKSB7XG4gICAgcmV0dXJuIHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgY2IoKTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSk7XG4gIH1cblxuICB0c1BhcnNlRW51bU1lbWJlcigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmlkID0gdGhpcy5tYXRjaCgxMjkpID8gc3VwZXIucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpIDogdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG5cbiAgICBpZiAodGhpcy5lYXQoMjkpKSB7XG4gICAgICBub2RlLmluaXRpYWxpemVyID0gc3VwZXIucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNFbnVtTWVtYmVyXCIpO1xuICB9XG5cbiAgdHNQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlLCBwcm9wZXJ0aWVzID0ge30pIHtcbiAgICBpZiAocHJvcGVydGllcy5jb25zdCkgbm9kZS5jb25zdCA9IHRydWU7XG4gICAgaWYgKHByb3BlcnRpZXMuZGVjbGFyZSkgbm9kZS5kZWNsYXJlID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTIyKTtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCBub2RlLmNvbnN0ID8gQklORF9UU19DT05TVF9FTlVNIDogQklORF9UU19FTlVNKTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBub2RlLm1lbWJlcnMgPSB0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KFwiRW51bU1lbWJlcnNcIiwgdGhpcy50c1BhcnNlRW51bU1lbWJlci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNFbnVtRGVjbGFyYXRpb25cIik7XG4gIH1cblxuICB0c1BhcnNlTW9kdWxlQmxvY2soKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5zY29wZS5lbnRlcihTQ09QRV9PVEhFUik7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgc3VwZXIucGFyc2VCbG9ja09yTW9kdWxlQmxvY2tCb2R5KG5vZGUuYm9keSA9IFtdLCB1bmRlZmluZWQsIHRydWUsIDgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU01vZHVsZUJsb2NrXCIpO1xuICB9XG5cbiAgdHNQYXJzZU1vZHVsZU9yTmFtZXNwYWNlRGVjbGFyYXRpb24obm9kZSwgbmVzdGVkID0gZmFsc2UpIHtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcblxuICAgIGlmICghbmVzdGVkKSB7XG4gICAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCBCSU5EX1RTX05BTUVTUEFDRSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy50c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbihpbm5lciwgdHJ1ZSk7XG4gICAgICBub2RlLmJvZHkgPSBpbm5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY29wZS5lbnRlcihTQ09QRV9UU19NT0RVTEUpO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoUEFSQU0pO1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy50c1BhcnNlTW9kdWxlQmxvY2soKTtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU01vZHVsZURlY2xhcmF0aW9uXCIpO1xuICB9XG5cbiAgdHNQYXJzZUFtYmllbnRFeHRlcm5hbE1vZHVsZURlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTA5KSkge1xuICAgICAgbm9kZS5nbG9iYWwgPSB0cnVlO1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDEyOSkpIHtcbiAgICAgIG5vZGUuaWQgPSBzdXBlci5wYXJzZVN0cmluZ0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGNoKDUpKSB7XG4gICAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX1RTX01PRFVMRSk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihQQVJBTSk7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnRzUGFyc2VNb2R1bGVCbG9jaygpO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIik7XG4gIH1cblxuICB0c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZSwgaXNFeHBvcnQpIHtcbiAgICBub2RlLmlzRXhwb3J0ID0gaXNFeHBvcnQgfHwgZmFsc2U7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgQklORF9MRVhJQ0FMKTtcbiAgICB0aGlzLmV4cGVjdCgyOSk7XG4gICAgY29uc3QgbW9kdWxlUmVmZXJlbmNlID0gdGhpcy50c1BhcnNlTW9kdWxlUmVmZXJlbmNlKCk7XG5cbiAgICBpZiAobm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiAmJiBtb2R1bGVSZWZlcmVuY2UudHlwZSAhPT0gXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW1wb3J0QWxpYXNIYXNJbXBvcnRUeXBlLCB7XG4gICAgICAgIGF0OiBtb2R1bGVSZWZlcmVuY2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG5vZGUubW9kdWxlUmVmZXJlbmNlID0gbW9kdWxlUmVmZXJlbmNlO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIik7XG4gIH1cblxuICB0c0lzRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKDExNikgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA0MDtcbiAgfVxuXG4gIHRzUGFyc2VNb2R1bGVSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNJc0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKCkgPyB0aGlzLnRzUGFyc2VFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSgpIDogdGhpcy50c1BhcnNlRW50aXR5TmFtZShmYWxzZSk7XG4gIH1cblxuICB0c1BhcnNlRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDExNik7XG4gICAgdGhpcy5leHBlY3QoMTApO1xuXG4gICAgaWYgKCF0aGlzLm1hdGNoKDEyOSkpIHtcbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHN1cGVyLnBhcnNlRXhwckF0b20oKTtcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIik7XG4gIH1cblxuICB0c0xvb2tBaGVhZChmKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgY29uc3QgcmVzID0gZigpO1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgdHNUcnlQYXJzZUFuZENhdGNoKGYpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IGYoKSB8fCBhYm9ydCgpKTtcbiAgICBpZiAocmVzdWx0LmFib3J0ZWQgfHwgIXJlc3VsdC5ub2RlKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmIChyZXN1bHQuZXJyb3IpIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgIHJldHVybiByZXN1bHQubm9kZTtcbiAgfVxuXG4gIHRzVHJ5UGFyc2UoZikge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGYoKTtcblxuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHRzVHJ5UGFyc2VEZWNsYXJlKG5hbnkpIHtcbiAgICBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnR0eXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIGxldCBraW5kO1xuXG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDk5KSkge1xuICAgICAgc3RhcnR0eXBlID0gNzQ7XG4gICAgICBraW5kID0gXCJsZXRcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50c0luQW1iaWVudENvbnRleHQoKCkgPT4ge1xuICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gNjgpIHtcbiAgICAgICAgbmFueS5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobmFueSwgZmFsc2UsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnR0eXBlID09PSA4MCkge1xuICAgICAgICBuYW55LmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5hbnksIHRydWUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gMTIyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24obmFueSwge1xuICAgICAgICAgIGRlY2xhcmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydHR5cGUgPT09IDEwOSkge1xuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlQW1iaWVudEV4dGVybmFsTW9kdWxlRGVjbGFyYXRpb24obmFueSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydHR5cGUgPT09IDc1IHx8IHN0YXJ0dHlwZSA9PT0gNzQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoKDc1KSB8fCAhdGhpcy5pc0xvb2thaGVhZENvbnRleHR1YWwoXCJlbnVtXCIpKSB7XG4gICAgICAgICAgbmFueS5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChuYW55LCBraW5kIHx8IHRoaXMuc3RhdGUudmFsdWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5leHBlY3QoNzUpO1xuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlRW51bURlY2xhcmF0aW9uKG5hbnksIHtcbiAgICAgICAgICBjb25zdDogdHJ1ZSxcbiAgICAgICAgICBkZWNsYXJlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnR0eXBlID09PSAxMjUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24obmFueSwge1xuICAgICAgICAgIGRlY2xhcmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbklzSWRlbnRpZmllcihzdGFydHR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VEZWNsYXJhdGlvbihuYW55LCB0aGlzLnN0YXRlLnZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRzVHJ5UGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50c1BhcnNlRGVjbGFyYXRpb24odGhpcy5zdGFydE5vZGUoKSwgdGhpcy5zdGF0ZS52YWx1ZSwgdHJ1ZSk7XG4gIH1cblxuICB0c1BhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSB7XG4gICAgc3dpdGNoIChleHByLm5hbWUpIHtcbiAgICAgIGNhc2UgXCJkZWNsYXJlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IHRoaXMudHNUcnlQYXJzZURlY2xhcmUobm9kZSk7XG5cbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlY2xhcmF0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJnbG9iYWxcIjpcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgICAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX1RTX01PRFVMRSk7XG4gICAgICAgICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoUEFSQU0pO1xuICAgICAgICAgIGNvbnN0IG1vZCA9IG5vZGU7XG4gICAgICAgICAgbW9kLmdsb2JhbCA9IHRydWU7XG4gICAgICAgICAgbW9kLmlkID0gZXhwcjtcbiAgICAgICAgICBtb2QuYm9keSA9IHRoaXMudHNQYXJzZU1vZHVsZUJsb2NrKCk7XG4gICAgICAgICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobW9kLCBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZURlY2xhcmF0aW9uKG5vZGUsIGV4cHIubmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHRzUGFyc2VEZWNsYXJhdGlvbihub2RlLCB2YWx1ZSwgbmV4dCkge1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgXCJhYnN0cmFjdFwiOlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3IobmV4dCkgJiYgKHRoaXMubWF0Y2goODApIHx8IHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUFic3RyYWN0RGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIm1vZHVsZVwiOlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3IobmV4dCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5tYXRjaCgxMjkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlQW1iaWVudEV4dGVybmFsTW9kdWxlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIm5hbWVzcGFjZVwiOlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3IobmV4dCkgJiYgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VNb2R1bGVPck5hbWVzcGFjZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgIGlmICh0aGlzLnRzQ2hlY2tMaW5lVGVybWluYXRvcihuZXh0KSAmJiB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVBbGlhc0RlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdHNDaGVja0xpbmVUZXJtaW5hdG9yKG5leHQpIHtcbiAgICBpZiAobmV4dCkge1xuICAgICAgaWYgKHRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuICF0aGlzLmlzTGluZVRlcm1pbmF0b3IoKTtcbiAgfVxuXG4gIHRzVHJ5UGFyc2VHZW5lcmljQXN5bmNBcnJvd0Z1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYykge1xuICAgIGlmICghdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0cnVlO1xuICAgIGNvbnN0IHJlcyA9IHRoaXMudHNUcnlQYXJzZUFuZENhdGNoKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlcnMoKTtcbiAgICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5leHBlY3QoMTkpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycztcblxuICAgIGlmICghcmVzKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZUFycm93RXhwcmVzc2lvbihyZXMsIG51bGwsIHRydWUpO1xuICB9XG5cbiAgdHNQYXJzZVR5cGVBcmd1bWVudHNJbkV4cHJlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMucmVTY2FuX2x0KCkgIT09IDQ3KSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG4gIH1cblxuICB0c1BhcnNlVHlwZUFyZ3VtZW50cygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMudHNJblR5cGUoKCkgPT4gdGhpcy50c0luTm9Db250ZXh0KCgpID0+IHtcbiAgICAgIHRoaXMuZXhwZWN0KDQ3KTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KFwiVHlwZVBhcmFtZXRlcnNPckFyZ3VtZW50c1wiLCB0aGlzLnRzUGFyc2VUeXBlLmJpbmQodGhpcykpO1xuICAgIH0pKTtcblxuICAgIGlmIChub2RlLnBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRW1wdHlUeXBlQXJndW1lbnRzLCB7XG4gICAgICAgIGF0OiBub2RlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdCg0OCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIik7XG4gIH1cblxuICB0c0lzRGVjbGFyYXRpb25TdGFydCgpIHtcbiAgICByZXR1cm4gdG9rZW5Jc1RTRGVjbGFyYXRpb25TdGFydCh0aGlzLnN0YXRlLnR5cGUpO1xuICB9XG5cbiAgaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgIGlmICh0aGlzLnRzSXNEZWNsYXJhdGlvblN0YXJ0KCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc3VwZXIuaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCk7XG4gIH1cblxuICBwYXJzZUFzc2lnbmFibGVMaXN0SXRlbShhbGxvd01vZGlmaWVycywgZGVjb3JhdG9ycykge1xuICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbGV0IGFjY2Vzc2liaWxpdHk7XG4gICAgbGV0IHJlYWRvbmx5ID0gZmFsc2U7XG4gICAgbGV0IG92ZXJyaWRlID0gZmFsc2U7XG5cbiAgICBpZiAoYWxsb3dNb2RpZmllcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbW9kaWZpZWQgPSB7fTtcbiAgICAgIHRoaXMudHNQYXJzZU1vZGlmaWVycyh7XG4gICAgICAgIG1vZGlmaWVkLFxuICAgICAgICBhbGxvd2VkTW9kaWZpZXJzOiBbXCJwdWJsaWNcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwib3ZlcnJpZGVcIiwgXCJyZWFkb25seVwiXVxuICAgICAgfSk7XG4gICAgICBhY2Nlc3NpYmlsaXR5ID0gbW9kaWZpZWQuYWNjZXNzaWJpbGl0eTtcbiAgICAgIG92ZXJyaWRlID0gbW9kaWZpZWQub3ZlcnJpZGU7XG4gICAgICByZWFkb25seSA9IG1vZGlmaWVkLnJlYWRvbmx5O1xuXG4gICAgICBpZiAoYWxsb3dNb2RpZmllcnMgPT09IGZhbHNlICYmIChhY2Nlc3NpYmlsaXR5IHx8IHJlYWRvbmx5IHx8IG92ZXJyaWRlKSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlVuZXhwZWN0ZWRQYXJhbWV0ZXJNb2RpZmllciwge1xuICAgICAgICAgIGF0OiBzdGFydExvY1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCgpO1xuICAgIHRoaXMucGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW1UeXBlcyhsZWZ0KTtcbiAgICBjb25zdCBlbHQgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KGxlZnQuc3RhcnQsIGxlZnQubG9jLnN0YXJ0LCBsZWZ0KTtcblxuICAgIGlmIChhY2Nlc3NpYmlsaXR5IHx8IHJlYWRvbmx5IHx8IG92ZXJyaWRlKSB7XG4gICAgICBjb25zdCBwcCA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcblxuICAgICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgIHBwLmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWNjZXNzaWJpbGl0eSkgcHAuYWNjZXNzaWJpbGl0eSA9IGFjY2Vzc2liaWxpdHk7XG4gICAgICBpZiAocmVhZG9ubHkpIHBwLnJlYWRvbmx5ID0gcmVhZG9ubHk7XG4gICAgICBpZiAob3ZlcnJpZGUpIHBwLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG5cbiAgICAgIGlmIChlbHQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgZWx0LnR5cGUgIT09IFwiQXNzaWdubWVudFBhdHRlcm5cIikge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlVuc3VwcG9ydGVkUGFyYW1ldGVyUHJvcGVydHlLaW5kLCB7XG4gICAgICAgICAgYXQ6IHBwXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBwcC5wYXJhbWV0ZXIgPSBlbHQ7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBwLCBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIik7XG4gICAgfVxuXG4gICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICBsZWZ0LmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzO1xuICAgIH1cblxuICAgIHJldHVybiBlbHQ7XG4gIH1cblxuICBpc1NpbXBsZVBhcmFtZXRlcihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJUU1BhcmFtZXRlclByb3BlcnR5XCIgJiYgc3VwZXIuaXNTaW1wbGVQYXJhbWV0ZXIobm9kZS5wYXJhbWV0ZXIpIHx8IHN1cGVyLmlzU2ltcGxlUGFyYW1ldGVyKG5vZGUpO1xuICB9XG5cbiAgcGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2gobm9kZSwgdHlwZSwgaXNNZXRob2QgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy50c1BhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24oMTQpO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZGlsZXNzVHlwZSA9IHR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiID8gXCJUU0RlY2xhcmVGdW5jdGlvblwiIDogdHlwZSA9PT0gXCJDbGFzc01ldGhvZFwiIHx8IHR5cGUgPT09IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIgPyBcIlRTRGVjbGFyZU1ldGhvZFwiIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGJvZGlsZXNzVHlwZSAmJiAhdGhpcy5tYXRjaCg1KSAmJiB0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBib2RpbGVzc1R5cGUpO1xuICAgIH1cblxuICAgIGlmIChib2RpbGVzc1R5cGUgPT09IFwiVFNEZWNsYXJlRnVuY3Rpb25cIiAmJiB0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRGVjbGFyZUZ1bmN0aW9uSGFzSW1wbGVtZW50YXRpb24sIHtcbiAgICAgICAgYXQ6IG5vZGVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobm9kZS5kZWNsYXJlKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCBib2RpbGVzc1R5cGUsIGlzTWV0aG9kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2gobm9kZSwgdHlwZSwgaXNNZXRob2QpO1xuICB9XG5cbiAgcmVnaXN0ZXJGdW5jdGlvblN0YXRlbWVudElkKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuYm9keSAmJiBub2RlLmlkKSB7XG4gICAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCBCSU5EX1RTX0FNQklFTlQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5yZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgdHNDaGVja0ZvckludmFsaWRUeXBlQ2FzdHMoaXRlbXMpIHtcbiAgICBpdGVtcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaWYgKChub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLnR5cGUpID09PSBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbmV4cGVjdGVkVHlwZUFubm90YXRpb24sIHtcbiAgICAgICAgICBhdDogbm9kZS50eXBlQW5ub3RhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRvUmVmZXJlbmNlZExpc3QoZXhwckxpc3QsIGlzSW5QYXJlbnMpIHtcbiAgICB0aGlzLnRzQ2hlY2tGb3JJbnZhbGlkVHlwZUNhc3RzKGV4cHJMaXN0KTtcbiAgICByZXR1cm4gZXhwckxpc3Q7XG4gIH1cblxuICBwYXJzZUFycmF5TGlrZShjbG9zZSwgY2FuQmVQYXR0ZXJuLCBpc1R1cGxlLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlQXJyYXlMaWtlKGNsb3NlLCBjYW5CZVBhdHRlcm4sIGlzVHVwbGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIikge1xuICAgICAgdGhpcy50c0NoZWNrRm9ySW52YWxpZFR5cGVDYXN0cyhub2RlLmVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgc3RhdGUpIHtcbiAgICBpZiAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5tYXRjaCgzNSkpIHtcbiAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IG5vbk51bGxFeHByZXNzaW9uID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9uTnVsbEV4cHJlc3Npb24uZXhwcmVzc2lvbiA9IGJhc2U7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vbk51bGxFeHByZXNzaW9uLCBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIik7XG4gICAgfVxuXG4gICAgbGV0IGlzT3B0aW9uYWxDYWxsID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5tYXRjaCgxOCkgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA2MCkge1xuICAgICAgaWYgKG5vQ2FsbHMpIHtcbiAgICAgICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyID0gaXNPcHRpb25hbENhbGwgPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goNTEpKSB7XG4gICAgICBsZXQgbWlzc2luZ1BhcmVuRXJyb3JMb2M7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRzVHJ5UGFyc2VBbmRDYXRjaCgoKSA9PiB7XG4gICAgICAgIGlmICghbm9DYWxscyAmJiB0aGlzLmF0UG9zc2libGVBc3luY0Fycm93KGJhc2UpKSB7XG4gICAgICAgICAgY29uc3QgYXN5bmNBcnJvd0ZuID0gdGhpcy50c1RyeVBhcnNlR2VuZXJpY0FzeW5jQXJyb3dGdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MpO1xuXG4gICAgICAgICAgaWYgKGFzeW5jQXJyb3dGbikge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jQXJyb3dGbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0eXBlQXJndW1lbnRzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50c0luRXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAoIXR5cGVBcmd1bWVudHMpIHJldHVybjtcblxuICAgICAgICBpZiAoaXNPcHRpb25hbENhbGwgJiYgIXRoaXMubWF0Y2goMTApKSB7XG4gICAgICAgICAgbWlzc2luZ1BhcmVuRXJyb3JMb2MgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuSXNUZW1wbGF0ZSh0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIucGFyc2VUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBzdGF0ZSk7XG4gICAgICAgICAgcmVzdWx0LnR5cGVQYXJhbWV0ZXJzID0gdHlwZUFyZ3VtZW50cztcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFub0NhbGxzICYmIHRoaXMuZWF0KDEwKSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgICAgbm9kZS5jYWxsZWUgPSBiYXNlO1xuICAgICAgICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKDExLCBmYWxzZSk7XG4gICAgICAgICAgdGhpcy50c0NoZWNrRm9ySW52YWxpZFR5cGVDYXN0cyhub2RlLmFyZ3VtZW50cyk7XG4gICAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVBcmd1bWVudHM7XG5cbiAgICAgICAgICBpZiAoc3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcikge1xuICAgICAgICAgICAgbm9kZS5vcHRpb25hbCA9IGlzT3B0aW9uYWxDYWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaENhbGxFeHByZXNzaW9uKG5vZGUsIHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuXG4gICAgICAgIGlmICh0b2tlblR5cGUgPT09IDQ4IHx8IHRva2VuVHlwZSAhPT0gMTAgJiYgdG9rZW5DYW5TdGFydEV4cHJlc3Npb24odG9rZW5UeXBlKSAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IGJhc2U7XG4gICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlQXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvblwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobWlzc2luZ1BhcmVuRXJyb3JMb2MpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKG1pc3NpbmdQYXJlbkVycm9yTG9jLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIiAmJiAodGhpcy5tYXRjaCgxNikgfHwgdGhpcy5tYXRjaCgxOCkgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpICE9PSA0MCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkludmFsaWRQcm9wZXJ0eUFjY2Vzc0FmdGVySW5zdGFudGlhdGlvbkV4cHJlc3Npb24sIHtcbiAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKTtcbiAgfVxuXG4gIHBhcnNlTmV3Q2FsbGVlKG5vZGUpIHtcbiAgICB2YXIgX2NhbGxlZSRleHRyYTtcblxuICAgIHN1cGVyLnBhcnNlTmV3Q2FsbGVlKG5vZGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbGxlZVxuICAgIH0gPSBub2RlO1xuXG4gICAgaWYgKGNhbGxlZS50eXBlID09PSBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIiAmJiAhKChfY2FsbGVlJGV4dHJhID0gY2FsbGVlLmV4dHJhKSAhPSBudWxsICYmIF9jYWxsZWUkZXh0cmEucGFyZW50aGVzaXplZCkpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBjYWxsZWUudHlwZVBhcmFtZXRlcnM7XG4gICAgICBub2RlLmNhbGxlZSA9IGNhbGxlZS5leHByZXNzaW9uO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlRXhwck9wKGxlZnQsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjKSB7XG4gICAgaWYgKHRva2VuT3BlcmF0b3JQcmVjZWRlbmNlKDU4KSA+IG1pblByZWMgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5pc0NvbnRleHR1YWwoOTMpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSBsZWZ0O1xuXG4gICAgICBjb25zdCBfY29uc3QgPSB0aGlzLnRzVHJ5TmV4dFBhcnNlQ29uc3RhbnRDb250ZXh0KCk7XG5cbiAgICAgIGlmIChfY29uc3QpIHtcbiAgICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IF9jb25zdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzTmV4dFRoZW5QYXJzZVR5cGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNBc0V4cHJlc3Npb25cIik7XG4gICAgICB0aGlzLnJlU2Nhbl9sdF9ndCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3Aobm9kZSwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cHJPcChsZWZ0LCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYyk7XG4gIH1cblxuICBjaGVja1Jlc2VydmVkV29yZCh3b3JkLCBzdGFydExvYywgY2hlY2tLZXl3b3JkcywgaXNCaW5kaW5nKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQpIHtcbiAgICAgIHN1cGVyLmNoZWNrUmVzZXJ2ZWRXb3JkKHdvcmQsIHN0YXJ0TG9jLCBjaGVja0tleXdvcmRzLCBpc0JpbmRpbmcpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRHVwbGljYXRlRXhwb3J0cygpIHt9XG5cbiAgcGFyc2VJbXBvcnQobm9kZSkge1xuICAgIG5vZGUuaW1wb3J0S2luZCA9IFwidmFsdWVcIjtcblxuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpIHx8IHRoaXMubWF0Y2goNTUpIHx8IHRoaXMubWF0Y2goNSkpIHtcbiAgICAgIGxldCBhaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG5cbiAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjYpICYmIGFoZWFkLnR5cGUgIT09IDEyICYmIGFoZWFkLnR5cGUgIT09IDk3ICYmIGFoZWFkLnR5cGUgIT09IDI5KSB7XG4gICAgICAgIG5vZGUuaW1wb3J0S2luZCA9IFwidHlwZVwiO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSAmJiBhaGVhZC50eXBlID09PSAyOSkge1xuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW1wb3J0Tm9kZSA9IHN1cGVyLnBhcnNlSW1wb3J0KG5vZGUpO1xuXG4gICAgaWYgKGltcG9ydE5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgJiYgaW1wb3J0Tm9kZS5zcGVjaWZpZXJzLmxlbmd0aCA+IDEgJiYgaW1wb3J0Tm9kZS5zcGVjaWZpZXJzWzBdLnR5cGUgPT09IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlR5cGVJbXBvcnRDYW5ub3RTcGVjaWZ5RGVmYXVsdEFuZE5hbWVkLCB7XG4gICAgICAgIGF0OiBpbXBvcnROb2RlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1wb3J0Tm9kZTtcbiAgfVxuXG4gIHBhcnNlRXhwb3J0KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg4MykpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI2KSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgIT09IDYxKSB7XG4gICAgICAgIG5vZGUuaW1wb3J0S2luZCA9IFwidHlwZVwiO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuaW1wb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKG5vZGUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYXQoMjkpKSB7XG4gICAgICBjb25zdCBhc3NpZ24gPSBub2RlO1xuICAgICAgYXNzaWduLmV4cHJlc3Npb24gPSBzdXBlci5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGFzc2lnbiwgXCJUU0V4cG9ydEFzc2lnbm1lbnRcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdENvbnRleHR1YWwoOTMpKSB7XG4gICAgICBjb25zdCBkZWNsID0gbm9kZTtcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMjQpO1xuICAgICAgZGVjbC5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjYpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gNSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydChub2RlKTtcbiAgICB9XG4gIH1cblxuICBpc0Fic3RyYWN0Q2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKDEyMCkgJiYgdGhpcy5sb29rYWhlYWQoKS50eXBlID09PSA4MDtcbiAgfVxuXG4gIHBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMuaXNBYnN0cmFjdENsYXNzKCkpIHtcbiAgICAgIGNvbnN0IGNscyA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNscy5hYnN0cmFjdCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKGNscywgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF0Y2goMTI1KSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24odGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCk7XG4gIH1cblxuICBwYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplciA9IGZhbHNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNBbWJpZW50Q29udGV4dFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gc3VwZXIucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgfHwgaXNBbWJpZW50Q29udGV4dCk7XG4gICAgaWYgKCFpc0FtYmllbnRDb250ZXh0KSByZXR1cm4gZGVjbGFyYXRpb247XG5cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgaW5pdFxuICAgIH0gb2YgZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zKSB7XG4gICAgICBpZiAoIWluaXQpIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoa2luZCAhPT0gXCJjb25zdFwiIHx8ICEhaWQudHlwZUFubm90YXRpb24pIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5Jbml0aWFsaXplck5vdEFsbG93ZWRJbkFtYmllbnRDb250ZXh0LCB7XG4gICAgICAgICAgYXQ6IGluaXRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGluaXQudHlwZSAhPT0gXCJTdHJpbmdMaXRlcmFsXCIgJiYgaW5pdC50eXBlICE9PSBcIkJvb2xlYW5MaXRlcmFsXCIgJiYgaW5pdC50eXBlICE9PSBcIk51bWVyaWNMaXRlcmFsXCIgJiYgaW5pdC50eXBlICE9PSBcIkJpZ0ludExpdGVyYWxcIiAmJiAoaW5pdC50eXBlICE9PSBcIlRlbXBsYXRlTGl0ZXJhbFwiIHx8IGluaXQuZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkgJiYgIWlzUG9zc2libHlMaXRlcmFsRW51bShpbml0KSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkNvbnN0SW5pdGlhaWxpemVyTXVzdEJlU3RyaW5nT3JOdW1lcmljTGl0ZXJhbE9yTGl0ZXJhbEVudW1SZWZlcmVuY2UsIHtcbiAgICAgICAgICBhdDogaW5pdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gIH1cblxuICBwYXJzZVN0YXRlbWVudENvbnRlbnQoY29udGV4dCwgdG9wTGV2ZWwpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg3NSkgJiYgdGhpcy5pc0xvb2thaGVhZENvbnRleHR1YWwoXCJlbnVtXCIpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMuZXhwZWN0KDc1KTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSwge1xuICAgICAgICBjb25zdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyMikpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24odGhpcy5zdGFydE5vZGUoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNSkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHNQYXJzZUludGVyZmFjZURlY2xhcmF0aW9uKHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucGFyc2VTdGF0ZW1lbnRDb250ZW50KGNvbnRleHQsIHRvcExldmVsKTtcbiAgfVxuXG4gIHBhcnNlQWNjZXNzTW9kaWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZU1vZGlmaWVyKFtcInB1YmxpY1wiLCBcInByb3RlY3RlZFwiLCBcInByaXZhdGVcIl0pO1xuICB9XG5cbiAgdHNIYXNTb21lTW9kaWZpZXJzKG1lbWJlciwgbW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVycy5zb21lKG1vZGlmaWVyID0+IHtcbiAgICAgIGlmICh0c0lzQWNjZXNzTW9kaWZpZXIobW9kaWZpZXIpKSB7XG4gICAgICAgIHJldHVybiBtZW1iZXIuYWNjZXNzaWJpbGl0eSA9PT0gbW9kaWZpZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAhIW1lbWJlclttb2RpZmllcl07XG4gICAgfSk7XG4gIH1cblxuICB0c0lzU3RhcnRPZlN0YXRpY0Jsb2NrcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTA0KSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDEyMztcbiAgfVxuXG4gIHBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlKSB7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gW1wiZGVjbGFyZVwiLCBcInByaXZhdGVcIiwgXCJwdWJsaWNcIiwgXCJwcm90ZWN0ZWRcIiwgXCJvdmVycmlkZVwiLCBcImFic3RyYWN0XCIsIFwicmVhZG9ubHlcIiwgXCJzdGF0aWNcIl07XG4gICAgdGhpcy50c1BhcnNlTW9kaWZpZXJzKHtcbiAgICAgIG1vZGlmaWVkOiBtZW1iZXIsXG4gICAgICBhbGxvd2VkTW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICBkaXNhbGxvd2VkTW9kaWZpZXJzOiBbXCJpblwiLCBcIm91dFwiXSxcbiAgICAgIHN0b3BPblN0YXJ0T2ZDbGFzc1N0YXRpY0Jsb2NrOiB0cnVlLFxuICAgICAgZXJyb3JUZW1wbGF0ZTogVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyUG9zaXRpb25zXG4gICAgfSk7XG5cbiAgICBjb25zdCBjYWxsUGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnRzSXNTdGFydE9mU3RhdGljQmxvY2tzKCkpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnRzSGFzU29tZU1vZGlmaWVycyhtZW1iZXIsIG1vZGlmaWVycykpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlN0YXRpY0Jsb2NrQ2Fubm90SGF2ZU1vZGlmaWVyLCB7XG4gICAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5wYXJzZUNsYXNzU3RhdGljQmxvY2soY2xhc3NCb2R5LCBtZW1iZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgISFtZW1iZXIuc3RhdGljKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG1lbWJlci5kZWNsYXJlKSB7XG4gICAgICB0aGlzLnRzSW5BbWJpZW50Q29udGV4dChjYWxsUGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxQYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKCk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyhjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUsIGlzU3RhdGljKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy50c1RyeVBhcnNlSW5kZXhTaWduYXR1cmUobWVtYmVyKTtcblxuICAgIGlmIChpZHgpIHtcbiAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goaWR4KTtcblxuICAgICAgaWYgKG1lbWJlci5hYnN0cmFjdCkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkluZGV4U2lnbmF0dXJlSGFzQWJzdHJhY3QsIHtcbiAgICAgICAgICBhdDogbWVtYmVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVtYmVyLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbmRleFNpZ25hdHVyZUhhc0FjY2Vzc2liaWxpdHksIHtcbiAgICAgICAgICBhdDogbWVtYmVyLFxuICAgICAgICAgIG1vZGlmaWVyOiBtZW1iZXIuYWNjZXNzaWJpbGl0eVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lbWJlci5kZWNsYXJlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5kZXhTaWduYXR1cmVIYXNEZWNsYXJlLCB7XG4gICAgICAgICAgYXQ6IG1lbWJlclxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lbWJlci5vdmVycmlkZSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkluZGV4U2lnbmF0dXJlSGFzT3ZlcnJpZGUsIHtcbiAgICAgICAgICBhdDogbWVtYmVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0YXRlLmluQWJzdHJhY3RDbGFzcyAmJiBtZW1iZXIuYWJzdHJhY3QpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuTm9uQWJzdHJhY3RDbGFzc0hhc0Fic3RyYWN0TWV0aG9kLCB7XG4gICAgICAgIGF0OiBtZW1iZXJcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtZW1iZXIub3ZlcnJpZGUpIHtcbiAgICAgIGlmICghc3RhdGUuaGFkU3VwZXJDbGFzcykge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLk92ZXJyaWRlTm90SW5TdWJDbGFzcywge1xuICAgICAgICAgIGF0OiBtZW1iZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3VwZXIucGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyhjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUsIGlzU3RhdGljKTtcbiAgfVxuXG4gIHBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnMobWV0aG9kT3JQcm9wKSB7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSB0aGlzLmVhdCgxNyk7XG4gICAgaWYgKG9wdGlvbmFsKSBtZXRob2RPclByb3Aub3B0aW9uYWwgPSB0cnVlO1xuXG4gICAgaWYgKG1ldGhvZE9yUHJvcC5yZWFkb25seSAmJiB0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5DbGFzc01ldGhvZEhhc1JlYWRvbmx5LCB7XG4gICAgICAgIGF0OiBtZXRob2RPclByb3BcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtZXRob2RPclByb3AuZGVjbGFyZSAmJiB0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5DbGFzc01ldGhvZEhhc0RlY2xhcmUsIHtcbiAgICAgICAgYXQ6IG1ldGhvZE9yUHJvcFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIHtcbiAgICBjb25zdCBkZWNsID0gZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IHRoaXMudHNQYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwcikgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGRlY2wgfHwgc3VwZXIucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpO1xuICB9XG5cbiAgc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICBpZiAodGhpcy50c0lzRGVjbGFyYXRpb25TdGFydCgpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gc3VwZXIuc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpO1xuICB9XG5cbiAgcGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyB8fCAhdGhpcy5tYXRjaCgxNykpIHtcbiAgICAgIHJldHVybiBzdXBlci5wYXJzZUNvbmRpdGlvbmFsKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cnlQYXJzZSgoKSA9PiBzdXBlci5wYXJzZUNvbmRpdGlvbmFsKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYykpO1xuXG4gICAgaWYgKCFyZXN1bHQubm9kZSkge1xuICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICBzdXBlci5zZXRPcHRpb25hbFBhcmFtZXRlcnNFcnJvcihyZWZFeHByZXNzaW9uRXJyb3JzLCByZXN1bHQuZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmVycm9yKSB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICByZXR1cm4gcmVzdWx0Lm5vZGU7XG4gIH1cblxuICBwYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydFBvcywgc3RhcnRMb2MpIHtcbiAgICBub2RlID0gc3VwZXIucGFyc2VQYXJlbkl0ZW0obm9kZSwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcblxuICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgY29uc3QgdHlwZUNhc3ROb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgdHlwZUNhc3ROb2RlLmV4cHJlc3Npb24gPSBub2RlO1xuICAgICAgdHlwZUNhc3ROb2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodHlwZUNhc3ROb2RlLCBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQgJiYgdGhpcy5pc0NvbnRleHR1YWwoMTIxKSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNJbkFtYmllbnRDb250ZXh0KCgpID0+IHRoaXMucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBpc0RlY2xhcmUgPSB0aGlzLmVhdENvbnRleHR1YWwoMTIxKTtcblxuICAgIGlmIChpc0RlY2xhcmUgJiYgKHRoaXMuaXNDb250ZXh0dWFsKDEyMSkgfHwgIXRoaXMuc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShUU0Vycm9ycy5FeHBlY3RlZEFtYmllbnRBZnRlckV4cG9ydERlY2xhcmUsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGlzSWRlbnRpZmllciA9IHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSk7XG4gICAgY29uc3QgZGVjbGFyYXRpb24gPSBpc0lkZW50aWZpZXIgJiYgdGhpcy50c1RyeVBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSB8fCBzdXBlci5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIGlmICghZGVjbGFyYXRpb24pIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiIHx8IGRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiIHx8IGlzRGVjbGFyZSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVjbGFyZSkge1xuICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb24oZGVjbGFyYXRpb24sIHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBkZWNsYXJhdGlvbi5kZWNsYXJlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gIH1cblxuICBwYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQsIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKCghaXNTdGF0ZW1lbnQgfHwgb3B0aW9uYWxJZCkgJiYgdGhpcy5pc0NvbnRleHR1YWwoMTEwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1cGVyLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCwgbm9kZS5kZWNsYXJlID8gQklORF9UU19BTUJJRU5UIDogQklORF9DTEFTUyk7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VJbk91dE1vZGlmaWVycy5iaW5kKHRoaXMpKTtcbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgfVxuXG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eUFubm90YXRpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5vcHRpb25hbCAmJiB0aGlzLmVhdCgzNSkpIHtcbiAgICAgIG5vZGUuZGVmaW5pdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIGlmICh0eXBlKSBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgfVxuXG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5wYXJzZUNsYXNzUHJvcGVydHlBbm5vdGF0aW9uKG5vZGUpO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCAmJiAhKG5vZGUucmVhZG9ubHkgJiYgIW5vZGUudHlwZUFubm90YXRpb24pICYmIHRoaXMubWF0Y2goMjkpKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkRlY2xhcmVDbGFzc0ZpZWxkSGFzSW5pdGlhbGl6ZXIsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChub2RlLmFic3RyYWN0ICYmIHRoaXMubWF0Y2goMjkpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtleVxuICAgICAgfSA9IG5vZGU7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkFic3RyYWN0UHJvcGVydHlIYXNJbml0aWFsaXplciwge1xuICAgICAgICBhdDogdGhpcy5zdGF0ZS5zdGFydExvYyxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgIW5vZGUuY29tcHV0ZWQgPyBrZXkubmFtZSA6IGBbJHt0aGlzLmlucHV0LnNsaWNlKGtleS5zdGFydCwga2V5LmVuZCl9XWBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZUNsYXNzUHJvcGVydHkobm9kZSk7XG4gIH1cblxuICBwYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUpIHtcbiAgICBpZiAobm9kZS5hYnN0cmFjdCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5Qcml2YXRlRWxlbWVudEhhc0Fic3RyYWN0LCB7XG4gICAgICAgIGF0OiBub2RlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5hY2Nlc3NpYmlsaXR5KSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlByaXZhdGVFbGVtZW50SGFzQWNjZXNzaWJpbGl0eSwge1xuICAgICAgICBhdDogbm9kZSxcbiAgICAgICAgbW9kaWZpZXI6IG5vZGUuYWNjZXNzaWJpbGl0eVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZUNsYXNzUHJvcGVydHlBbm5vdGF0aW9uKG5vZGUpO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUpO1xuICB9XG5cbiAgcHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIpIHtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKCk7XG5cbiAgICBpZiAodHlwZVBhcmFtZXRlcnMgJiYgaXNDb25zdHJ1Y3Rvcikge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5Db25zdHJ1Y3Rvckhhc1R5cGVQYXJhbWV0ZXJzLCB7XG4gICAgICAgIGF0OiB0eXBlUGFyYW1ldGVyc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgZGVjbGFyZSA9IGZhbHNlLFxuICAgICAga2luZFxuICAgIH0gPSBtZXRob2Q7XG5cbiAgICBpZiAoZGVjbGFyZSAmJiAoa2luZCA9PT0gXCJnZXRcIiB8fCBraW5kID09PSBcInNldFwiKSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EZWNsYXJlQWNjZXNzb3IsIHtcbiAgICAgICAgYXQ6IG1ldGhvZCxcbiAgICAgICAga2luZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSBtZXRob2QudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICBzdXBlci5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gIH1cblxuICBwdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYykge1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnMoKTtcbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIG1ldGhvZC50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgIHN1cGVyLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgfVxuXG4gIGRlY2xhcmVDbGFzc1ByaXZhdGVNZXRob2RJblNjb3BlKG5vZGUsIGtpbmQpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIlRTRGVjbGFyZU1ldGhvZFwiKSByZXR1cm47XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgIW5vZGUudmFsdWUuYm9keSkgcmV0dXJuO1xuICAgIHN1cGVyLmRlY2xhcmVDbGFzc1ByaXZhdGVNZXRob2RJblNjb3BlKG5vZGUsIGtpbmQpO1xuICB9XG5cbiAgcGFyc2VDbGFzc1N1cGVyKG5vZGUpIHtcbiAgICBzdXBlci5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG5cbiAgICBpZiAobm9kZS5zdXBlckNsYXNzICYmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDUxKSkpIHtcbiAgICAgIG5vZGUuc3VwZXJUeXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHNJbkV4cHJlc3Npb24oKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDExMCkpIHtcbiAgICAgIG5vZGUuaW1wbGVtZW50cyA9IHRoaXMudHNQYXJzZUhlcml0YWdlQ2xhdXNlKFwiaW1wbGVtZW50c1wiKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKCk7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSBwcm9wLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0UG9zLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cblxuICBwYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGFsbG93TW9kaWZpZXJzKSB7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycygpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgYWxsb3dNb2RpZmllcnMpO1xuICB9XG5cbiAgcGFyc2VWYXJJZChkZWNsLCBraW5kKSB7XG4gICAgc3VwZXIucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcblxuICAgIGlmIChkZWNsLmlkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmIHRoaXMuZWF0KDM1KSkge1xuICAgICAgZGVjbC5kZWZpbml0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG5cbiAgICBpZiAodHlwZSkge1xuICAgICAgZGVjbC5pZC50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oZGVjbC5pZCk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKG5vZGUsIGNhbGwpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbihub2RlLCBjYWxsKTtcbiAgfVxuXG4gIHBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICB2YXIgX2pzeCwgX2pzeDIsIF90eXBlQ2FzdCwgX2pzeDMsIF90eXBlQ2FzdDIsIF9qc3g0LCBfdHlwZUNhc3QzO1xuXG4gICAgbGV0IHN0YXRlO1xuICAgIGxldCBqc3g7XG4gICAgbGV0IHR5cGVDYXN0O1xuXG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwianN4XCIpICYmICh0aGlzLm1hdGNoKDEzOCkgfHwgdGhpcy5tYXRjaCg0NykpKSB7XG4gICAgICBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgIGpzeCA9IHRoaXMudHJ5UGFyc2UoKCkgPT4gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSksIHN0YXRlKTtcbiAgICAgIGlmICghanN4LmVycm9yKSByZXR1cm4ganN4Lm5vZGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgY3VycmVudENvbnRleHQgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChjdXJyZW50Q29udGV4dCA9PT0gdHlwZXMual9vVGFnIHx8IGN1cnJlbnRDb250ZXh0ID09PSB0eXBlcy5qX2V4cHIpIHtcbiAgICAgICAgY29udGV4dC5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoISgoX2pzeCA9IGpzeCkgIT0gbnVsbCAmJiBfanN4LmVycm9yKSAmJiAhdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHJldHVybiBzdXBlci5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKTtcbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlIHx8IHN0YXRlID09PSB0aGlzLnN0YXRlKSBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICBsZXQgdHlwZVBhcmFtZXRlcnM7XG4gICAgY29uc3QgYXJyb3cgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IHtcbiAgICAgIHZhciBfZXhwciRleHRyYSwgX3R5cGVQYXJhbWV0ZXJzO1xuXG4gICAgICB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXJzKCk7XG4gICAgICBjb25zdCBleHByID0gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSk7XG5cbiAgICAgIGlmIChleHByLnR5cGUgIT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCAoX2V4cHIkZXh0cmEgPSBleHByLmV4dHJhKSAhPSBudWxsICYmIF9leHByJGV4dHJhLnBhcmVudGhlc2l6ZWQpIHtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCgoX3R5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnMpID09IG51bGwgPyB2b2lkIDAgOiBfdHlwZVBhcmFtZXRlcnMucGFyYW1zLmxlbmd0aCkgIT09IDApIHtcbiAgICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShleHByLCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICB9XG5cbiAgICAgIGV4cHIudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgIHJldHVybiBleHByO1xuICAgIH0sIHN0YXRlKTtcblxuICAgIGlmICghYXJyb3cuZXJyb3IgJiYgIWFycm93LmFib3J0ZWQpIHtcbiAgICAgIGlmICh0eXBlUGFyYW1ldGVycykgdGhpcy5yZXBvcnRSZXNlcnZlZEFycm93VHlwZVBhcmFtKHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgIHJldHVybiBhcnJvdy5ub2RlO1xuICAgIH1cblxuICAgIGlmICghanN4KSB7XG4gICAgICBhc3NlcnQoIXRoaXMuaGFzUGx1Z2luKFwianN4XCIpKTtcbiAgICAgIHR5cGVDYXN0ID0gdGhpcy50cnlQYXJzZSgoKSA9PiBzdXBlci5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSwgc3RhdGUpO1xuICAgICAgaWYgKCF0eXBlQ2FzdC5lcnJvcikgcmV0dXJuIHR5cGVDYXN0Lm5vZGU7XG4gICAgfVxuXG4gICAgaWYgKChfanN4MiA9IGpzeCkgIT0gbnVsbCAmJiBfanN4Mi5ub2RlKSB7XG4gICAgICB0aGlzLnN0YXRlID0ganN4LmZhaWxTdGF0ZTtcbiAgICAgIHJldHVybiBqc3gubm9kZTtcbiAgICB9XG5cbiAgICBpZiAoYXJyb3cubm9kZSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IGFycm93LmZhaWxTdGF0ZTtcbiAgICAgIGlmICh0eXBlUGFyYW1ldGVycykgdGhpcy5yZXBvcnRSZXNlcnZlZEFycm93VHlwZVBhcmFtKHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgIHJldHVybiBhcnJvdy5ub2RlO1xuICAgIH1cblxuICAgIGlmICgoX3R5cGVDYXN0ID0gdHlwZUNhc3QpICE9IG51bGwgJiYgX3R5cGVDYXN0Lm5vZGUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB0eXBlQ2FzdC5mYWlsU3RhdGU7XG4gICAgICByZXR1cm4gdHlwZUNhc3Qubm9kZTtcbiAgICB9XG5cbiAgICBpZiAoKF9qc3gzID0ganN4KSAhPSBudWxsICYmIF9qc3gzLnRocm93bikgdGhyb3cganN4LmVycm9yO1xuICAgIGlmIChhcnJvdy50aHJvd24pIHRocm93IGFycm93LmVycm9yO1xuICAgIGlmICgoX3R5cGVDYXN0MiA9IHR5cGVDYXN0KSAhPSBudWxsICYmIF90eXBlQ2FzdDIudGhyb3duKSB0aHJvdyB0eXBlQ2FzdC5lcnJvcjtcbiAgICB0aHJvdyAoKF9qc3g0ID0ganN4KSA9PSBudWxsID8gdm9pZCAwIDogX2pzeDQuZXJyb3IpIHx8IGFycm93LmVycm9yIHx8ICgoX3R5cGVDYXN0MyA9IHR5cGVDYXN0KSA9PSBudWxsID8gdm9pZCAwIDogX3R5cGVDYXN0My5lcnJvcik7XG4gIH1cblxuICByZXBvcnRSZXNlcnZlZEFycm93VHlwZVBhcmFtKG5vZGUpIHtcbiAgICB2YXIgX25vZGUkZXh0cmE7XG5cbiAgICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoID09PSAxICYmICEoKF9ub2RlJGV4dHJhID0gbm9kZS5leHRyYSkgIT0gbnVsbCAmJiBfbm9kZSRleHRyYS50cmFpbGluZ0NvbW1hKSAmJiB0aGlzLmdldFBsdWdpbk9wdGlvbihcInR5cGVzY3JpcHRcIiwgXCJkaXNhbGxvd0FtYmlndW91c0pTWExpa2VcIikpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuUmVzZXJ2ZWRBcnJvd1R5cGVQYXJhbSwge1xuICAgICAgICBhdDogbm9kZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VNYXliZVVuYXJ5KHJlZkV4cHJlc3Npb25FcnJvcnMsIHNhd1VuYXJ5KSB7XG4gICAgaWYgKCF0aGlzLmhhc1BsdWdpbihcImpzeFwiKSAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVBc3NlcnRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlTWF5YmVVbmFyeShyZWZFeHByZXNzaW9uRXJyb3JzLCBzYXdVbmFyeSk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VBcnJvdyhub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IHtcbiAgICAgICAgY29uc3QgcmV0dXJuVHlwZSA9IHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKDE0KTtcbiAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgIXRoaXMubWF0Y2goMTkpKSBhYm9ydCgpO1xuICAgICAgICByZXR1cm4gcmV0dXJuVHlwZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdC5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgIGlmICghcmVzdWx0LnRocm93bikge1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICAgICAgbm9kZS5yZXR1cm5UeXBlID0gcmVzdWx0Lm5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQXJyb3cobm9kZSk7XG4gIH1cblxuICBwYXJzZUFzc2lnbmFibGVMaXN0SXRlbVR5cGVzKHBhcmFtKSB7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgaWYgKHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmICF0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQgJiYgIXRoaXMuc3RhdGUuaW5UeXBlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuUGF0dGVybklzT3B0aW9uYWwsIHtcbiAgICAgICAgICBhdDogcGFyYW1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHBhcmFtLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkgcGFyYW0udHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihwYXJhbSk7XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG5cbiAgaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZykge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNCaW5kaW5nKTtcblxuICAgICAgY2FzZSBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdXBlci5pc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gIH1cblxuICB0b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMgPSBmYWxzZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGVQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihub2RlLCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgICAgIGlmIChpc0xIUykge1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnJlY29yZEFycm93UGFyZW1ldGVyQmluZGluZ0Vycm9yKFRTRXJyb3JzLlVuZXhwZWN0ZWRUeXBlQ2FzdEluUGFyYW1ldGVyLCB7XG4gICAgICAgICAgICBhdDogbm9kZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuVW5leHBlY3RlZFR5cGVDYXN0SW5QYXJhbWV0ZXIsIHtcbiAgICAgICAgICAgIGF0OiBub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzTEhTKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAoIWlzTEhTICYmIG5vZGUubGVmdC50eXBlID09PSBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZS5sZWZ0KTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdXBlci50b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMpO1xuICAgIH1cbiAgfVxuXG4gIHRvQXNzaWduYWJsZVBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUsIGlzTEhTKSB7XG4gICAgc3dpdGNoIChub2RlLmV4cHJlc3Npb24udHlwZSkge1xuICAgICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTVHlwZUFzc2VydGlvblwiOlxuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNMSFMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIudG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTKTtcbiAgICB9XG4gIH1cblxuICBjaGVja1RvUmVzdENvbnZlcnNpb24obm9kZSwgYWxsb3dQYXR0ZXJuKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTVHlwZUFzc2VydGlvblwiOlxuICAgICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy5jaGVja1RvUmVzdENvbnZlcnNpb24obm9kZS5leHByZXNzaW9uLCBmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdXBlci5jaGVja1RvUmVzdENvbnZlcnNpb24obm9kZSwgYWxsb3dQYXR0ZXJuKTtcbiAgICB9XG4gIH1cblxuICBpc1ZhbGlkTFZhbCh0eXBlLCBpc1VucGFyZW50aGVzaXplZEluQXNzaWduLCBiaW5kaW5nKSB7XG4gICAgcmV0dXJuIGdldE93biQxKHtcbiAgICAgIFRTVHlwZUNhc3RFeHByZXNzaW9uOiB0cnVlLFxuICAgICAgVFNQYXJhbWV0ZXJQcm9wZXJ0eTogXCJwYXJhbWV0ZXJcIixcbiAgICAgIFRTTm9uTnVsbEV4cHJlc3Npb246IFwiZXhwcmVzc2lvblwiLFxuICAgICAgVFNBc0V4cHJlc3Npb246IChiaW5kaW5nICE9PSBCSU5EX05PTkUgfHwgIWlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24pICYmIFtcImV4cHJlc3Npb25cIiwgdHJ1ZV0sXG4gICAgICBUU1R5cGVBc3NlcnRpb246IChiaW5kaW5nICE9PSBCSU5EX05PTkUgfHwgIWlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24pICYmIFtcImV4cHJlc3Npb25cIiwgdHJ1ZV1cbiAgICB9LCB0eXBlKSB8fCBzdXBlci5pc1ZhbGlkTFZhbCh0eXBlLCBpc1VucGFyZW50aGVzaXplZEluQXNzaWduLCBiaW5kaW5nKTtcbiAgfVxuXG4gIHBhcnNlQmluZGluZ0F0b20oKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgNzg6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCg1MSkpIHtcbiAgICAgIGNvbnN0IHR5cGVBcmd1bWVudHMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzSW5FeHByZXNzaW9uKCk7XG5cbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICBjb25zdCBjYWxsID0gc3VwZXIucGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByKTtcbiAgICAgICAgY2FsbC50eXBlUGFyYW1ldGVycyA9IHR5cGVBcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgMTApO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5wYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIpO1xuICB9XG5cbiAgY2hlY2tDb21tYUFmdGVyUmVzdChjbG9zZSkge1xuICAgIGlmICh0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQgJiYgdGhpcy5tYXRjaCgxMikgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSBjbG9zZSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5jaGVja0NvbW1hQWZ0ZXJSZXN0KGNsb3NlKTtcbiAgICB9XG4gIH1cblxuICBpc0NsYXNzTWV0aG9kKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDQ3KSB8fCBzdXBlci5pc0NsYXNzTWV0aG9kKCk7XG4gIH1cblxuICBpc0NsYXNzUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMzUpIHx8IHRoaXMubWF0Y2goMTQpIHx8IHN1cGVyLmlzQ2xhc3NQcm9wZXJ0eSgpO1xuICB9XG5cbiAgcGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0KSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCk7XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgJiYgbm9kZS50eXBlQW5ub3RhdGlvbiAmJiBub2RlLnJpZ2h0LnN0YXJ0IDwgbm9kZS50eXBlQW5ub3RhdGlvbi5zdGFydCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5UeXBlQW5ub3RhdGlvbkFmdGVyQXNzaWduLCB7XG4gICAgICAgIGF0OiBub2RlLnR5cGVBbm5vdGF0aW9uXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGdldFRva2VuRnJvbUNvZGUoY29kZSkge1xuICAgIGlmICh0aGlzLnN0YXRlLmluVHlwZSkge1xuICAgICAgaWYgKGNvZGUgPT09IDYyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKDQ4LCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGUgPT09IDYwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKDQ3LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcbiAgfVxuXG4gIHJlU2Nhbl9sdF9ndCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBpZiAodHlwZSA9PT0gNDcpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDE7XG4gICAgICB0aGlzLnJlYWRUb2tlbl9sdCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNDgpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDE7XG4gICAgICB0aGlzLnJlYWRUb2tlbl9ndCgpO1xuICAgIH1cbiAgfVxuXG4gIHJlU2Nhbl9sdCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBpZiAodHlwZSA9PT0gNTEpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDI7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ3LCAxKTtcbiAgICAgIHJldHVybiA0NztcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHRvQXNzaWduYWJsZUxpc3QoZXhwckxpc3QsIHRyYWlsaW5nQ29tbWFMb2MsIGlzTEhTKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZXhwciA9IGV4cHJMaXN0W2ldO1xuXG4gICAgICBpZiAoKGV4cHIgPT0gbnVsbCA/IHZvaWQgMCA6IGV4cHIudHlwZSkgPT09IFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICBleHByTGlzdFtpXSA9IHRoaXMudHlwZUNhc3RUb1BhcmFtZXRlcihleHByKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlci50b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0LCB0cmFpbGluZ0NvbW1hTG9jLCBpc0xIUyk7XG4gIH1cblxuICB0eXBlQ2FzdFRvUGFyYW1ldGVyKG5vZGUpIHtcbiAgICBub2RlLmV4cHJlc3Npb24udHlwZUFubm90YXRpb24gPSBub2RlLnR5cGVBbm5vdGF0aW9uO1xuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudHlwZUFubm90YXRpb24ubG9jLmVuZCk7XG4gICAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbjtcbiAgfVxuXG4gIHNob3VsZFBhcnNlQXJyb3cocGFyYW1zKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICByZXR1cm4gcGFyYW1zLmV2ZXJ5KGV4cHIgPT4gdGhpcy5pc0Fzc2lnbmFibGUoZXhwciwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5zaG91bGRQYXJzZUFycm93KHBhcmFtcyk7XG4gIH1cblxuICBzaG91bGRQYXJzZUFzeW5jQXJyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTQpIHx8IHN1cGVyLnNob3VsZFBhcnNlQXN5bmNBcnJvdygpO1xuICB9XG5cbiAgY2FuSGF2ZUxlYWRpbmdEZWNvcmF0b3IoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNhbkhhdmVMZWFkaW5nRGVjb3JhdG9yKCkgfHwgdGhpcy5pc0Fic3RyYWN0Q2xhc3MoKTtcbiAgfVxuXG4gIGpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBZnRlck5hbWUobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDUxKSkge1xuICAgICAgY29uc3QgdHlwZUFyZ3VtZW50cyA9IHRoaXMudHNUcnlQYXJzZUFuZENhdGNoKCgpID0+IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHNJbkV4cHJlc3Npb24oKSk7XG4gICAgICBpZiAodHlwZUFyZ3VtZW50cykgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVBcmd1bWVudHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBZnRlck5hbWUobm9kZSk7XG4gIH1cblxuICBnZXRHZXR0ZXJTZXR0ZXJFeHBlY3RlZFBhcmFtQ291bnQobWV0aG9kKSB7XG4gICAgY29uc3QgYmFzZUNvdW50ID0gc3VwZXIuZ2V0R2V0dGVyU2V0dGVyRXhwZWN0ZWRQYXJhbUNvdW50KG1ldGhvZCk7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRPYmplY3RPckNsYXNzTWV0aG9kUGFyYW1zKG1ldGhvZCk7XG4gICAgY29uc3QgZmlyc3RQYXJhbSA9IHBhcmFtc1swXTtcbiAgICBjb25zdCBoYXNDb250ZXh0UGFyYW0gPSBmaXJzdFBhcmFtICYmIHRoaXMuaXNUaGlzUGFyYW0oZmlyc3RQYXJhbSk7XG4gICAgcmV0dXJuIGhhc0NvbnRleHRQYXJhbSA/IGJhc2VDb3VudCArIDEgOiBiYXNlQ291bnQ7XG4gIH1cblxuICBwYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKSB7XG4gICAgY29uc3QgcGFyYW0gPSBzdXBlci5wYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcblxuICAgIGlmICh0eXBlKSB7XG4gICAgICBwYXJhbS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24ocGFyYW0pO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuXG4gIHRzSW5BbWJpZW50Q29udGV4dChjYikge1xuICAgIGNvbnN0IG9sZElzQW1iaWVudENvbnRleHQgPSB0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQ7XG4gICAgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ID0gb2xkSXNBbWJpZW50Q29udGV4dDtcbiAgICB9XG4gIH1cblxuICBwYXJzZUNsYXNzKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkKSB7XG4gICAgY29uc3Qgb2xkSW5BYnN0cmFjdENsYXNzID0gdGhpcy5zdGF0ZS5pbkFic3RyYWN0Q2xhc3M7XG4gICAgdGhpcy5zdGF0ZS5pbkFic3RyYWN0Q2xhc3MgPSAhIW5vZGUuYWJzdHJhY3Q7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlQ2xhc3Mobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnN0YXRlLmluQWJzdHJhY3RDbGFzcyA9IG9sZEluQWJzdHJhY3RDbGFzcztcbiAgICB9XG4gIH1cblxuICB0c1BhcnNlQWJzdHJhY3REZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goODApKSB7XG4gICAgICBub2RlLmFic3RyYWN0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI1KSkge1xuICAgICAgaWYgKCF0aGlzLmhhc0ZvbGxvd2luZ0xpbmVCcmVhaygpKSB7XG4gICAgICAgIG5vZGUuYWJzdHJhY3QgPSB0cnVlO1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLk5vbkNsYXNzTWV0aG9kUHJvcGVydHlIYXNBYnN0cmFjdE1vZGlmZXIsIHtcbiAgICAgICAgICBhdDogbm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgODApO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlTWV0aG9kKG5vZGUsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd0RpcmVjdFN1cGVyLCB0eXBlLCBpbkNsYXNzU2NvcGUpIHtcbiAgICBjb25zdCBtZXRob2QgPSBzdXBlci5wYXJzZU1ldGhvZChub2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dEaXJlY3RTdXBlciwgdHlwZSwgaW5DbGFzc1Njb3BlKTtcblxuICAgIGlmIChtZXRob2QuYWJzdHJhY3QpIHtcbiAgICAgIGNvbnN0IGhhc0JvZHkgPSB0aGlzLmhhc1BsdWdpbihcImVzdHJlZVwiKSA/ICEhbWV0aG9kLnZhbHVlLmJvZHkgOiAhIW1ldGhvZC5ib2R5O1xuXG4gICAgICBpZiAoaGFzQm9keSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAga2V5XG4gICAgICAgIH0gPSBtZXRob2Q7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQWJzdHJhY3RNZXRob2RIYXNJbXBsZW1lbnRhdGlvbiwge1xuICAgICAgICAgIGF0OiBtZXRob2QsXG4gICAgICAgICAgbWV0aG9kTmFtZToga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICFtZXRob2QuY29tcHV0ZWQgPyBrZXkubmFtZSA6IGBbJHt0aGlzLmlucHV0LnNsaWNlKGtleS5zdGFydCwga2V5LmVuZCl9XWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfVxuXG4gIHRzUGFyc2VUeXBlUGFyYW1ldGVyTmFtZSgpIHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgcmV0dXJuIHR5cGVOYW1lLm5hbWU7XG4gIH1cblxuICBzaG91bGRQYXJzZUFzQW1iaWVudENvbnRleHQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJ0eXBlc2NyaXB0XCIsIFwiZHRzXCIpO1xuICB9XG5cbiAgcGFyc2UoKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VBc0FtYmllbnRDb250ZXh0KCkpIHtcbiAgICAgIHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlKCk7XG4gIH1cblxuICBnZXRFeHByZXNzaW9uKCkge1xuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlQXNBbWJpZW50Q29udGV4dCgpKSB7XG4gICAgICB0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5nZXRFeHByZXNzaW9uKCk7XG4gIH1cblxuICBwYXJzZUV4cG9ydFNwZWNpZmllcihub2RlLCBpc1N0cmluZywgaXNJblR5cGVFeHBvcnQsIGlzTWF5YmVUeXBlT25seSkge1xuICAgIGlmICghaXNTdHJpbmcgJiYgaXNNYXliZVR5cGVPbmx5KSB7XG4gICAgICB0aGlzLnBhcnNlVHlwZU9ubHlJbXBvcnRFeHBvcnRTcGVjaWZpZXIobm9kZSwgZmFsc2UsIGlzSW5UeXBlRXhwb3J0KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIik7XG4gICAgfVxuXG4gICAgbm9kZS5leHBvcnRLaW5kID0gXCJ2YWx1ZVwiO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydFNwZWNpZmllcihub2RlLCBpc1N0cmluZywgaXNJblR5cGVFeHBvcnQsIGlzTWF5YmVUeXBlT25seSk7XG4gIH1cblxuICBwYXJzZUltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIGltcG9ydGVkSXNTdHJpbmcsIGlzSW5UeXBlT25seUltcG9ydCwgaXNNYXliZVR5cGVPbmx5KSB7XG4gICAgaWYgKCFpbXBvcnRlZElzU3RyaW5nICYmIGlzTWF5YmVUeXBlT25seSkge1xuICAgICAgdGhpcy5wYXJzZVR5cGVPbmx5SW1wb3J0RXhwb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgdHJ1ZSwgaXNJblR5cGVPbmx5SW1wb3J0KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkltcG9ydFNwZWNpZmllclwiKTtcbiAgICB9XG5cbiAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBpbXBvcnRlZElzU3RyaW5nLCBpc0luVHlwZU9ubHlJbXBvcnQsIGlzTWF5YmVUeXBlT25seSk7XG4gIH1cblxuICBwYXJzZVR5cGVPbmx5SW1wb3J0RXhwb3J0U3BlY2lmaWVyKG5vZGUsIGlzSW1wb3J0LCBpc0luVHlwZU9ubHlJbXBvcnRFeHBvcnQpIHtcbiAgICBjb25zdCBsZWZ0T2ZBc0tleSA9IGlzSW1wb3J0ID8gXCJpbXBvcnRlZFwiIDogXCJsb2NhbFwiO1xuICAgIGNvbnN0IHJpZ2h0T2ZBc0tleSA9IGlzSW1wb3J0ID8gXCJsb2NhbFwiIDogXCJleHBvcnRlZFwiO1xuICAgIGxldCBsZWZ0T2ZBcyA9IG5vZGVbbGVmdE9mQXNLZXldO1xuICAgIGxldCByaWdodE9mQXM7XG4gICAgbGV0IGhhc1R5cGVTcGVjaWZpZXIgPSBmYWxzZTtcbiAgICBsZXQgY2FuUGFyc2VBc0tleXdvcmQgPSB0cnVlO1xuICAgIGNvbnN0IGxvYyA9IGxlZnRPZkFzLmxvYy5zdGFydDtcblxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5MykpIHtcbiAgICAgIGNvbnN0IGZpcnN0QXMgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuXG4gICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTMpKSB7XG4gICAgICAgIGNvbnN0IHNlY29uZEFzID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcblxuICAgICAgICBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIGhhc1R5cGVTcGVjaWZpZXIgPSB0cnVlO1xuICAgICAgICAgIGxlZnRPZkFzID0gZmlyc3RBcztcbiAgICAgICAgICByaWdodE9mQXMgPSBpc0ltcG9ydCA/IHRoaXMucGFyc2VJZGVudGlmaWVyKCkgOiB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgICAgIGNhblBhcnNlQXNLZXl3b3JkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmlnaHRPZkFzID0gc2Vjb25kQXM7XG4gICAgICAgICAgY2FuUGFyc2VBc0tleXdvcmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIGNhblBhcnNlQXNLZXl3b3JkID0gZmFsc2U7XG4gICAgICAgIHJpZ2h0T2ZBcyA9IGlzSW1wb3J0ID8gdGhpcy5wYXJzZUlkZW50aWZpZXIoKSA6IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNUeXBlU3BlY2lmaWVyID0gdHJ1ZTtcbiAgICAgICAgbGVmdE9mQXMgPSBmaXJzdEFzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgaGFzVHlwZVNwZWNpZmllciA9IHRydWU7XG5cbiAgICAgIGlmIChpc0ltcG9ydCkge1xuICAgICAgICBsZWZ0T2ZBcyA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoOTMpKSB7XG4gICAgICAgICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChsZWZ0T2ZBcy5uYW1lLCBsZWZ0T2ZBcy5sb2Muc3RhcnQsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0T2ZBcyA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1R5cGVTcGVjaWZpZXIgJiYgaXNJblR5cGVPbmx5SW1wb3J0RXhwb3J0KSB7XG4gICAgICB0aGlzLnJhaXNlKGlzSW1wb3J0ID8gVFNFcnJvcnMuVHlwZU1vZGlmaWVySXNVc2VkSW5UeXBlSW1wb3J0cyA6IFRTRXJyb3JzLlR5cGVNb2RpZmllcklzVXNlZEluVHlwZUV4cG9ydHMsIHtcbiAgICAgICAgYXQ6IGxvY1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbm9kZVtsZWZ0T2ZBc0tleV0gPSBsZWZ0T2ZBcztcbiAgICBub2RlW3JpZ2h0T2ZBc0tleV0gPSByaWdodE9mQXM7XG4gICAgY29uc3Qga2luZEtleSA9IGlzSW1wb3J0ID8gXCJpbXBvcnRLaW5kXCIgOiBcImV4cG9ydEtpbmRcIjtcbiAgICBub2RlW2tpbmRLZXldID0gaGFzVHlwZVNwZWNpZmllciA/IFwidHlwZVwiIDogXCJ2YWx1ZVwiO1xuXG4gICAgaWYgKGNhblBhcnNlQXNLZXl3b3JkICYmIHRoaXMuZWF0Q29udGV4dHVhbCg5MykpIHtcbiAgICAgIG5vZGVbcmlnaHRPZkFzS2V5XSA9IGlzSW1wb3J0ID8gdGhpcy5wYXJzZUlkZW50aWZpZXIoKSA6IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgfVxuXG4gICAgaWYgKCFub2RlW3JpZ2h0T2ZBc0tleV0pIHtcbiAgICAgIG5vZGVbcmlnaHRPZkFzS2V5XSA9IGNsb25lSWRlbnRpZmllcihub2RlW2xlZnRPZkFzS2V5XSk7XG4gICAgfVxuXG4gICAgaWYgKGlzSW1wb3J0KSB7XG4gICAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlW3JpZ2h0T2ZBc0tleV0sIEJJTkRfTEVYSUNBTCk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBpc1Bvc3NpYmx5TGl0ZXJhbEVudW0oZXhwcmVzc2lvbikge1xuICBpZiAoZXhwcmVzc2lvbi50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB7XG4gICAgY29tcHV0ZWQsXG4gICAgcHJvcGVydHlcbiAgfSA9IGV4cHJlc3Npb247XG5cbiAgaWYgKGNvbXB1dGVkICYmIHByb3BlcnR5LnR5cGUgIT09IFwiU3RyaW5nTGl0ZXJhbFwiICYmIChwcm9wZXJ0eS50eXBlICE9PSBcIlRlbXBsYXRlTGl0ZXJhbFwiIHx8IHByb3BlcnR5LmV4cHJlc3Npb25zLmxlbmd0aCA+IDApKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzVW5jb21wdXRlZE1lbWJlckV4cHJlc3Npb25DaGFpbihleHByZXNzaW9uLm9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGlzVW5jb21wdXRlZE1lbWJlckV4cHJlc3Npb25DaGFpbihleHByZXNzaW9uKSB7XG4gIGlmIChleHByZXNzaW9uLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGV4cHJlc3Npb24udHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgaWYgKGV4cHJlc3Npb24uY29tcHV0ZWQpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGlzVW5jb21wdXRlZE1lbWJlckV4cHJlc3Npb25DaGFpbihleHByZXNzaW9uLm9iamVjdCk7XG59XG5cbmNvbnN0IFBsYWNlaG9sZGVyRXJyb3JzID0gUGFyc2VFcnJvckVudW1gcGxhY2Vob2xkZXJzYCh7XG4gIENsYXNzTmFtZUlzUmVxdWlyZWQ6IFwiQSBjbGFzcyBuYW1lIGlzIHJlcXVpcmVkLlwiLFxuICBVbmV4cGVjdGVkU3BhY2U6IFwiVW5leHBlY3RlZCBzcGFjZSBpbiBwbGFjZWhvbGRlci5cIlxufSk7XG52YXIgcGxhY2Vob2xkZXJzID0gKHN1cGVyQ2xhc3MgPT4gY2xhc3MgUGxhY2Vob2xkZXJzUGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgcGFyc2VQbGFjZWhvbGRlcihleHBlY3RlZE5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNDApKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5hc3NlcnROb1NwYWNlKCk7XG4gICAgICBub2RlLm5hbWUgPSBzdXBlci5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICB0aGlzLmFzc2VydE5vU3BhY2UoKTtcbiAgICAgIHRoaXMuZXhwZWN0KDE0MCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihub2RlLCBleHBlY3RlZE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZpbmlzaFBsYWNlaG9sZGVyKG5vZGUsIGV4cGVjdGVkTm9kZSkge1xuICAgIGNvbnN0IGlzRmluaXNoZWQgPSAhIShub2RlLmV4cGVjdGVkTm9kZSAmJiBub2RlLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIik7XG4gICAgbm9kZS5leHBlY3RlZE5vZGUgPSBleHBlY3RlZE5vZGU7XG4gICAgcmV0dXJuIGlzRmluaXNoZWQgPyBub2RlIDogdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUGxhY2Vob2xkZXJcIik7XG4gIH1cblxuICBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gMzcgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSkgPT09IDM3KSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPcCgxNDAsIDIpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5nZXRUb2tlbkZyb21Db2RlKGNvZGUpO1xuICB9XG5cbiAgcGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIkV4cHJlc3Npb25cIikgfHwgc3VwZXIucGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxuXG4gIHBhcnNlSWRlbnRpZmllcihsaWJlcmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIikgfHwgc3VwZXIucGFyc2VJZGVudGlmaWVyKGxpYmVyYWwpO1xuICB9XG5cbiAgY2hlY2tSZXNlcnZlZFdvcmQod29yZCwgc3RhcnRMb2MsIGNoZWNrS2V5d29yZHMsIGlzQmluZGluZykge1xuICAgIGlmICh3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN1cGVyLmNoZWNrUmVzZXJ2ZWRXb3JkKHdvcmQsIHN0YXJ0TG9jLCBjaGVja0tleXdvcmRzLCBpc0JpbmRpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlQmluZGluZ0F0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIlBhdHRlcm5cIikgfHwgc3VwZXIucGFyc2VCaW5kaW5nQXRvbSgpO1xuICB9XG5cbiAgaXNWYWxpZExWYWwodHlwZSwgaXNQYXJlbnRoZXNpemVkLCBiaW5kaW5nKSB7XG4gICAgcmV0dXJuIHR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiB8fCBzdXBlci5pc1ZhbGlkTFZhbCh0eXBlLCBpc1BhcmVudGhlc2l6ZWQsIGJpbmRpbmcpO1xuICB9XG5cbiAgdG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTKSB7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSBcIlBsYWNlaG9sZGVyXCIgJiYgbm9kZS5leHBlY3RlZE5vZGUgPT09IFwiRXhwcmVzc2lvblwiKSB7XG4gICAgICBub2RlLmV4cGVjdGVkTm9kZSA9IFwiUGF0dGVyblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci50b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMpO1xuICAgIH1cbiAgfVxuXG4gIGlzTGV0KGNvbnRleHQpIHtcbiAgICBpZiAoc3VwZXIuaXNMZXQoY29udGV4dCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoOTkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLmxvb2thaGVhZCgpO1xuXG4gICAgaWYgKG5leHRUb2tlbi50eXBlID09PSAxNDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZlcmlmeUJyZWFrQ29udGludWUobm9kZSwgaXNCcmVhaykge1xuICAgIGlmIChub2RlLmxhYmVsICYmIG5vZGUubGFiZWwudHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiKSByZXR1cm47XG4gICAgc3VwZXIudmVyaWZ5QnJlYWtDb250aW51ZShub2RlLCBpc0JyZWFrKTtcbiAgfVxuXG4gIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSB7XG4gICAgaWYgKGV4cHIudHlwZSAhPT0gXCJQbGFjZWhvbGRlclwiIHx8IGV4cHIuZXh0cmEgJiYgZXhwci5leHRyYS5wYXJlbnRoZXNpemVkKSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgY29uc3Qgc3RtdCA9IG5vZGU7XG4gICAgICBzdG10LmxhYmVsID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihleHByLCBcIklkZW50aWZpZXJcIik7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHN0bXQuYm9keSA9IHN1cGVyLnBhcnNlU3RhdGVtZW50KFwibGFiZWxcIik7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHN0bXQsIFwiTGFiZWxlZFN0YXRlbWVudFwiKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIG5vZGUubmFtZSA9IGV4cHIubmFtZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihub2RlLCBcIlN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHBhcnNlQmxvY2soYWxsb3dEaXJlY3RpdmVzLCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUsIGFmdGVyQmxvY2tQYXJzZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJCbG9ja1N0YXRlbWVudFwiKSB8fCBzdXBlci5wYXJzZUJsb2NrKGFsbG93RGlyZWN0aXZlcywgY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBhZnRlckJsb2NrUGFyc2UpO1xuICB9XG5cbiAgcGFyc2VGdW5jdGlvbklkKHJlcXVpcmVJZCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpIHx8IHN1cGVyLnBhcnNlRnVuY3Rpb25JZChyZXF1aXJlSWQpO1xuICB9XG5cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIGNvbnN0IHR5cGUgPSBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIjtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnRha2VEZWNvcmF0b3JzKG5vZGUpO1xuICAgIGNvbnN0IG9sZFN0cmljdCA9IHRoaXMuc3RhdGUuc3RyaWN0O1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiSWRlbnRpZmllclwiKTtcblxuICAgIGlmIChwbGFjZWhvbGRlcikge1xuICAgICAgaWYgKHRoaXMubWF0Y2goODEpIHx8IHRoaXMubWF0Y2goMTQwKSB8fCB0aGlzLm1hdGNoKDUpKSB7XG4gICAgICAgIG5vZGUuaWQgPSBwbGFjZWhvbGRlcjtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9uYWxJZCB8fCAhaXNTdGF0ZW1lbnQpIHtcbiAgICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgICAgIG5vZGUuYm9keSA9IHRoaXMuZmluaXNoUGxhY2Vob2xkZXIocGxhY2Vob2xkZXIsIFwiQ2xhc3NCb2R5XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShQbGFjZWhvbGRlckVycm9ycy5DbGFzc05hbWVJc1JlcXVpcmVkLCB7XG4gICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkKTtcbiAgICB9XG5cbiAgICBzdXBlci5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiQ2xhc3NCb2R5XCIpIHx8IHN1cGVyLnBhcnNlQ2xhc3NCb2R5KCEhbm9kZS5zdXBlckNsYXNzLCBvbGRTdHJpY3QpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gIH1cblxuICBwYXJzZUV4cG9ydChub2RlKSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmICghcGxhY2Vob2xkZXIpIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydChub2RlKTtcblxuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoOTcpICYmICF0aGlzLm1hdGNoKDEyKSkge1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgICBub2RlLnNvdXJjZSA9IG51bGw7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgXCJEZWNsYXJhdGlvblwiKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZXhwb3J0RGVmYXVsdEZyb21cIik7XG4gICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBzcGVjaWZpZXIuZXhwb3J0ZWQgPSBwbGFjZWhvbGRlcjtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBbdGhpcy5maW5pc2hOb2RlKHNwZWNpZmllciwgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIpXTtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnQobm9kZSk7XG4gIH1cblxuICBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNjUpKSB7XG4gICAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5TdGFydCgpO1xuXG4gICAgICBpZiAodGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcImZyb21cIikpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuc3RhcnRzV2l0aCh0b2tlbkxhYmVsTmFtZSgxNDApLCB0aGlzLm5leHRUb2tlblN0YXJ0U2luY2UobmV4dCArIDQpKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpO1xuICB9XG5cbiAgbWF5YmVQYXJzZUV4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSkge1xuICAgIGlmIChub2RlLnNwZWNpZmllcnMgJiYgbm9kZS5zcGVjaWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5tYXliZVBhcnNlRXhwb3J0RGVmYXVsdFNwZWNpZmllcihub2RlKTtcbiAgfVxuXG4gIGNoZWNrRXhwb3J0KG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzcGVjaWZpZXJzXG4gICAgfSA9IG5vZGU7XG5cbiAgICBpZiAoc3BlY2lmaWVycyAhPSBudWxsICYmIHNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmZpbHRlcihub2RlID0+IG5vZGUuZXhwb3J0ZWQudHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiKTtcbiAgICB9XG5cbiAgICBzdXBlci5jaGVja0V4cG9ydChub2RlKTtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzO1xuICB9XG5cbiAgcGFyc2VJbXBvcnQobm9kZSkge1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiSWRlbnRpZmllclwiKTtcbiAgICBpZiAoIXBsYWNlaG9sZGVyKSByZXR1cm4gc3VwZXIucGFyc2VJbXBvcnQobm9kZSk7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG5cbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDk3KSAmJiAhdGhpcy5tYXRjaCgxMikpIHtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgXCJTdHJpbmdMaXRlcmFsXCIpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShwbGFjZWhvbGRlcik7XG4gICAgc3BlY2lmaWVyLmxvY2FsID0gcGxhY2Vob2xkZXI7XG4gICAgbm9kZS5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKHNwZWNpZmllciwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpKTtcblxuICAgIGlmICh0aGlzLmVhdCgxMikpIHtcbiAgICAgIGNvbnN0IGhhc1N0YXJJbXBvcnQgPSB0aGlzLm1heWJlUGFyc2VTdGFySW1wb3J0U3BlY2lmaWVyKG5vZGUpO1xuICAgICAgaWYgKCFoYXNTdGFySW1wb3J0KSB0aGlzLnBhcnNlTmFtZWRJbXBvcnRTcGVjaWZpZXJzKG5vZGUpO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCg5Nyk7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlSW1wb3J0U291cmNlKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIik7XG4gIH1cblxuICBwYXJzZUltcG9ydFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiU3RyaW5nTGl0ZXJhbFwiKSB8fCBzdXBlci5wYXJzZUltcG9ydFNvdXJjZSgpO1xuICB9XG5cbiAgYXNzZXJ0Tm9TcGFjZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdGFydCA+IHRoaXMuc3RhdGUubGFzdFRva0VuZExvYy5pbmRleCkge1xuICAgICAgdGhpcy5yYWlzZShQbGFjZWhvbGRlckVycm9ycy5VbmV4cGVjdGVkU3BhY2UsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUubGFzdFRva0VuZExvY1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG52YXIgdjhpbnRyaW5zaWMgPSAoc3VwZXJDbGFzcyA9PiBjbGFzcyBWOEludHJpbnNpY01peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIHBhcnNlVjhJbnRyaW5zaWMoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNTQpKSB7XG4gICAgICBjb25zdCB2OEludHJpbnNpY1N0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUodGhpcy5zdGF0ZS5zdGFydCk7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIobm9kZSwgbmFtZSk7XG4gICAgICAgIGlkZW50aWZpZXIudHlwZSA9IFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCI7XG5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2goMTApKSB7XG4gICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy51bmV4cGVjdGVkKHY4SW50cmluc2ljU3RhcnRMb2MpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIHJldHVybiB0aGlzLnBhcnNlVjhJbnRyaW5zaWMoKSB8fCBzdXBlci5wYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBoYXNQbHVnaW4ocGx1Z2lucywgZXhwZWN0ZWRDb25maWcpIHtcbiAgY29uc3QgW2V4cGVjdGVkTmFtZSwgZXhwZWN0ZWRPcHRpb25zXSA9IHR5cGVvZiBleHBlY3RlZENvbmZpZyA9PT0gXCJzdHJpbmdcIiA/IFtleHBlY3RlZENvbmZpZywge31dIDogZXhwZWN0ZWRDb25maWc7XG4gIGNvbnN0IGV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGV4cGVjdGVkT3B0aW9ucyk7XG4gIGNvbnN0IGV4cGVjdGVkT3B0aW9uc0lzRW1wdHkgPSBleHBlY3RlZEtleXMubGVuZ3RoID09PSAwO1xuICByZXR1cm4gcGx1Z2lucy5zb21lKHAgPT4ge1xuICAgIGlmICh0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkT3B0aW9uc0lzRW1wdHkgJiYgcCA9PT0gZXhwZWN0ZWROYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbcGx1Z2luTmFtZSwgcGx1Z2luT3B0aW9uc10gPSBwO1xuXG4gICAgICBpZiAocGx1Z2luTmFtZSAhPT0gZXhwZWN0ZWROYW1lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXhwZWN0ZWRLZXlzKSB7XG4gICAgICAgIGlmIChwbHVnaW5PcHRpb25zW2tleV0gIT09IGV4cGVjdGVkT3B0aW9uc1trZXldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRQbHVnaW5PcHRpb24ocGx1Z2lucywgbmFtZSwgb3B0aW9uKSB7XG4gIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnMuZmluZChwbHVnaW4gPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBsdWdpbikpIHtcbiAgICAgIHJldHVybiBwbHVnaW5bMF0gPT09IG5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwbHVnaW4gPT09IG5hbWU7XG4gICAgfVxuICB9KTtcblxuICBpZiAocGx1Z2luICYmIEFycmF5LmlzQXJyYXkocGx1Z2luKSkge1xuICAgIHJldHVybiBwbHVnaW5bMV1bb3B0aW9uXTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuY29uc3QgUElQRUxJTkVfUFJPUE9TQUxTID0gW1wibWluaW1hbFwiLCBcImZzaGFycFwiLCBcImhhY2tcIiwgXCJzbWFydFwiXTtcbmNvbnN0IFRPUElDX1RPS0VOUyA9IFtcIl5eXCIsIFwiQEBcIiwgXCJeXCIsIFwiJVwiLCBcIiNcIl07XG5jb25zdCBSRUNPUkRfQU5EX1RVUExFX1NZTlRBWF9UWVBFUyA9IFtcImhhc2hcIiwgXCJiYXJcIl07XG5mdW5jdGlvbiB2YWxpZGF0ZVBsdWdpbnMocGx1Z2lucykge1xuICBpZiAoaGFzUGx1Z2luKHBsdWdpbnMsIFwiZGVjb3JhdG9yc1wiKSkge1xuICAgIGlmIChoYXNQbHVnaW4ocGx1Z2lucywgXCJkZWNvcmF0b3JzLWxlZ2FjeVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSB0aGUgZGVjb3JhdG9ycyBhbmQgZGVjb3JhdG9ycy1sZWdhY3kgcGx1Z2luIHRvZ2V0aGVyXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlY29yYXRvcnNCZWZvcmVFeHBvcnQgPSBnZXRQbHVnaW5PcHRpb24ocGx1Z2lucywgXCJkZWNvcmF0b3JzXCIsIFwiZGVjb3JhdG9yc0JlZm9yZUV4cG9ydFwiKTtcblxuICAgIGlmIChkZWNvcmF0b3JzQmVmb3JlRXhwb3J0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSAnZGVjb3JhdG9ycycgcGx1Z2luIHJlcXVpcmVzIGEgJ2RlY29yYXRvcnNCZWZvcmVFeHBvcnQnIG9wdGlvbixcIiArIFwiIHdob3NlIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLiBJZiB5b3UgYXJlIG1pZ3JhdGluZyBmcm9tXCIgKyBcIiBCYWJ5bG9uL0JhYmVsIDYgb3Igd2FudCB0byB1c2UgdGhlIG9sZCBkZWNvcmF0b3JzIHByb3Bvc2FsLCB5b3VcIiArIFwiIHNob3VsZCB1c2UgdGhlICdkZWNvcmF0b3JzLWxlZ2FjeScgcGx1Z2luIGluc3RlYWQgb2YgJ2RlY29yYXRvcnMnLlwiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWNvcmF0b3JzQmVmb3JlRXhwb3J0ICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2RlY29yYXRvcnNCZWZvcmVFeHBvcnQnIG11c3QgYmUgYSBib29sZWFuLlwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaGFzUGx1Z2luKHBsdWdpbnMsIFwiZmxvd1wiKSAmJiBoYXNQbHVnaW4ocGx1Z2lucywgXCJ0eXBlc2NyaXB0XCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgZmxvdyBhbmQgdHlwZXNjcmlwdCBwbHVnaW5zLlwiKTtcbiAgfVxuXG4gIGlmIChoYXNQbHVnaW4ocGx1Z2lucywgXCJwbGFjZWhvbGRlcnNcIikgJiYgaGFzUGx1Z2luKHBsdWdpbnMsIFwidjhpbnRyaW5zaWNcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tYmluZSBwbGFjZWhvbGRlcnMgYW5kIHY4aW50cmluc2ljIHBsdWdpbnMuXCIpO1xuICB9XG5cbiAgaWYgKGhhc1BsdWdpbihwbHVnaW5zLCBcInBpcGVsaW5lT3BlcmF0b3JcIikpIHtcbiAgICBjb25zdCBwcm9wb3NhbCA9IGdldFBsdWdpbk9wdGlvbihwbHVnaW5zLCBcInBpcGVsaW5lT3BlcmF0b3JcIiwgXCJwcm9wb3NhbFwiKTtcblxuICAgIGlmICghUElQRUxJTkVfUFJPUE9TQUxTLmluY2x1ZGVzKHByb3Bvc2FsKSkge1xuICAgICAgY29uc3QgcHJvcG9zYWxMaXN0ID0gUElQRUxJTkVfUFJPUE9TQUxTLm1hcChwID0+IGBcIiR7cH1cImApLmpvaW4oXCIsIFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCJwaXBlbGluZU9wZXJhdG9yXCIgcmVxdWlyZXMgXCJwcm9wb3NhbFwiIG9wdGlvbiB3aG9zZSB2YWx1ZSBtdXN0IGJlIG9uZSBvZjogJHtwcm9wb3NhbExpc3R9LmApO1xuICAgIH1cblxuICAgIGNvbnN0IHR1cGxlU3ludGF4SXNIYXNoID0gaGFzUGx1Z2luKHBsdWdpbnMsIFtcInJlY29yZEFuZFR1cGxlXCIsIHtcbiAgICAgIHN5bnRheFR5cGU6IFwiaGFzaFwiXG4gICAgfV0pO1xuXG4gICAgaWYgKHByb3Bvc2FsID09PSBcImhhY2tcIikge1xuICAgICAgaWYgKGhhc1BsdWdpbihwbHVnaW5zLCBcInBsYWNlaG9sZGVyc1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tYmluZSBwbGFjZWhvbGRlcnMgcGx1Z2luIGFuZCBIYWNrLXN0eWxlIHBpcGVzLlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1BsdWdpbihwbHVnaW5zLCBcInY4aW50cmluc2ljXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIHY4aW50cmluc2ljIHBsdWdpbiBhbmQgSGFjay1zdHlsZSBwaXBlcy5cIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvcGljVG9rZW4gPSBnZXRQbHVnaW5PcHRpb24ocGx1Z2lucywgXCJwaXBlbGluZU9wZXJhdG9yXCIsIFwidG9waWNUb2tlblwiKTtcblxuICAgICAgaWYgKCFUT1BJQ19UT0tFTlMuaW5jbHVkZXModG9waWNUb2tlbikpIHtcbiAgICAgICAgY29uc3QgdG9rZW5MaXN0ID0gVE9QSUNfVE9LRU5TLm1hcCh0ID0+IGBcIiR7dH1cImApLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcInBpcGVsaW5lT3BlcmF0b3JcIiBpbiBcInByb3Bvc2FsXCI6IFwiaGFja1wiIG1vZGUgYWxzbyByZXF1aXJlcyBhIFwidG9waWNUb2tlblwiIG9wdGlvbiB3aG9zZSB2YWx1ZSBtdXN0IGJlIG9uZSBvZjogJHt0b2tlbkxpc3R9LmApO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9waWNUb2tlbiA9PT0gXCIjXCIgJiYgdHVwbGVTeW50YXhJc0hhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbHVnaW4gY29uZmxpY3QgYmV0d2VlbiBgW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7IHByb3Bvc2FsOiBcImhhY2tcIiwgdG9waWNUb2tlbjogXCIjXCIgfV1gIGFuZCBgW1wicmVjb3JkQW5kdHVwbGVcIiwgeyBzeW50YXhUeXBlOiBcImhhc2hcIn1dYC4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3Bvc2FsID09PSBcInNtYXJ0XCIgJiYgdHVwbGVTeW50YXhJc0hhc2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGx1Z2luIGNvbmZsaWN0IGJldHdlZW4gYFtcInBpcGVsaW5lT3BlcmF0b3JcIiwgeyBwcm9wb3NhbDogXCJzbWFydFwiIH1dYCBhbmQgYFtcInJlY29yZEFuZHR1cGxlXCIsIHsgc3ludGF4VHlwZTogXCJoYXNoXCJ9XWAuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc1BsdWdpbihwbHVnaW5zLCBcIm1vZHVsZUF0dHJpYnV0ZXNcIikpIHtcbiAgICB7XG4gICAgICBpZiAoaGFzUGx1Z2luKHBsdWdpbnMsIFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tYmluZSBpbXBvcnRBc3NlcnRpb25zIGFuZCBtb2R1bGVBdHRyaWJ1dGVzIHBsdWdpbnMuXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtb2R1bGVBdHRyaWJ1dGVzVmVyc2lvblBsdWdpbk9wdGlvbiA9IGdldFBsdWdpbk9wdGlvbihwbHVnaW5zLCBcIm1vZHVsZUF0dHJpYnV0ZXNcIiwgXCJ2ZXJzaW9uXCIpO1xuXG4gICAgICBpZiAobW9kdWxlQXR0cmlidXRlc1ZlcnNpb25QbHVnaW5PcHRpb24gIT09IFwibWF5LTIwMjBcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ21vZHVsZUF0dHJpYnV0ZXMnIHBsdWdpbiByZXF1aXJlcyBhICd2ZXJzaW9uJyBvcHRpb24sXCIgKyBcIiByZXByZXNlbnRpbmcgdGhlIGxhc3QgcHJvcG9zYWwgdXBkYXRlLiBDdXJyZW50bHksIHRoZVwiICsgXCIgb25seSBzdXBwb3J0ZWQgdmFsdWUgaXMgJ21heS0yMDIwJy5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc1BsdWdpbihwbHVnaW5zLCBcInJlY29yZEFuZFR1cGxlXCIpICYmICFSRUNPUkRfQU5EX1RVUExFX1NZTlRBWF9UWVBFUy5pbmNsdWRlcyhnZXRQbHVnaW5PcHRpb24ocGx1Z2lucywgXCJyZWNvcmRBbmRUdXBsZVwiLCBcInN5bnRheFR5cGVcIikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiJ3JlY29yZEFuZFR1cGxlJyByZXF1aXJlcyAnc3ludGF4VHlwZScgb3B0aW9uIHdob3NlIHZhbHVlIHNob3VsZCBiZSBvbmUgb2Y6IFwiICsgUkVDT1JEX0FORF9UVVBMRV9TWU5UQVhfVFlQRVMubWFwKHAgPT4gYCcke3B9J2ApLmpvaW4oXCIsIFwiKSk7XG4gIH1cblxuICBpZiAoaGFzUGx1Z2luKHBsdWdpbnMsIFwiYXN5bmNEb0V4cHJlc3Npb25zXCIpICYmICFoYXNQbHVnaW4ocGx1Z2lucywgXCJkb0V4cHJlc3Npb25zXCIpKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCInYXN5bmNEb0V4cHJlc3Npb25zJyByZXF1aXJlcyAnZG9FeHByZXNzaW9ucycsIHBsZWFzZSBhZGQgJ2RvRXhwcmVzc2lvbnMnIHRvIHBhcnNlciBwbHVnaW5zLlwiKTtcbiAgICBlcnJvci5taXNzaW5nUGx1Z2lucyA9IFwiZG9FeHByZXNzaW9uc1wiO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5jb25zdCBtaXhpblBsdWdpbnMgPSB7XG4gIGVzdHJlZSxcbiAganN4LFxuICBmbG93LFxuICB0eXBlc2NyaXB0LFxuICB2OGludHJpbnNpYyxcbiAgcGxhY2Vob2xkZXJzXG59O1xuY29uc3QgbWl4aW5QbHVnaW5OYW1lcyA9IE9iamVjdC5rZXlzKG1peGluUGx1Z2lucyk7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBzb3VyY2VUeXBlOiBcInNjcmlwdFwiLFxuICBzb3VyY2VGaWxlbmFtZTogdW5kZWZpbmVkLFxuICBzdGFydENvbHVtbjogMCxcbiAgc3RhcnRMaW5lOiAxLFxuICBhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IGZhbHNlLFxuICBhbGxvd1N1cGVyT3V0c2lkZU1ldGhvZDogZmFsc2UsXG4gIGFsbG93VW5kZWNsYXJlZEV4cG9ydHM6IGZhbHNlLFxuICBwbHVnaW5zOiBbXSxcbiAgc3RyaWN0TW9kZTogbnVsbCxcbiAgcmFuZ2VzOiBmYWxzZSxcbiAgdG9rZW5zOiBmYWxzZSxcbiAgY3JlYXRlUGFyZW50aGVzaXplZEV4cHJlc3Npb25zOiBmYWxzZSxcbiAgZXJyb3JSZWNvdmVyeTogZmFsc2UsXG4gIGF0dGFjaENvbW1lbnQ6IHRydWVcbn07XG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGRlZmF1bHRPcHRpb25zKSkge1xuICAgIG9wdGlvbnNba2V5XSA9IG9wdHMgJiYgb3B0c1trZXldICE9IG51bGwgPyBvcHRzW2tleV0gOiBkZWZhdWx0T3B0aW9uc1trZXldO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmNvbnN0IGdldE93biA9IChvYmplY3QsIGtleSkgPT4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIG9iamVjdFtrZXldO1xuXG5jb25zdCB1bndyYXBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IG5vZGUgPT4ge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIgPyB1bndyYXBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24pIDogbm9kZTtcbn07XG5cbmNsYXNzIExWYWxQYXJzZXIgZXh0ZW5kcyBOb2RlVXRpbHMge1xuICB0b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMgPSBmYWxzZSkge1xuICAgIHZhciBfbm9kZSRleHRyYSwgX25vZGUkZXh0cmEzO1xuXG4gICAgbGV0IHBhcmVudGhlc2l6ZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIgfHwgKF9ub2RlJGV4dHJhID0gbm9kZS5leHRyYSkgIT0gbnVsbCAmJiBfbm9kZSRleHRyYS5wYXJlbnRoZXNpemVkKSB7XG4gICAgICBwYXJlbnRoZXNpemVkID0gdW53cmFwUGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZSk7XG5cbiAgICAgIGlmIChpc0xIUykge1xuICAgICAgICBpZiAocGFyZW50aGVzaXplZC50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnJlY29yZEFycm93UGFyZW1ldGVyQmluZGluZ0Vycm9yKEVycm9ycy5JbnZhbGlkUGFyZW50aGVzaXplZEFzc2lnbm1lbnQsIHtcbiAgICAgICAgICAgIGF0OiBub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50aGVzaXplZC50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRQYXJlbnRoZXNpemVkQXNzaWdubWVudCwge1xuICAgICAgICAgICAgYXQ6IG5vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZFBhcmVudGhlc2l6ZWRBc3NpZ25tZW50LCB7XG4gICAgICAgICAgYXQ6IG5vZGVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBub2RlLnByb3BlcnRpZXMubGVuZ3RoLCBsYXN0ID0gbGVuZ3RoIC0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9ub2RlJGV4dHJhMjtcblxuICAgICAgICAgIGNvbnN0IHByb3AgPSBub2RlLnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgY29uc3QgaXNMYXN0ID0gaSA9PT0gbGFzdDtcbiAgICAgICAgICB0aGlzLnRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpO1xuXG4gICAgICAgICAgaWYgKGlzTGFzdCAmJiBwcm9wLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiAoX25vZGUkZXh0cmEyID0gbm9kZS5leHRyYSkgIT0gbnVsbCAmJiBfbm9kZSRleHRyYTIudHJhaWxpbmdDb21tYUxvYykge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUmVzdFRyYWlsaW5nQ29tbWEsIHtcbiAgICAgICAgICAgICAgYXQ6IG5vZGUuZXh0cmEudHJhaWxpbmdDb21tYUxvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gbm9kZTtcblxuICAgICAgICAgIGlmICh0aGlzLmlzUHJpdmF0ZU5hbWUoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihrZXkpLCBrZXkubG9jLnN0YXJ0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRvQXNzaWduYWJsZSh2YWx1ZSwgaXNMSFMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBAYmFiZWwvcGFyc2VyIGVycm9yICh0aGlzIGlzIGEgYnVnLCBwbGVhc2UgcmVwb3J0IGl0KS5cIiArIFwiIFNwcmVhZEVsZW1lbnQgc2hvdWxkIGJlIGNvbnZlcnRlZCBieSAudG9Bc3NpZ25hYmxlJ3MgY2FsbGVyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCAoX25vZGUkZXh0cmEzID0gbm9kZS5leHRyYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGV4dHJhMy50cmFpbGluZ0NvbW1hTG9jLCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiPVwiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ0VxSW5Bc3NpZ25tZW50LCB7XG4gICAgICAgICAgICBhdDogbm9kZS5sZWZ0LmxvYy5lbmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUudHlwZSA9IFwiQXNzaWdubWVudFBhdHRlcm5cIjtcbiAgICAgICAgZGVsZXRlIG5vZGUub3BlcmF0b3I7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUubGVmdCwgaXNMSFMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHBhcmVudGhlc2l6ZWQsIGlzTEhTKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdG9Bc3NpZ25hYmxlT2JqZWN0RXhwcmVzc2lvblByb3AocHJvcCwgaXNMYXN0LCBpc0xIUykge1xuICAgIGlmIChwcm9wLnR5cGUgPT09IFwiT2JqZWN0TWV0aG9kXCIpIHtcbiAgICAgIHRoaXMucmFpc2UocHJvcC5raW5kID09PSBcImdldFwiIHx8IHByb3Aua2luZCA9PT0gXCJzZXRcIiA/IEVycm9ycy5QYXR0ZXJuSGFzQWNjZXNzb3IgOiBFcnJvcnMuUGF0dGVybkhhc01ldGhvZCwge1xuICAgICAgICBhdDogcHJvcC5rZXlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgcHJvcC50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgY29uc3QgYXJnID0gcHJvcC5hcmd1bWVudDtcbiAgICAgIHRoaXMuY2hlY2tUb1Jlc3RDb252ZXJzaW9uKGFyZywgZmFsc2UpO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUoYXJnLCBpc0xIUyk7XG5cbiAgICAgIGlmICghaXNMYXN0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlJlc3RUcmFpbGluZ0NvbW1hLCB7XG4gICAgICAgICAgYXQ6IHByb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHByb3AsIGlzTEhTKTtcbiAgICB9XG4gIH1cblxuICB0b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0LCB0cmFpbGluZ0NvbW1hTG9jLCBpc0xIUykge1xuICAgIGNvbnN0IGVuZCA9IGV4cHJMaXN0Lmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoIWVsdCkgY29udGludWU7XG5cbiAgICAgIGlmIChlbHQudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgICAgZWx0LnR5cGUgPSBcIlJlc3RFbGVtZW50XCI7XG4gICAgICAgIGNvbnN0IGFyZyA9IGVsdC5hcmd1bWVudDtcbiAgICAgICAgdGhpcy5jaGVja1RvUmVzdENvbnZlcnNpb24oYXJnLCB0cnVlKTtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUoYXJnLCBpc0xIUyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShlbHQsIGlzTEhTKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsdC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgICAgaWYgKGkgPCBlbmQpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5SZXN0VHJhaWxpbmdDb21tYSwge1xuICAgICAgICAgICAgYXQ6IGVsdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWlsaW5nQ29tbWFMb2MpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5SZXN0VHJhaWxpbmdDb21tYSwge1xuICAgICAgICAgICAgYXQ6IHRyYWlsaW5nQ29tbWFMb2NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlzQXNzaWduYWJsZShub2RlLCBpc0JpbmRpbmcpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxhc3QgPSBub2RlLnByb3BlcnRpZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICByZXR1cm4gbm9kZS5wcm9wZXJ0aWVzLmV2ZXJ5KChwcm9wLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcC50eXBlICE9PSBcIk9iamVjdE1ldGhvZFwiICYmIChpID09PSBsYXN0IHx8IHByb3AudHlwZSAhPT0gXCJTcHJlYWRFbGVtZW50XCIpICYmIHRoaXMuaXNBc3NpZ25hYmxlKHByb3ApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gdGhpcy5pc0Fzc2lnbmFibGUobm9kZS52YWx1ZSk7XG5cbiAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLmFyZ3VtZW50KTtcblxuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gbm9kZS5lbGVtZW50cy5ldmVyeShlbGVtZW50ID0+IGVsZW1lbnQgPT09IG51bGwgfHwgdGhpcy5pc0Fzc2lnbmFibGUoZWxlbWVudCkpO1xuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIG5vZGUub3BlcmF0b3IgPT09IFwiPVwiO1xuXG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbik7XG5cbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiAhaXNCaW5kaW5nO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdG9SZWZlcmVuY2VkTGlzdChleHByTGlzdCwgaXNQYXJlbnRoZXNpemVkRXhwcikge1xuICAgIHJldHVybiBleHByTGlzdDtcbiAgfVxuXG4gIHRvUmVmZXJlbmNlZExpc3REZWVwKGV4cHJMaXN0LCBpc1BhcmVudGhlc2l6ZWRFeHByKSB7XG4gICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KGV4cHJMaXN0LCBpc1BhcmVudGhlc2l6ZWRFeHByKTtcblxuICAgIGZvciAoY29uc3QgZXhwciBvZiBleHByTGlzdCkge1xuICAgICAgaWYgKChleHByID09IG51bGwgPyB2b2lkIDAgOiBleHByLnR5cGUpID09PSBcIkFycmF5RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdERlZXAoZXhwci5lbGVtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGFyc2VTcHJlYWQocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKHJlZkV4cHJlc3Npb25FcnJvcnMsIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZVJlc3RCaW5kaW5nKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVzdEVsZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZUJpbmRpbmdBdG9tKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KDMsIDkzLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyYXlQYXR0ZXJuXCIpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3RMaWtlKDgsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICB9XG5cbiAgcGFyc2VCaW5kaW5nTGlzdChjbG9zZSwgY2xvc2VDaGFyQ29kZSwgYWxsb3dFbXB0eSwgYWxsb3dNb2RpZmllcnMpIHtcbiAgICBjb25zdCBlbHRzID0gW107XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcblxuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcy5tYXRjaCgxMikpIHtcbiAgICAgICAgZWx0cy5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlQXNzaWduYWJsZUxpc3RJdGVtVHlwZXModGhpcy5wYXJzZVJlc3RCaW5kaW5nKCkpKTtcblxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tDb21tYUFmdGVyUmVzdChjbG9zZUNoYXJDb2RlKSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0KGNsb3NlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVjb3JhdG9ycyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDI2KSAmJiB0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZFBhcmFtZXRlckRlY29yYXRvciwge1xuICAgICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgICAgIGRlY29yYXRvcnMucHVzaCh0aGlzLnBhcnNlRGVjb3JhdG9yKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWx0cy5wdXNoKHRoaXMucGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW0oYWxsb3dNb2RpZmllcnMsIGRlY29yYXRvcnMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWx0cztcbiAgfVxuXG4gIHBhcnNlQmluZGluZ1Jlc3RQcm9wZXJ0eShwcm9wKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcHJvcC5hcmd1bWVudCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5jaGVja0NvbW1hQWZ0ZXJSZXN0KDEyNSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlJlc3RFbGVtZW50XCIpO1xuICB9XG5cbiAgcGFyc2VCaW5kaW5nUHJvcGVydHkoKSB7XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHN0YXJ0OiBzdGFydFBvcyxcbiAgICAgIHN0YXJ0TG9jXG4gICAgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBpZiAodHlwZSA9PT0gMjEpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQmluZGluZ1Jlc3RQcm9wZXJ0eShwcm9wKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDEzNCkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJkZXN0cnVjdHVyaW5nUHJpdmF0ZVwiLCBzdGFydExvYyk7XG4gICAgICB0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUodGhpcy5zdGF0ZS52YWx1ZSwgc3RhcnRMb2MpO1xuICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICB9XG5cbiAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0UG9zLCBzdGFydExvYywgZmFsc2UsIGZhbHNlLCB0cnVlLCBmYWxzZSk7XG4gIH1cblxuICBwYXJzZUFzc2lnbmFibGVMaXN0SXRlbShhbGxvd01vZGlmaWVycywgZGVjb3JhdG9ycykge1xuICAgIGNvbnN0IGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KCk7XG4gICAgdGhpcy5wYXJzZUFzc2lnbmFibGVMaXN0SXRlbVR5cGVzKGxlZnQpO1xuICAgIGNvbnN0IGVsdCA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQobGVmdC5zdGFydCwgbGVmdC5sb2Muc3RhcnQsIGxlZnQpO1xuXG4gICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICBsZWZ0LmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzO1xuICAgIH1cblxuICAgIHJldHVybiBlbHQ7XG4gIH1cblxuICBwYXJzZUFzc2lnbmFibGVMaXN0SXRlbVR5cGVzKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG5cbiAgcGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCBsZWZ0KSB7XG4gICAgdmFyIF9zdGFydExvYywgX3N0YXJ0UG9zLCBfbGVmdDtcblxuICAgIHN0YXJ0TG9jID0gKF9zdGFydExvYyA9IHN0YXJ0TG9jKSAhPSBudWxsID8gX3N0YXJ0TG9jIDogdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBzdGFydFBvcyA9IChfc3RhcnRQb3MgPSBzdGFydFBvcykgIT0gbnVsbCA/IF9zdGFydFBvcyA6IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgbGVmdCA9IChfbGVmdCA9IGxlZnQpICE9IG51bGwgPyBfbGVmdCA6IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIGlmICghdGhpcy5lYXQoMjkpKSByZXR1cm4gbGVmdDtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIik7XG4gIH1cblxuICBpc1ZhbGlkTFZhbCh0eXBlLCBpc1VucGFyZW50aGVzaXplZEluQXNzaWduLCBiaW5kaW5nKSB7XG4gICAgcmV0dXJuIGdldE93bih7XG4gICAgICBBc3NpZ25tZW50UGF0dGVybjogXCJsZWZ0XCIsXG4gICAgICBSZXN0RWxlbWVudDogXCJhcmd1bWVudFwiLFxuICAgICAgT2JqZWN0UHJvcGVydHk6IFwidmFsdWVcIixcbiAgICAgIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uOiBcImV4cHJlc3Npb25cIixcbiAgICAgIEFycmF5UGF0dGVybjogXCJlbGVtZW50c1wiLFxuICAgICAgT2JqZWN0UGF0dGVybjogXCJwcm9wZXJ0aWVzXCJcbiAgICB9LCB0eXBlKTtcbiAgfVxuXG4gIGNoZWNrTFZhbChleHByZXNzaW9uLCB7XG4gICAgaW46IGFuY2VzdG9yLFxuICAgIGJpbmRpbmcgPSBCSU5EX05PTkUsXG4gICAgY2hlY2tDbGFzaGVzID0gZmFsc2UsXG4gICAgc3RyaWN0TW9kZUNoYW5nZWQgPSBmYWxzZSxcbiAgICBhbGxvd2luZ1Nsb3BweUxldEJpbmRpbmcgPSAhKGJpbmRpbmcgJiBCSU5EX1NDT1BFX0xFWElDQUwpLFxuICAgIGhhc1BhcmVudGhlc2l6ZWRBbmNlc3RvciA9IGZhbHNlXG4gIH0pIHtcbiAgICB2YXIgX2V4cHJlc3Npb24kZXh0cmE7XG5cbiAgICBjb25zdCB0eXBlID0gZXhwcmVzc2lvbi50eXBlO1xuICAgIGlmICh0aGlzLmlzT2JqZWN0TWV0aG9kKGV4cHJlc3Npb24pKSByZXR1cm47XG5cbiAgICBpZiAodHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgIGlmIChiaW5kaW5nICE9PSBCSU5EX05PTkUpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZFByb3BlcnR5QmluZGluZ1BhdHRlcm4sIHtcbiAgICAgICAgICBhdDogZXhwcmVzc2lvblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChleHByZXNzaW9uLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihleHByZXNzaW9uLCBiaW5kaW5nLCBzdHJpY3RNb2RlQ2hhbmdlZCwgYWxsb3dpbmdTbG9wcHlMZXRCaW5kaW5nKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IGV4cHJlc3Npb247XG5cbiAgICAgIGlmIChjaGVja0NsYXNoZXMpIHtcbiAgICAgICAgaWYgKGNoZWNrQ2xhc2hlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5QYXJhbUR1cGUsIHtcbiAgICAgICAgICAgIGF0OiBleHByZXNzaW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2tDbGFzaGVzLmFkZChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWRpdHkgPSB0aGlzLmlzVmFsaWRMVmFsKGV4cHJlc3Npb24udHlwZSwgIShoYXNQYXJlbnRoZXNpemVkQW5jZXN0b3IgfHwgKF9leHByZXNzaW9uJGV4dHJhID0gZXhwcmVzc2lvbi5leHRyYSkgIT0gbnVsbCAmJiBfZXhwcmVzc2lvbiRleHRyYS5wYXJlbnRoZXNpemVkKSAmJiBhbmNlc3Rvci50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsIGJpbmRpbmcpO1xuICAgIGlmICh2YWxpZGl0eSA9PT0gdHJ1ZSkgcmV0dXJuO1xuXG4gICAgaWYgKHZhbGlkaXR5ID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgUGFyc2VFcnJvckNsYXNzID0gYmluZGluZyA9PT0gQklORF9OT05FID8gRXJyb3JzLkludmFsaWRMaHMgOiBFcnJvcnMuSW52YWxpZExoc0JpbmRpbmc7XG4gICAgICB0aGlzLnJhaXNlKFBhcnNlRXJyb3JDbGFzcywge1xuICAgICAgICBhdDogZXhwcmVzc2lvbixcbiAgICAgICAgYW5jZXN0b3I6IGFuY2VzdG9yLnR5cGUgPT09IFwiVXBkYXRlRXhwcmVzc2lvblwiID8ge1xuICAgICAgICAgIHR5cGU6IFwiVXBkYXRlRXhwcmVzc2lvblwiLFxuICAgICAgICAgIHByZWZpeDogYW5jZXN0b3IucHJlZml4XG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgdHlwZTogYW5jZXN0b3IudHlwZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBba2V5LCBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uXSA9IEFycmF5LmlzQXJyYXkodmFsaWRpdHkpID8gdmFsaWRpdHkgOiBbdmFsaWRpdHksIHR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIl07XG4gICAgY29uc3QgbmV4dEFuY2VzdG9yID0gZXhwcmVzc2lvbi50eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IGV4cHJlc3Npb24udHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIgfHwgZXhwcmVzc2lvbi50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIgPyBleHByZXNzaW9uIDogYW5jZXN0b3I7XG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIFtdLmNvbmNhdChleHByZXNzaW9uW2tleV0pKSB7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgdGhpcy5jaGVja0xWYWwoY2hpbGQsIHtcbiAgICAgICAgICBpbjogbmV4dEFuY2VzdG9yLFxuICAgICAgICAgIGJpbmRpbmcsXG4gICAgICAgICAgY2hlY2tDbGFzaGVzLFxuICAgICAgICAgIGFsbG93aW5nU2xvcHB5TGV0QmluZGluZyxcbiAgICAgICAgICBzdHJpY3RNb2RlQ2hhbmdlZCxcbiAgICAgICAgICBoYXNQYXJlbnRoZXNpemVkQW5jZXN0b3I6IGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2hlY2tJZGVudGlmaWVyKGF0LCBiaW5kaW5nVHlwZSwgc3RyaWN0TW9kZUNoYW5nZWQgPSBmYWxzZSwgYWxsb3dMZXRCaW5kaW5nID0gIShiaW5kaW5nVHlwZSAmIEJJTkRfU0NPUEVfTEVYSUNBTCkpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdHJpY3QgJiYgKHN0cmljdE1vZGVDaGFuZ2VkID8gaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkKGF0Lm5hbWUsIHRoaXMuaW5Nb2R1bGUpIDogaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZChhdC5uYW1lKSkpIHtcbiAgICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gQklORF9OT05FKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlN0cmljdEV2YWxBcmd1bWVudHMsIHtcbiAgICAgICAgICBhdCxcbiAgICAgICAgICByZWZlcmVuY2VOYW1lOiBhdC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RyaWN0RXZhbEFyZ3VtZW50c0JpbmRpbmcsIHtcbiAgICAgICAgICBhdCxcbiAgICAgICAgICBiaW5kaW5nTmFtZTogYXQubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFsbG93TGV0QmluZGluZyAmJiBhdC5uYW1lID09PSBcImxldFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5MZXRJbkxleGljYWxCaW5kaW5nLCB7XG4gICAgICAgIGF0XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIShiaW5kaW5nVHlwZSAmIEJJTkRfTk9ORSkpIHtcbiAgICAgIHRoaXMuZGVjbGFyZU5hbWVGcm9tSWRlbnRpZmllcihhdCwgYmluZGluZ1R5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGRlY2xhcmVOYW1lRnJvbUlkZW50aWZpZXIoaWRlbnRpZmllciwgYmluZGluZykge1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUoaWRlbnRpZmllci5uYW1lLCBiaW5kaW5nLCBpZGVudGlmaWVyLmxvYy5zdGFydCk7XG4gIH1cblxuICBjaGVja1RvUmVzdENvbnZlcnNpb24obm9kZSwgYWxsb3dQYXR0ZXJuKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLmNoZWNrVG9SZXN0Q29udmVyc2lvbihub2RlLmV4cHJlc3Npb24sIGFsbG93UGF0dGVybik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChhbGxvd1BhdHRlcm4pIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUmVzdEFzc2lnbm1lbnRQYXR0ZXJuLCB7XG4gICAgICAgICAgYXQ6IG5vZGVcbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tDb21tYUFmdGVyUmVzdChjbG9zZSkge1xuICAgIGlmICghdGhpcy5tYXRjaCgxMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnJhaXNlKHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gY2xvc2UgPyBFcnJvcnMuUmVzdFRyYWlsaW5nQ29tbWEgOiBFcnJvcnMuRWxlbWVudEFmdGVyUmVzdCwge1xuICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG59XG5cbmNsYXNzIEV4cHJlc3Npb25QYXJzZXIgZXh0ZW5kcyBMVmFsUGFyc2VyIHtcbiAgY2hlY2tQcm90byhwcm9wLCBpc1JlY29yZCwgcHJvdG9SZWYsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAocHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIiB8fCB0aGlzLmlzT2JqZWN0TWV0aG9kKHByb3ApIHx8IHByb3AuY29tcHV0ZWQgfHwgcHJvcC5zaG9ydGhhbmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSBwcm9wLmtleTtcbiAgICBjb25zdCBuYW1lID0ga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8ga2V5Lm5hbWUgOiBrZXkudmFsdWU7XG5cbiAgICBpZiAobmFtZSA9PT0gXCJfX3Byb3RvX19cIikge1xuICAgICAgaWYgKGlzUmVjb3JkKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlJlY29yZE5vUHJvdG8sIHtcbiAgICAgICAgICBhdDoga2V5XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm90b1JlZi51c2VkKSB7XG4gICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMuZG91YmxlUHJvdG9Mb2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMuZG91YmxlUHJvdG9Mb2MgPSBrZXkubG9jLnN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EdXBsaWNhdGVQcm90bywge1xuICAgICAgICAgICAgYXQ6IGtleVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByb3RvUmVmLnVzZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHNob3VsZEV4aXREZXNjZW5kaW5nKGV4cHIsIHBvdGVudGlhbEFycm93QXQpIHtcbiAgICByZXR1cm4gZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgZXhwci5zdGFydCA9PT0gcG90ZW50aWFsQXJyb3dBdDtcbiAgfVxuXG4gIGdldEV4cHJlc3Npb24oKSB7XG4gICAgdGhpcy5lbnRlckluaXRpYWxTY29wZXMoKTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgaWYgKCF0aGlzLm1hdGNoKDEzNSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cblxuICAgIHRoaXMuZmluYWxpemVSZW1haW5pbmdDb21tZW50cygpO1xuICAgIGV4cHIuY29tbWVudHMgPSB0aGlzLnN0YXRlLmNvbW1lbnRzO1xuICAgIGV4cHIuZXJyb3JzID0gdGhpcy5zdGF0ZS5lcnJvcnM7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnRva2Vucykge1xuICAgICAgZXhwci50b2tlbnMgPSB0aGlzLnRva2VucztcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIHBhcnNlRXhwcmVzc2lvbihkaXNhbGxvd0luLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKGRpc2FsbG93SW4pIHtcbiAgICAgIHJldHVybiB0aGlzLmRpc2FsbG93SW5BbmQoKCkgPT4gdGhpcy5wYXJzZUV4cHJlc3Npb25CYXNlKHJlZkV4cHJlc3Npb25FcnJvcnMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hbGxvd0luQW5kKCgpID0+IHRoaXMucGFyc2VFeHByZXNzaW9uQmFzZShyZWZFeHByZXNzaW9uRXJyb3JzKSk7XG4gIH1cblxuICBwYXJzZUV4cHJlc3Npb25CYXNlKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycyk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCgxMikpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuXG4gICAgICB3aGlsZSAodGhpcy5lYXQoMTIpKSB7XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3Qobm9kZS5leHByZXNzaW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgcGFyc2VNYXliZUFzc2lnbkRpc2FsbG93SW4ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNhbGxvd0luQW5kKCgpID0+IHRoaXMucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkpO1xuICB9XG5cbiAgcGFyc2VNYXliZUFzc2lnbkFsbG93SW4ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd0luQW5kKCgpID0+IHRoaXMucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkpO1xuICB9XG5cbiAgc2V0T3B0aW9uYWxQYXJhbWV0ZXJzRXJyb3IocmVmRXhwcmVzc2lvbkVycm9ycywgcmVzdWx0RXJyb3IpIHtcbiAgICB2YXIgX3Jlc3VsdEVycm9yJGxvYztcblxuICAgIHJlZkV4cHJlc3Npb25FcnJvcnMub3B0aW9uYWxQYXJhbWV0ZXJzTG9jID0gKF9yZXN1bHRFcnJvciRsb2MgPSByZXN1bHRFcnJvciA9PSBudWxsID8gdm9pZCAwIDogcmVzdWx0RXJyb3IubG9jKSAhPSBudWxsID8gX3Jlc3VsdEVycm9yJGxvYyA6IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIH1cblxuICBwYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcblxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMDUpKSB7XG4gICAgICBpZiAodGhpcy5wcm9kUGFyYW0uaGFzWWllbGQpIHtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLnBhcnNlWWllbGQoKTtcblxuICAgICAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICAgICAgICBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG93bkV4cHJlc3Npb25FcnJvcnM7XG5cbiAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgICAgb3duRXhwcmVzc2lvbkVycm9ycyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWZFeHByZXNzaW9uRXJyb3JzID0gbmV3IEV4cHJlc3Npb25FcnJvcnMoKTtcbiAgICAgIG93bkV4cHJlc3Npb25FcnJvcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcblxuICAgIGlmICh0eXBlID09PSAxMCB8fCB0b2tlbklzSWRlbnRpZmllcih0eXBlKSkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICB9XG5cbiAgICBsZXQgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuXG4gICAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgICBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIH1cblxuICAgIGlmICh0b2tlbklzQXNzaWdubWVudCh0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgbm9kZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuXG4gICAgICBpZiAodGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobGVmdCwgdHJ1ZSk7XG4gICAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG5cbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMuZG91YmxlUHJvdG9Mb2MgIT0gbnVsbCAmJiByZWZFeHByZXNzaW9uRXJyb3JzLmRvdWJsZVByb3RvTG9jLmluZGV4ID49IHN0YXJ0UG9zKSB7XG4gICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5kb3VibGVQcm90b0xvYyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycy5zaG9ydGhhbmRBc3NpZ25Mb2MgIT0gbnVsbCAmJiByZWZFeHByZXNzaW9uRXJyb3JzLnNob3J0aGFuZEFzc2lnbkxvYy5pbmRleCA+PSBzdGFydFBvcykge1xuICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMuc2hvcnRoYW5kQXNzaWduTG9jID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnByaXZhdGVLZXlMb2MgIT0gbnVsbCAmJiByZWZFeHByZXNzaW9uRXJyb3JzLnByaXZhdGVLZXlMb2MuaW5kZXggPj0gc3RhcnRQb3MpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrRGVzdHJ1Y3R1cmluZ1ByaXZhdGUocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5wcml2YXRlS2V5TG9jID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChsZWZ0LCB7XG4gICAgICAgIGluOiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG93bkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBsZWZ0O1xuICB9XG5cbiAgcGFyc2VNYXliZUNvbmRpdGlvbmFsKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IHBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQ7XG4gICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkRXhpdERlc2NlbmRpbmcoZXhwciwgcG90ZW50aWFsQXJyb3dBdCkpIHtcbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxuXG4gIHBhcnNlQ29uZGl0aW9uYWwoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIHBhcnNlTWF5YmVVbmFyeU9yUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTM0KSA/IHRoaXMucGFyc2VQcml2YXRlTmFtZSgpIDogdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cblxuICBwYXJzZUV4cHJPcHMocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgcG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdDtcbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnlPclByaXZhdGUocmVmRXhwcmVzc2lvbkVycm9ycyk7XG5cbiAgICBpZiAodGhpcy5zaG91bGRFeGl0RGVzY2VuZGluZyhleHByLCBwb3RlbnRpYWxBcnJvd0F0KSkge1xuICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3AoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCAtMSk7XG4gIH1cblxuICBwYXJzZUV4cHJPcChsZWZ0LCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYykge1xuICAgIGlmICh0aGlzLmlzUHJpdmF0ZU5hbWUobGVmdCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRQcml2YXRlTmFtZVNWKGxlZnQpO1xuXG4gICAgICBpZiAobWluUHJlYyA+PSB0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZSg1OCkgfHwgIXRoaXMucHJvZFBhcmFtLmhhc0luIHx8ICF0aGlzLm1hdGNoKDU4KSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Qcml2YXRlSW5FeHBlY3RlZEluLCB7XG4gICAgICAgICAgYXQ6IGxlZnQsXG4gICAgICAgICAgaWRlbnRpZmllck5hbWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUodmFsdWUsIGxlZnQubG9jLnN0YXJ0KTtcbiAgICB9XG5cbiAgICBjb25zdCBvcCA9IHRoaXMuc3RhdGUudHlwZTtcblxuICAgIGlmICh0b2tlbklzT3BlcmF0b3Iob3ApICYmICh0aGlzLnByb2RQYXJhbS5oYXNJbiB8fCAhdGhpcy5tYXRjaCg1OCkpKSB7XG4gICAgICBsZXQgcHJlYyA9IHRva2VuT3BlcmF0b3JQcmVjZWRlbmNlKG9wKTtcblxuICAgICAgaWYgKHByZWMgPiBtaW5QcmVjKSB7XG4gICAgICAgIGlmIChvcCA9PT0gMzkpIHtcbiAgICAgICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInBpcGVsaW5lT3BlcmF0b3JcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5jaGVja1BpcGVsaW5lQXRJbmZpeE9wZXJhdG9yKGxlZnQsIGxlZnRTdGFydExvYyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYyk7XG4gICAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgICBjb25zdCBsb2dpY2FsID0gb3AgPT09IDQxIHx8IG9wID09PSA0MjtcbiAgICAgICAgY29uc3QgY29hbGVzY2UgPSBvcCA9PT0gNDA7XG5cbiAgICAgICAgaWYgKGNvYWxlc2NlKSB7XG4gICAgICAgICAgcHJlYyA9IHRva2VuT3BlcmF0b3JQcmVjZWRlbmNlKDQyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgIGlmIChvcCA9PT0gMzkgJiYgdGhpcy5oYXNQbHVnaW4oW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7XG4gICAgICAgICAgcHJvcG9zYWw6IFwibWluaW1hbFwiXG4gICAgICAgIH1dKSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IDk2ICYmIHRoaXMucHJvZFBhcmFtLmhhc0F3YWl0KSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkQXdhaXRBZnRlclBpcGVsaW5lQm9keSwge1xuICAgICAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5zdGFydExvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VFeHByT3BSaWdodEV4cHIob3AsIHByZWMpO1xuICAgICAgICBjb25zdCBmaW5pc2hlZE5vZGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbG9naWNhbCB8fCBjb2FsZXNjZSA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKTtcbiAgICAgICAgY29uc3QgbmV4dE9wID0gdGhpcy5zdGF0ZS50eXBlO1xuXG4gICAgICAgIGlmIChjb2FsZXNjZSAmJiAobmV4dE9wID09PSA0MSB8fCBuZXh0T3AgPT09IDQyKSB8fCBsb2dpY2FsICYmIG5leHRPcCA9PT0gNDApIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5NaXhpbmdDb2FsZXNjZVdpdGhMb2dpY2FsLCB7XG4gICAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5zdGFydExvY1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3AoZmluaXNoZWROb2RlLCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cblxuICBwYXJzZUV4cHJPcFJpZ2h0RXhwcihvcCwgcHJlYykge1xuICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG5cbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpKSB7XG4gICAgICAgICAgY2FzZSBcImhhY2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpdGhUb3BpY0JpbmRpbmdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VIYWNrUGlwZUJvZHkoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSBcInNtYXJ0XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXRoVG9waWNCaW5kaW5nQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMDUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuUGlwZUJvZHlJc1RpZ2h0ZXIsIHtcbiAgICAgICAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNtYXJ0UGlwZWxpbmVCb2R5SW5TdHlsZSh0aGlzLnBhcnNlRXhwck9wQmFzZVJpZ2h0RXhwcihvcCwgcHJlYyksIHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgXCJmc2hhcnBcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpdGhTb2xvQXdhaXRQZXJtaXR0aW5nQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRlNoYXJwUGlwZWxpbmVCb2R5KHByZWMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3BCYXNlUmlnaHRFeHByKG9wLCBwcmVjKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUV4cHJPcEJhc2VSaWdodEV4cHIob3AsIHByZWMpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5T3JQcml2YXRlKCksIHN0YXJ0UG9zLCBzdGFydExvYywgdG9rZW5Jc1JpZ2h0QXNzb2NpYXRpdmUob3ApID8gcHJlYyAtIDEgOiBwcmVjKTtcbiAgfVxuXG4gIHBhcnNlSGFja1BpcGVCb2R5KCkge1xuICAgIHZhciBfYm9keSRleHRyYTtcblxuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0TG9jXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIGNvbnN0IHJlcXVpcmVkUGFyZW50aGVzZXMgPSBVbnBhcmVudGhlc2l6ZWRQaXBlQm9keURlc2NyaXB0aW9ucy5oYXMoYm9keS50eXBlKTtcblxuICAgIGlmIChyZXF1aXJlZFBhcmVudGhlc2VzICYmICEoKF9ib2R5JGV4dHJhID0gYm9keS5leHRyYSkgIT0gbnVsbCAmJiBfYm9keSRleHRyYS5wYXJlbnRoZXNpemVkKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUGlwZVVucGFyZW50aGVzaXplZEJvZHksIHtcbiAgICAgICAgYXQ6IHN0YXJ0TG9jLFxuICAgICAgICB0eXBlOiBib2R5LnR5cGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy50b3BpY1JlZmVyZW5jZVdhc1VzZWRJbkN1cnJlbnRDb250ZXh0KCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlBpcGVUb3BpY1VudXNlZCwge1xuICAgICAgICBhdDogc3RhcnRMb2NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBib2R5O1xuICB9XG5cbiAgY2hlY2tFeHBvbmVudGlhbEFmdGVyVW5hcnkobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDU3KSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFRva2VuVW5hcnlFeHBvbmVudGlhdGlvbiwge1xuICAgICAgICBhdDogbm9kZS5hcmd1bWVudFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VNYXliZVVuYXJ5KHJlZkV4cHJlc3Npb25FcnJvcnMsIHNhd1VuYXJ5KSB7XG4gICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBpc0F3YWl0ID0gdGhpcy5pc0NvbnRleHR1YWwoOTYpO1xuXG4gICAgaWYgKGlzQXdhaXQgJiYgdGhpcy5pc0F3YWl0QWxsb3dlZCgpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlQXdhaXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIGlmICghc2F3VW5hcnkpIHRoaXMuY2hlY2tFeHBvbmVudGlhbEFmdGVyVW5hcnkoZXhwcik7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGUgPSB0aGlzLm1hdGNoKDM0KTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcblxuICAgIGlmICh0b2tlbklzUHJlZml4KHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5tYXRjaCg3MikpIHtcbiAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJ0aHJvd0V4cHJlc3Npb25zXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0RlbGV0ZSA9IHRoaXMubWF0Y2goODkpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSk7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcblxuICAgICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIGlzRGVsZXRlKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IG5vZGUuYXJndW1lbnQ7XG5cbiAgICAgICAgaWYgKGFyZy50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlN0cmljdERlbGV0ZSwge1xuICAgICAgICAgICAgYXQ6IG5vZGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc1Byb3BlcnR5QXNQcml2YXRlTmFtZShhcmcpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVsZXRlUHJpdmF0ZUZpZWxkLCB7XG4gICAgICAgICAgICBhdDogbm9kZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdXBkYXRlKSB7XG4gICAgICAgIGlmICghc2F3VW5hcnkpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrRXhwb25lbnRpYWxBZnRlclVuYXJ5KG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlVuYXJ5RXhwcmVzc2lvblwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZVVwZGF0ZShub2RlLCB1cGRhdGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuXG4gICAgaWYgKGlzQXdhaXQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBzdGFydHNFeHByID0gdGhpcy5oYXNQbHVnaW4oXCJ2OGludHJpbnNpY1wiKSA/IHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHR5cGUpIDogdG9rZW5DYW5TdGFydEV4cHJlc3Npb24odHlwZSkgJiYgIXRoaXMubWF0Y2goNTQpO1xuXG4gICAgICBpZiAoc3RhcnRzRXhwciAmJiAhdGhpcy5pc0FtYmlndW91c0F3YWl0KCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZU92ZXJ3cml0ZShFcnJvcnMuQXdhaXROb3RJbkFzeW5jQ29udGV4dCwge1xuICAgICAgICAgIGF0OiBzdGFydExvY1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBd2FpdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgcGFyc2VVcGRhdGUobm9kZSwgdXBkYXRlLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgY29uc3QgdXBkYXRlRXhwcmVzc2lvbk5vZGUgPSBub2RlO1xuICAgICAgdGhpcy5jaGVja0xWYWwodXBkYXRlRXhwcmVzc2lvbk5vZGUuYXJndW1lbnQsIHtcbiAgICAgICAgaW46IHRoaXMuZmluaXNoTm9kZSh1cGRhdGVFeHByZXNzaW9uTm9kZSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbGV0IGV4cHIgPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIGZhbHNlKSkgcmV0dXJuIGV4cHI7XG5cbiAgICB3aGlsZSAodG9rZW5Jc1Bvc3RmaXgodGhpcy5zdGF0ZS50eXBlKSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSBmYWxzZTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSBleHByO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLCB7XG4gICAgICAgIGluOiBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVXBkYXRlRXhwcmVzc2lvblwiKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICBwYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IHBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQ7XG4gICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKTtcblxuICAgIGlmICh0aGlzLnNob3VsZEV4aXREZXNjZW5kaW5nKGV4cHIsIHBvdGVudGlhbEFycm93QXQpKSB7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgfVxuXG4gIHBhcnNlU3Vic2NyaXB0cyhiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgIG9wdGlvbmFsQ2hhaW5NZW1iZXI6IGZhbHNlLFxuICAgICAgbWF5YmVBc3luY0Fycm93OiB0aGlzLmF0UG9zc2libGVBc3luY0Fycm93KGJhc2UpLFxuICAgICAgc3RvcDogZmFsc2VcbiAgICB9O1xuXG4gICAgZG8ge1xuICAgICAgYmFzZSA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5tYXliZUFzeW5jQXJyb3cgPSBmYWxzZTtcbiAgICB9IHdoaWxlICghc3RhdGUuc3RvcCk7XG5cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIHBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBpZiAoIW5vQ2FsbHMgJiYgdHlwZSA9PT0gMTUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQmluZChiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuSXNUZW1wbGF0ZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgbGV0IG9wdGlvbmFsID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZSA9PT0gMTgpIHtcbiAgICAgIGlmIChub0NhbGxzICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNDApIHtcbiAgICAgICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyID0gb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKCFub0NhbGxzICYmIHRoaXMubWF0Y2goMTApKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNvdmVyQ2FsbEFuZEFzeW5jQXJyb3dIZWFkKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgc3RhdGUsIG9wdGlvbmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29tcHV0ZWQgPSB0aGlzLmVhdCgwKTtcblxuICAgICAgaWYgKGNvbXB1dGVkIHx8IG9wdGlvbmFsIHx8IHRoaXMuZWF0KDE2KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU1lbWJlcihiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIHN0YXRlLCBjb21wdXRlZCwgb3B0aW9uYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBhcnNlTWVtYmVyKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgc3RhdGUsIGNvbXB1dGVkLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgIG5vZGUuY29tcHV0ZWQgPSBjb21wdXRlZDtcblxuICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgaWYgKGJhc2UudHlwZSA9PT0gXCJTdXBlclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlN1cGVyUHJpdmF0ZUZpZWxkLCB7XG4gICAgICAgICAgYXQ6IHN0YXJ0TG9jXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUodGhpcy5zdGF0ZS52YWx1ZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcikge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VCaW5kKGJhc2UsIHN0YXJ0UG9zLCBzdGFydExvYywgbm9DYWxscywgc3RhdGUpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VOb0NhbGxFeHByKCk7XG4gICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJpbmRFeHByZXNzaW9uXCIpLCBzdGFydFBvcywgc3RhcnRMb2MsIG5vQ2FsbHMpO1xuICB9XG5cbiAgcGFyc2VDb3ZlckNhbGxBbmRBc3luY0Fycm93SGVhZChiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIHN0YXRlLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgbGV0IHJlZkV4cHJlc3Npb25FcnJvcnMgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRydWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLmNhbGxlZSA9IGJhc2U7XG4gICAgY29uc3Qge1xuICAgICAgbWF5YmVBc3luY0Fycm93LFxuICAgICAgb3B0aW9uYWxDaGFpbk1lbWJlclxuICAgIH0gPSBzdGF0ZTtcblxuICAgIGlmIChtYXliZUFzeW5jQXJyb3cpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmVudGVyKG5ld0FzeW5jQXJyb3dTY29wZSgpKTtcbiAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMgPSBuZXcgRXhwcmVzc2lvbkVycm9ycygpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cygxMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKDExLCBiYXNlLnR5cGUgPT09IFwiSW1wb3J0XCIsIGJhc2UudHlwZSAhPT0gXCJTdXBlclwiLCBub2RlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICB9XG5cbiAgICBsZXQgZmluaXNoZWROb2RlID0gdGhpcy5maW5pc2hDYWxsRXhwcmVzc2lvbihub2RlLCBvcHRpb25hbENoYWluTWVtYmVyKTtcblxuICAgIGlmIChtYXliZUFzeW5jQXJyb3cgJiYgdGhpcy5zaG91bGRQYXJzZUFzeW5jQXJyb3coKSAmJiAhb3B0aW9uYWwpIHtcbiAgICAgIHN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgdGhpcy5jaGVja0Rlc3RydWN0dXJpbmdQcml2YXRlKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUudmFsaWRhdGVBc1BhdHRlcm4oKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcbiAgICAgIGZpbmlzaGVkTm9kZSA9IHRoaXMucGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZmluaXNoZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdykge1xuICAgICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRvUmVmZXJlbmNlZEFyZ3VtZW50cyhmaW5pc2hlZE5vZGUpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgcmV0dXJuIGZpbmlzaGVkTm9kZTtcbiAgfVxuXG4gIHRvUmVmZXJlbmNlZEFyZ3VtZW50cyhub2RlLCBpc1BhcmVudGhlc2l6ZWRFeHByKSB7XG4gICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0RGVlcChub2RlLmFyZ3VtZW50cywgaXNQYXJlbnRoZXNpemVkRXhwcik7XG4gIH1cblxuICBwYXJzZVRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihiYXNlLCBzdGFydFBvcywgc3RhcnRMb2MsIHN0YXRlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBub2RlLnRhZyA9IGJhc2U7XG4gICAgbm9kZS5xdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZSh0cnVlKTtcblxuICAgIGlmIChzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5PcHRpb25hbENoYWluaW5nTm9UZW1wbGF0ZSwge1xuICAgICAgICBhdDogc3RhcnRMb2NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIik7XG4gIH1cblxuICBhdFBvc3NpYmxlQXN5bmNBcnJvdyhiYXNlKSB7XG4gICAgcmV0dXJuIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLmluZGV4ID09PSBiYXNlLmVuZCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiBiYXNlLmVuZCAtIGJhc2Uuc3RhcnQgPT09IDUgJiYgYmFzZS5zdGFydCA9PT0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0O1xuICB9XG5cbiAgZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAobm9kZS5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRcIikge1xuICAgICAgaWYgKG5vZGUuYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCF0aGlzLmhhc1BsdWdpbihcIm1vZHVsZUF0dHJpYnV0ZXNcIikpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBub2RlLmFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxBcml0eSwge1xuICAgICAgICAgIGF0OiBub2RlLFxuICAgICAgICAgIG1heEFyZ3VtZW50Q291bnQ6IHRoaXMuaGFzUGx1Z2luKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSB8fCB0aGlzLmhhc1BsdWdpbihcIm1vZHVsZUF0dHJpYnV0ZXNcIikgPyAyIDogMVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgYXJnIG9mIG5vZGUuYXJndW1lbnRzKSB7XG4gICAgICAgICAgaWYgKGFyZy50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0Q2FsbFNwcmVhZEFyZ3VtZW50LCB7XG4gICAgICAgICAgICAgIGF0OiBhcmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgb3B0aW9uYWwgPyBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiA6IFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gIH1cblxuICBwYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKGNsb3NlLCBkeW5hbWljSW1wb3J0LCBhbGxvd1BsYWNlaG9sZGVyLCBub2RlRm9yRXh0cmEsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBlbHRzID0gW107XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuXG4gICAgICAgIGlmICh0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgICAgIGlmIChkeW5hbWljSW1wb3J0ICYmICF0aGlzLmhhc1BsdWdpbihcImltcG9ydEFzc2VydGlvbnNcIikgJiYgIXRoaXMuaGFzUGx1Z2luKFwibW9kdWxlQXR0cmlidXRlc1wiKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0Q2FsbEFyZ3VtZW50VHJhaWxpbmdDb21tYSwge1xuICAgICAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChub2RlRm9yRXh0cmEpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVHJhaWxpbmdDb21tYUV4dHJhVG9Ob2RlKG5vZGVGb3JFeHRyYSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWx0cy5wdXNoKHRoaXMucGFyc2VFeHByTGlzdEl0ZW0oZmFsc2UsIHJlZkV4cHJlc3Npb25FcnJvcnMsIGFsbG93UGxhY2Vob2xkZXIpKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgcmV0dXJuIGVsdHM7XG4gIH1cblxuICBzaG91bGRQYXJzZUFzeW5jQXJyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTkpICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpO1xuICB9XG5cbiAgcGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKG5vZGUsIGNhbGwpIHtcbiAgICB2YXIgX2NhbGwkZXh0cmE7XG5cbiAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhjYWxsKTtcbiAgICB0aGlzLmV4cGVjdCgxOSk7XG4gICAgdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBjYWxsLmFyZ3VtZW50cywgdHJ1ZSwgKF9jYWxsJGV4dHJhID0gY2FsbC5leHRyYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWxsJGV4dHJhLnRyYWlsaW5nQ29tbWFMb2MpO1xuXG4gICAgaWYgKGNhbGwuaW5uZXJDb21tZW50cykge1xuICAgICAgc2V0SW5uZXJDb21tZW50cyhub2RlLCBjYWxsLmlubmVyQ29tbWVudHMpO1xuICAgIH1cblxuICAgIGlmIChjYWxsLmNhbGxlZS50cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgICBzZXRJbm5lckNvbW1lbnRzKG5vZGUsIGNhbGwuY2FsbGVlLnRyYWlsaW5nQ29tbWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VOb0NhbGxFeHByKCkge1xuICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMucGFyc2VFeHByQXRvbSgpLCBzdGFydFBvcywgc3RhcnRMb2MsIHRydWUpO1xuICB9XG5cbiAgcGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgbGV0IG5vZGU7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIDc5OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVN1cGVyKCk7XG5cbiAgICAgIGNhc2UgODM6XG4gICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgICBpZiAodGhpcy5tYXRjaCgxNikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydE1ldGFQcm9wZXJ0eShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZEltcG9ydCwge1xuICAgICAgICAgICAgYXQ6IHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0XCIpO1xuXG4gICAgICBjYXNlIDc4OlxuICAgICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKTtcblxuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRG8odGhpcy5zdGFydE5vZGUoKSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgNTY6XG4gICAgICBjYXNlIDMxOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5yZWFkUmVnZXhwKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZWdFeHBMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgMTMwOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU51bWVyaWNMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuXG4gICAgICBjYXNlIDEzMTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCaWdJbnRMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuXG4gICAgICBjYXNlIDEzMjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEZWNpbWFsTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcblxuICAgICAgY2FzZSAxMjk6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcblxuICAgICAgY2FzZSA4NDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VOdWxsTGl0ZXJhbCgpO1xuXG4gICAgICBjYXNlIDg1OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJvb2xlYW5MaXRlcmFsKHRydWUpO1xuXG4gICAgICBjYXNlIDg2OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJvb2xlYW5MaXRlcmFsKGZhbHNlKTtcblxuICAgICAgY2FzZSAxMDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGNhbkJlQXJyb3cgPSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQgPT09IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIDI6XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycmF5TGlrZSh0aGlzLnN0YXRlLnR5cGUgPT09IDIgPyA0IDogMywgZmFsc2UsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgMDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXlMaWtlKDMsIHRydWUsIGZhbHNlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIDY6XG4gICAgICBjYXNlIDc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdExpa2UodGhpcy5zdGF0ZS50eXBlID09PSA2ID8gOSA6IDgsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIDU6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdExpa2UoOCwgZmFsc2UsIGZhbHNlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIDY4OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uT3JGdW5jdGlvblNlbnQoKTtcblxuICAgICAgY2FzZSAyNjpcbiAgICAgICAgdGhpcy5wYXJzZURlY29yYXRvcnMoKTtcblxuICAgICAgY2FzZSA4MDpcbiAgICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMudGFrZURlY29yYXRvcnMobm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgZmFsc2UpO1xuXG4gICAgICBjYXNlIDc3OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU5ld09yTmV3VGFyZ2V0KCk7XG5cbiAgICAgIGNhc2UgMjU6XG4gICAgICBjYXNlIDI0OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKGZhbHNlKTtcblxuICAgICAgY2FzZSAxNTpcbiAgICAgICAge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIG5vZGUub2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICBjb25zdCBjYWxsZWUgPSBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VOb0NhbGxFeHByKCk7XG5cbiAgICAgICAgICBpZiAoY2FsbGVlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQmluZEV4cHJlc3Npb25cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkQmluZCwge1xuICAgICAgICAgICAgICBhdDogY2FsbGVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAxMzQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Qcml2YXRlSW5FeHBlY3RlZEluLCB7XG4gICAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5zdGFydExvYyxcbiAgICAgICAgICAgIGlkZW50aWZpZXJOYW1lOiB0aGlzLnN0YXRlLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQcml2YXRlTmFtZSgpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgMzM6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRvcGljUmVmZXJlbmNlVGhlbkVxdWFsc1NpZ24oNTQsIFwiJVwiKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIDMyOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUb3BpY1JlZmVyZW5jZVRoZW5FcXVhbHNTaWduKDQ0LCBcIl5cIik7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAzNzpcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRvcGljUmVmZXJlbmNlKFwiaGFja1wiKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIDQ0OlxuICAgICAgY2FzZSA1NDpcbiAgICAgIGNhc2UgMjc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBwaXBlUHJvcG9zYWwgPSB0aGlzLmdldFBsdWdpbk9wdGlvbihcInBpcGVsaW5lT3BlcmF0b3JcIiwgXCJwcm9wb3NhbFwiKTtcblxuICAgICAgICAgIGlmIChwaXBlUHJvcG9zYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVG9waWNSZWZlcmVuY2UocGlwZVByb3Bvc2FsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgNDc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsb29rYWhlYWRDaCA9IHRoaXMuaW5wdXQuY29kZVBvaW50QXQodGhpcy5uZXh0VG9rZW5TdGFydCgpKTtcblxuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChsb29rYWhlYWRDaCkgfHwgbG9va2FoZWFkQ2ggPT09IDYyKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdE9uZVBsdWdpbihbXCJqc3hcIiwgXCJmbG93XCIsIFwidHlwZXNjcmlwdFwiXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0eXBlKSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjMpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gMTIzICYmICF0aGlzLmhhc0ZvbGxvd2luZ0xpbmVCcmVhaygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU1vZHVsZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjYW5CZUFycm93ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgICAgIGNvbnN0IGNvbnRhaW5zRXNjID0gdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgICAgICAgICBjb25zdCBpZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG5cbiAgICAgICAgICBpZiAoIWNvbnRhaW5zRXNjICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICB9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IDY4KSB7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGlkKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdE5vZGUoaWQpLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbklzSWRlbnRpZmllcih0eXBlKSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA2MSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXN5bmNBcnJvd1VuYXJ5RnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdE5vZGUoaWQpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gOTApIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXNldFByZXZpb3VzTm9kZVRyYWlsaW5nQ29tbWVudHMoaWQpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZURvKHRoaXMuc3RhcnROb2RlQXROb2RlKGlkKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNhbkJlQXJyb3cgJiYgdGhpcy5tYXRjaCgxOSkgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdE5vZGUoaWQpLCBbaWRdLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBwYXJzZVRvcGljUmVmZXJlbmNlVGhlbkVxdWFsc1NpZ24odG9waWNUb2tlblR5cGUsIHRvcGljVG9rZW5WYWx1ZSkge1xuICAgIGNvbnN0IHBpcGVQcm9wb3NhbCA9IHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpO1xuXG4gICAgaWYgKHBpcGVQcm9wb3NhbCkge1xuICAgICAgdGhpcy5zdGF0ZS50eXBlID0gdG9waWNUb2tlblR5cGU7XG4gICAgICB0aGlzLnN0YXRlLnZhbHVlID0gdG9waWNUb2tlblZhbHVlO1xuICAgICAgdGhpcy5zdGF0ZS5wb3MtLTtcbiAgICAgIHRoaXMuc3RhdGUuZW5kLS07XG4gICAgICB0aGlzLnN0YXRlLmVuZExvYyA9IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldCh0aGlzLnN0YXRlLmVuZExvYywgLTEpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUb3BpY1JlZmVyZW5jZShwaXBlUHJvcG9zYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZVRvcGljUmVmZXJlbmNlKHBpcGVQcm9wb3NhbCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCB0b2tlblR5cGUgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9waWNSZWZlcmVuY2Uobm9kZSwgc3RhcnRMb2MsIHBpcGVQcm9wb3NhbCwgdG9rZW5UeXBlKTtcbiAgfVxuXG4gIGZpbmlzaFRvcGljUmVmZXJlbmNlKG5vZGUsIHN0YXJ0TG9jLCBwaXBlUHJvcG9zYWwsIHRva2VuVHlwZSkge1xuICAgIGlmICh0aGlzLnRlc3RUb3BpY1JlZmVyZW5jZUNvbmZpZ3VyYXRpb24ocGlwZVByb3Bvc2FsLCBzdGFydExvYywgdG9rZW5UeXBlKSkge1xuICAgICAgY29uc3Qgbm9kZVR5cGUgPSBwaXBlUHJvcG9zYWwgPT09IFwic21hcnRcIiA/IFwiUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2VcIiA6IFwiVG9waWNSZWZlcmVuY2VcIjtcblxuICAgICAgaWYgKCF0aGlzLnRvcGljUmVmZXJlbmNlSXNBbGxvd2VkSW5DdXJyZW50Q29udGV4dCgpKSB7XG4gICAgICAgIHRoaXMucmFpc2UocGlwZVByb3Bvc2FsID09PSBcInNtYXJ0XCIgPyBFcnJvcnMuUHJpbWFyeVRvcGljTm90QWxsb3dlZCA6IEVycm9ycy5QaXBlVG9waWNVbmJvdW5kLCB7XG4gICAgICAgICAgYXQ6IHN0YXJ0TG9jXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlZ2lzdGVyVG9waWNSZWZlcmVuY2UoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbm9kZVR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QaXBlVG9waWNVbmNvbmZpZ3VyZWRUb2tlbiwge1xuICAgICAgICBhdDogc3RhcnRMb2MsXG4gICAgICAgIHRva2VuOiB0b2tlbkxhYmVsTmFtZSh0b2tlblR5cGUpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB0ZXN0VG9waWNSZWZlcmVuY2VDb25maWd1cmF0aW9uKHBpcGVQcm9wb3NhbCwgc3RhcnRMb2MsIHRva2VuVHlwZSkge1xuICAgIHN3aXRjaCAocGlwZVByb3Bvc2FsKSB7XG4gICAgICBjYXNlIFwiaGFja1wiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzUGx1Z2luKFtcInBpcGVsaW5lT3BlcmF0b3JcIiwge1xuICAgICAgICAgICAgdG9waWNUb2tlbjogdG9rZW5MYWJlbE5hbWUodG9rZW5UeXBlKVxuICAgICAgICAgIH1dKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwic21hcnRcIjpcbiAgICAgICAgcmV0dXJuIHRva2VuVHlwZSA9PT0gMjc7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlBpcGVUb3BpY1JlcXVpcmVzSGFja1BpcGVzLCB7XG4gICAgICAgICAgYXQ6IHN0YXJ0TG9jXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlQXN5bmNBcnJvd1VuYXJ5RnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKGZ1bmN0aW9uRmxhZ3ModHJ1ZSwgdGhpcy5wcm9kUGFyYW0uaGFzWWllbGQpKTtcbiAgICBjb25zdCBwYXJhbXMgPSBbdGhpcy5wYXJzZUlkZW50aWZpZXIoKV07XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuXG4gICAgaWYgKHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkxpbmVUZXJtaW5hdG9yQmVmb3JlQXJyb3csIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5leHBlY3QoMTkpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIHBhcmFtcywgdHJ1ZSk7XG4gIH1cblxuICBwYXJzZURvKG5vZGUsIGlzQXN5bmMpIHtcbiAgICB0aGlzLmV4cGVjdFBsdWdpbihcImRvRXhwcmVzc2lvbnNcIik7XG5cbiAgICBpZiAoaXNBc3luYykge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJhc3luY0RvRXhwcmVzc2lvbnNcIik7XG4gICAgfVxuXG4gICAgbm9kZS5hc3luYyA9IGlzQXN5bmM7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3Qgb2xkTGFiZWxzID0gdGhpcy5zdGF0ZS5sYWJlbHM7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBbXTtcblxuICAgIGlmIChpc0FzeW5jKSB7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihQQVJBTV9BV0FJVCk7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRvRXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIHBhcnNlU3VwZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodGhpcy5tYXRjaCgxMCkgJiYgIXRoaXMuc2NvcGUuYWxsb3dEaXJlY3RTdXBlciAmJiAhdGhpcy5vcHRpb25zLmFsbG93U3VwZXJPdXRzaWRlTWV0aG9kKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5TdXBlck5vdEFsbG93ZWQsIHtcbiAgICAgICAgYXQ6IG5vZGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc2NvcGUuYWxsb3dTdXBlciAmJiAhdGhpcy5vcHRpb25zLmFsbG93U3VwZXJPdXRzaWRlTWV0aG9kKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkU3VwZXIsIHtcbiAgICAgICAgYXQ6IG5vZGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5tYXRjaCgxMCkgJiYgIXRoaXMubWF0Y2goMCkgJiYgIXRoaXMubWF0Y2goMTYpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZFN1cGVyLCB7XG4gICAgICAgIGF0OiBub2RlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIik7XG4gIH1cblxuICBwYXJzZVByaXZhdGVOYW1lKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5zdGFydE5vZGVBdCh0aGlzLnN0YXRlLnN0YXJ0ICsgMSwgbmV3IFBvc2l0aW9uKHRoaXMuc3RhdGUuY3VyTGluZSwgdGhpcy5zdGF0ZS5zdGFydCArIDEgLSB0aGlzLnN0YXRlLmxpbmVTdGFydCwgdGhpcy5zdGF0ZS5zdGFydCArIDEpKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmlkID0gdGhpcy5jcmVhdGVJZGVudGlmaWVyKGlkLCBuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJpdmF0ZU5hbWVcIik7XG4gIH1cblxuICBwYXJzZUZ1bmN0aW9uT3JGdW5jdGlvblNlbnQoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodGhpcy5wcm9kUGFyYW0uaGFzWWllbGQgJiYgdGhpcy5tYXRjaCgxNikpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5zdGFydE5vZGVBdE5vZGUobm9kZSksIFwiZnVuY3Rpb25cIik7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgaWYgKHRoaXMubWF0Y2goMTAyKSkge1xuICAgICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImZ1bmN0aW9uU2VudFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaGFzUGx1Z2luKFwiZnVuY3Rpb25TZW50XCIpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU1ldGFQcm9wZXJ0eShub2RlLCBtZXRhLCBcInNlbnRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlKTtcbiAgfVxuXG4gIHBhcnNlTWV0YVByb3BlcnR5KG5vZGUsIG1ldGEsIHByb3BlcnR5TmFtZSkge1xuICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgY29uc3QgY29udGFpbnNFc2MgPSB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcblxuICAgIGlmIChub2RlLnByb3BlcnR5Lm5hbWUgIT09IHByb3BlcnR5TmFtZSB8fCBjb250YWluc0VzYykge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWRNZXRhUHJvcGVydHksIHtcbiAgICAgICAgYXQ6IG5vZGUucHJvcGVydHksXG4gICAgICAgIHRhcmdldDogbWV0YS5uYW1lLFxuICAgICAgICBvbmx5VmFsaWRQcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKTtcbiAgfVxuXG4gIHBhcnNlSW1wb3J0TWV0YVByb3BlcnR5KG5vZGUpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcih0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShub2RlKSwgXCJpbXBvcnRcIik7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTAwKSkge1xuICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydE1ldGFPdXRzaWRlTW9kdWxlLCB7XG4gICAgICAgICAgYXQ6IGlkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNhd1VuYW1iaWd1b3VzRVNNID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJzZU1ldGFQcm9wZXJ0eShub2RlLCBpZCwgXCJtZXRhXCIpO1xuICB9XG5cbiAgcGFyc2VMaXRlcmFsQXROb2RlKHZhbHVlLCB0eXBlLCBub2RlKSB7XG4gICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInJhd1ZhbHVlXCIsIHZhbHVlKTtcbiAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwicmF3XCIsIHRoaXMuaW5wdXQuc2xpY2Uobm9kZS5zdGFydCwgdGhpcy5zdGF0ZS5lbmQpKTtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuXG4gIHBhcnNlTGl0ZXJhbCh2YWx1ZSwgdHlwZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbEF0Tm9kZSh2YWx1ZSwgdHlwZSwgbm9kZSk7XG4gIH1cblxuICBwYXJzZVN0cmluZ0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiU3RyaW5nTGl0ZXJhbFwiKTtcbiAgfVxuXG4gIHBhcnNlTnVtZXJpY0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiTnVtZXJpY0xpdGVyYWxcIik7XG4gIH1cblxuICBwYXJzZUJpZ0ludExpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiQmlnSW50TGl0ZXJhbFwiKTtcbiAgfVxuXG4gIHBhcnNlRGVjaW1hbExpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiRGVjaW1hbExpdGVyYWxcIik7XG4gIH1cblxuICBwYXJzZVJlZ0V4cExpdGVyYWwodmFsdWUpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUsIFwiUmVnRXhwTGl0ZXJhbFwiKTtcbiAgICBub2RlLnBhdHRlcm4gPSB2YWx1ZS5wYXR0ZXJuO1xuICAgIG5vZGUuZmxhZ3MgPSB2YWx1ZS5mbGFncztcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlQm9vbGVhbkxpdGVyYWwodmFsdWUpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJvb2xlYW5MaXRlcmFsXCIpO1xuICB9XG5cbiAgcGFyc2VOdWxsTGl0ZXJhbCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTnVsbExpdGVyYWxcIik7XG4gIH1cblxuICBwYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uKGNhbkJlQXJyb3cpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCB2YWw7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3QXJyb3dIZWFkU2NvcGUoKSk7XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gZmFsc2U7XG4gICAgY29uc3QgaW5uZXJTdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3QgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgZXhwckxpc3QgPSBbXTtcbiAgICBjb25zdCByZWZFeHByZXNzaW9uRXJyb3JzID0gbmV3IEV4cHJlc3Npb25FcnJvcnMoKTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGxldCBzcHJlYWRTdGFydExvYztcbiAgICBsZXQgb3B0aW9uYWxDb21tYVN0YXJ0TG9jO1xuXG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMiwgcmVmRXhwcmVzc2lvbkVycm9ycy5vcHRpb25hbFBhcmFtZXRlcnNMb2MgPT09IG51bGwgPyBudWxsIDogcmVmRXhwcmVzc2lvbkVycm9ycy5vcHRpb25hbFBhcmFtZXRlcnNMb2MpO1xuXG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICAgIG9wdGlvbmFsQ29tbWFTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgIGNvbnN0IHNwcmVhZE5vZGVTdGFydFBvcyA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICAgIGNvbnN0IHNwcmVhZE5vZGVTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgIHNwcmVhZFN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpLCBzcHJlYWROb2RlU3RhcnRQb3MsIHNwcmVhZE5vZGVTdGFydExvYykpO1xuXG4gICAgICAgIGlmICghdGhpcy5jaGVja0NvbW1hQWZ0ZXJSZXN0KDQxKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4ocmVmRXhwcmVzc2lvbkVycm9ycywgdGhpcy5wYXJzZVBhcmVuSXRlbSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlubmVyRW5kTG9jID0gdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jO1xuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICBsZXQgYXJyb3dOb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuXG4gICAgaWYgKGNhbkJlQXJyb3cgJiYgdGhpcy5zaG91bGRQYXJzZUFycm93KGV4cHJMaXN0KSAmJiAoYXJyb3dOb2RlID0gdGhpcy5wYXJzZUFycm93KGFycm93Tm9kZSkpKSB7XG4gICAgICB0aGlzLmNoZWNrRGVzdHJ1Y3R1cmluZ1ByaXZhdGUocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS52YWxpZGF0ZUFzUGF0dGVybigpO1xuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICAgICAgdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihhcnJvd05vZGUsIGV4cHJMaXN0LCBmYWxzZSk7XG4gICAgICByZXR1cm4gYXJyb3dOb2RlO1xuICAgIH1cblxuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcblxuICAgIGlmICghZXhwckxpc3QubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25hbENvbW1hU3RhcnRMb2MpIHRoaXMudW5leHBlY3RlZChvcHRpb25hbENvbW1hU3RhcnRMb2MpO1xuICAgIGlmIChzcHJlYWRTdGFydExvYykgdGhpcy51bmV4cGVjdGVkKHNwcmVhZFN0YXJ0TG9jKTtcbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3REZWVwKGV4cHJMaXN0LCB0cnVlKTtcblxuICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKTtcbiAgICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbih2YWwsIGlubmVyRW5kTG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMud3JhcFBhcmVudGhlc2lzKHN0YXJ0UG9zLCBzdGFydExvYywgdmFsKTtcbiAgfVxuXG4gIHdyYXBQYXJlbnRoZXNpcyhzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5jcmVhdGVQYXJlbnRoZXNpemVkRXhwcmVzc2lvbnMpIHtcbiAgICAgIHRoaXMuYWRkRXh0cmEoZXhwcmVzc2lvbiwgXCJwYXJlbnRoZXNpemVkXCIsIHRydWUpO1xuICAgICAgdGhpcy5hZGRFeHRyYShleHByZXNzaW9uLCBcInBhcmVuU3RhcnRcIiwgc3RhcnRQb3MpO1xuICAgICAgdGhpcy50YWtlU3Vycm91bmRpbmdDb21tZW50cyhleHByZXNzaW9uLCBzdGFydFBvcywgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLmluZGV4KTtcbiAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVuRXhwcmVzc2lvbiA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBwYXJlbkV4cHJlc3Npb24uZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwYXJlbkV4cHJlc3Npb24sIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIik7XG4gIH1cblxuICBzaG91bGRQYXJzZUFycm93KHBhcmFtcykge1xuICAgIHJldHVybiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKTtcbiAgfVxuXG4gIHBhcnNlQXJyb3cobm9kZSkge1xuICAgIGlmICh0aGlzLmVhdCgxOSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlUGFyZW5JdGVtKG5vZGUsIHN0YXJ0UG9zLCBzdGFydExvYykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VOZXdPck5ld1RhcmdldCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmICh0aGlzLm1hdGNoKDE2KSkge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcih0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShub2RlKSwgXCJuZXdcIik7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IG1ldGFQcm9wID0gdGhpcy5wYXJzZU1ldGFQcm9wZXJ0eShub2RlLCBtZXRhLCBcInRhcmdldFwiKTtcblxuICAgICAgaWYgKCF0aGlzLnNjb3BlLmluTm9uQXJyb3dGdW5jdGlvbiAmJiAhdGhpcy5zY29wZS5pbkNsYXNzKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWROZXdUYXJnZXQsIHtcbiAgICAgICAgICBhdDogbWV0YVByb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXRhUHJvcDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJzZU5ldyhub2RlKTtcbiAgfVxuXG4gIHBhcnNlTmV3KG5vZGUpIHtcbiAgICB0aGlzLnBhcnNlTmV3Q2FsbGVlKG5vZGUpO1xuXG4gICAgaWYgKHRoaXMuZWF0KDEwKSkge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMucGFyc2VFeHByTGlzdCgxMSk7XG4gICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3QoYXJncyk7XG4gICAgICBub2RlLmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIik7XG4gIH1cblxuICBwYXJzZU5ld0NhbGxlZShub2RlKSB7XG4gICAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlTm9DYWxsRXhwcigpO1xuXG4gICAgaWYgKG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0XCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxOb3ROZXdFeHByZXNzaW9uLCB7XG4gICAgICAgIGF0OiBub2RlLmNhbGxlZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzT3B0aW9uYWxDaGFpbihub2RlLmNhbGxlZSkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk9wdGlvbmFsQ2hhaW5pbmdOb05ldywge1xuICAgICAgICBhdDogdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KDE4KSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuT3B0aW9uYWxDaGFpbmluZ05vTmV3LCB7XG4gICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0LFxuICAgICAgc3RhcnRMb2MsXG4gICAgICBlbmQsXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGVsZW1TdGFydCA9IHN0YXJ0ICsgMTtcbiAgICBjb25zdCBlbGVtID0gdGhpcy5zdGFydE5vZGVBdChlbGVtU3RhcnQsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgMSkpO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICBpZiAoIWlzVGFnZ2VkKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRFc2NhcGVTZXF1ZW5jZVRlbXBsYXRlLCB7XG4gICAgICAgICAgYXQ6IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgMilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaXNUYWlsID0gdGhpcy5tYXRjaCgyNCk7XG4gICAgY29uc3QgZW5kT2Zmc2V0ID0gaXNUYWlsID8gLTEgOiAtMjtcbiAgICBjb25zdCBlbGVtRW5kID0gZW5kICsgZW5kT2Zmc2V0O1xuICAgIGVsZW0udmFsdWUgPSB7XG4gICAgICByYXc6IHRoaXMuaW5wdXQuc2xpY2UoZWxlbVN0YXJ0LCBlbGVtRW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgY29va2VkOiB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiB2YWx1ZS5zbGljZSgxLCBlbmRPZmZzZXQpXG4gICAgfTtcbiAgICBlbGVtLnRhaWwgPSBpc1RhaWw7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3QgZmluaXNoZWROb2RlID0gdGhpcy5maW5pc2hOb2RlKGVsZW0sIFwiVGVtcGxhdGVFbGVtZW50XCIpO1xuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihmaW5pc2hlZE5vZGUsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldCh0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MsIGVuZE9mZnNldCkpO1xuICAgIHJldHVybiBmaW5pc2hlZE5vZGU7XG4gIH1cblxuICBwYXJzZVRlbXBsYXRlKGlzVGFnZ2VkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtdO1xuICAgIGxldCBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KGlzVGFnZ2VkKTtcbiAgICBub2RlLnF1YXNpcyA9IFtjdXJFbHRdO1xuXG4gICAgd2hpbGUgKCFjdXJFbHQudGFpbCkge1xuICAgICAgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VUZW1wbGF0ZVN1YnN0aXR1dGlvbigpKTtcbiAgICAgIHRoaXMucmVhZFRlbXBsYXRlQ29udGludWF0aW9uKCk7XG4gICAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoaXNUYWdnZWQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpO1xuICB9XG5cbiAgcGFyc2VUZW1wbGF0ZVN1YnN0aXR1dGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0TGlrZShjbG9zZSwgaXNQYXR0ZXJuLCBpc1JlY29yZCwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmIChpc1JlY29yZCkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IGZhbHNlO1xuICAgIGNvbnN0IHByb3BIYXNoID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2goY2xvc2UpKSB7XG4gICAgICAgICAgdGhpcy5hZGRUcmFpbGluZ0NvbW1hRXh0cmFUb05vZGUobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV0IHByb3A7XG5cbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcCA9IHRoaXMucGFyc2VCaW5kaW5nUHJvcGVydHkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AgPSB0aGlzLnBhcnNlUHJvcGVydHlEZWZpbml0aW9uKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICB0aGlzLmNoZWNrUHJvdG8ocHJvcCwgaXNSZWNvcmQsIHByb3BIYXNoLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUmVjb3JkICYmICF0aGlzLmlzT2JqZWN0UHJvcGVydHkocHJvcCkgJiYgcHJvcC50eXBlICE9PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUmVjb3JkUHJvcGVydHksIHtcbiAgICAgICAgICBhdDogcHJvcFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3Auc2hvcnRoYW5kKSB7XG4gICAgICAgIHRoaXMuYWRkRXh0cmEocHJvcCwgXCJzaG9ydGhhbmRcIiwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgIH1cblxuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICBsZXQgdHlwZSA9IFwiT2JqZWN0RXhwcmVzc2lvblwiO1xuXG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgdHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgIH0gZWxzZSBpZiAoaXNSZWNvcmQpIHtcbiAgICAgIHR5cGUgPSBcIlJlY29yZEV4cHJlc3Npb25cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpO1xuICB9XG5cbiAgYWRkVHJhaWxpbmdDb21tYUV4dHJhVG9Ob2RlKG5vZGUpIHtcbiAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwidHJhaWxpbmdDb21tYVwiLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydCk7XG4gICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInRyYWlsaW5nQ29tbWFMb2NcIiwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MsIGZhbHNlKTtcbiAgfVxuXG4gIG1heWJlQXN5bmNPckFjY2Vzc29yUHJvcChwcm9wKSB7XG4gICAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICh0aGlzLmlzTGl0ZXJhbFByb3BlcnR5TmFtZSgpIHx8IHRoaXMubWF0Y2goMCkgfHwgdGhpcy5tYXRjaCg1NSkpO1xuICB9XG5cbiAgcGFyc2VQcm9wZXJ0eURlZmluaXRpb24ocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGxldCBkZWNvcmF0b3JzID0gW107XG5cbiAgICBpZiAodGhpcy5tYXRjaCgyNikpIHtcbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWRQcm9wZXJ0eURlY29yYXRvciwge1xuICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodGhpcy5tYXRjaCgyNikpIHtcbiAgICAgICAgZGVjb3JhdG9ycy5wdXNoKHRoaXMucGFyc2VEZWNvcmF0b3IoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbGV0IGlzQXN5bmMgPSBmYWxzZTtcbiAgICBsZXQgaXNBY2Nlc3NvciA9IGZhbHNlO1xuICAgIGxldCBzdGFydFBvcztcbiAgICBsZXQgc3RhcnRMb2M7XG5cbiAgICBpZiAodGhpcy5tYXRjaCgyMSkpIHtcbiAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVNwcmVhZCgpO1xuICAgIH1cblxuICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgcHJvcC5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICAgIGRlY29yYXRvcnMgPSBbXTtcbiAgICB9XG5cbiAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuXG4gICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB9XG5cbiAgICBsZXQgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCg1NSk7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZVByZWZpeE9wZXJhdG9yKHByb3ApO1xuICAgIGNvbnN0IGNvbnRhaW5zRXNjID0gdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgICBjb25zdCBrZXkgPSB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3AsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuXG4gICAgaWYgKCFpc0dlbmVyYXRvciAmJiAhY29udGFpbnNFc2MgJiYgdGhpcy5tYXliZUFzeW5jT3JBY2Nlc3NvclByb3AocHJvcCkpIHtcbiAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkubmFtZTtcblxuICAgICAgaWYgKGtleU5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNldFByZXZpb3VzTm9kZVRyYWlsaW5nQ29tbWVudHMoa2V5KTtcbiAgICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCg1NSk7XG4gICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlOYW1lID09PSBcImdldFwiIHx8IGtleU5hbWUgPT09IFwic2V0XCIpIHtcbiAgICAgICAgaXNBY2Nlc3NvciA9IHRydWU7XG4gICAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGtleSk7XG4gICAgICAgIHByb3Aua2luZCA9IGtleU5hbWU7XG5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2goNTUpKSB7XG4gICAgICAgICAgaXNHZW5lcmF0b3IgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkFjY2Vzc29ySXNHZW5lcmF0b3IsIHtcbiAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCksXG4gICAgICAgICAgICBraW5kOiBrZXlOYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0UG9zLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGZhbHNlLCBpc0FjY2Vzc29yLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxuXG4gIGdldEdldHRlclNldHRlckV4cGVjdGVkUGFyYW1Db3VudChtZXRob2QpIHtcbiAgICByZXR1cm4gbWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgfVxuXG4gIGdldE9iamVjdE9yQ2xhc3NNZXRob2RQYXJhbXMobWV0aG9kKSB7XG4gICAgcmV0dXJuIG1ldGhvZC5wYXJhbXM7XG4gIH1cblxuICBjaGVja0dldHRlclNldHRlclBhcmFtcyhtZXRob2QpIHtcbiAgICB2YXIgX3BhcmFtcztcblxuICAgIGNvbnN0IHBhcmFtQ291bnQgPSB0aGlzLmdldEdldHRlclNldHRlckV4cGVjdGVkUGFyYW1Db3VudChtZXRob2QpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuZ2V0T2JqZWN0T3JDbGFzc01ldGhvZFBhcmFtcyhtZXRob2QpO1xuXG4gICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgIHRoaXMucmFpc2UobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgPyBFcnJvcnMuQmFkR2V0dGVyQXJpdHkgOiBFcnJvcnMuQmFkU2V0dGVyQXJpdHksIHtcbiAgICAgICAgYXQ6IG1ldGhvZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmICgoX3BhcmFtcyA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfcGFyYW1zLnR5cGUpID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkJhZFNldHRlclJlc3RQYXJhbWV0ZXIsIHtcbiAgICAgICAgYXQ6IG1ldGhvZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VPYmplY3RNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3Nvcikge1xuICAgIGlmIChpc0FjY2Vzc29yKSB7XG4gICAgICBjb25zdCBmaW5pc2hlZFByb3AgPSB0aGlzLnBhcnNlTWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBcIk9iamVjdE1ldGhvZFwiKTtcbiAgICAgIHRoaXMuY2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMoZmluaXNoZWRQcm9wKTtcbiAgICAgIHJldHVybiBmaW5pc2hlZFByb3A7XG4gICAgfVxuXG4gICAgaWYgKGlzQXN5bmMgfHwgaXNHZW5lcmF0b3IgfHwgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgcHJvcC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBmYWxzZSwgZmFsc2UsIFwiT2JqZWN0TWV0aG9kXCIpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlT2JqZWN0UHJvcGVydHkocHJvcCwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBpc1BhdHRlcm4sIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBwcm9wLnNob3J0aGFuZCA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuZWF0KDE0KSkge1xuICAgICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGF0ZS5zdGFydCwgdGhpcy5zdGF0ZS5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIk9iamVjdFByb3BlcnR5XCIpO1xuICAgIH1cblxuICAgIGlmICghcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChwcm9wLmtleS5uYW1lLCBwcm9wLmtleS5sb2Muc3RhcnQsIHRydWUsIGZhbHNlKTtcblxuICAgICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIGNsb25lSWRlbnRpZmllcihwcm9wLmtleSkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDI5KSkge1xuICAgICAgICBjb25zdCBzaG9ydGhhbmRBc3NpZ25Mb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuXG4gICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycy5zaG9ydGhhbmRBc3NpZ25Mb2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMuc2hvcnRoYW5kQXNzaWduTG9jID0gc2hvcnRoYW5kQXNzaWduTG9jO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkQ292ZXJJbml0aWFsaXplZE5hbWUsIHtcbiAgICAgICAgICAgIGF0OiBzaG9ydGhhbmRBc3NpZ25Mb2NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgY2xvbmVJZGVudGlmaWVyKHByb3Aua2V5KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLnZhbHVlID0gY2xvbmVJZGVudGlmaWVyKHByb3Aua2V5KTtcbiAgICAgIH1cblxuICAgICAgcHJvcC5zaG9ydGhhbmQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIk9iamVjdFByb3BlcnR5XCIpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0UG9zLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlT2JqZWN0TWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IpIHx8IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eShwcm9wLCBzdGFydFBvcywgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKCFub2RlKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlUHJvcGVydHlOYW1lKHByb3AsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAodGhpcy5lYXQoMCkpIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBsZXQga2V5O1xuXG4gICAgICBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodHlwZSkpIHtcbiAgICAgICAga2V5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIDEzMDpcbiAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VOdW1lcmljTGl0ZXJhbCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI5OlxuICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEzMTpcbiAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VCaWdJbnRMaXRlcmFsKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMzI6XG4gICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlRGVjaW1hbExpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDEzNDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleUxvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG5cbiAgICAgICAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnByaXZhdGVLZXlMb2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMucHJpdmF0ZUtleUxvYyA9IHByaXZhdGVLZXlMb2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRQcml2YXRlRmllbGQsIHtcbiAgICAgICAgICAgICAgICAgIGF0OiBwcml2YXRlS2V5TG9jXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvcC5rZXkgPSBrZXk7XG5cbiAgICAgIGlmICh0eXBlICE9PSAxMzQpIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wLmtleTtcbiAgfVxuXG4gIGluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKSB7XG4gICAgbm9kZS5pZCA9IG51bGw7XG4gICAgbm9kZS5nZW5lcmF0b3IgPSBmYWxzZTtcbiAgICBub2RlLmFzeW5jID0gISFpc0FzeW5jO1xuICB9XG5cbiAgcGFyc2VNZXRob2Qobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93RGlyZWN0U3VwZXIsIHR5cGUsIGluQ2xhc3NTY29wZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYyk7XG4gICAgbm9kZS5nZW5lcmF0b3IgPSAhIWlzR2VuZXJhdG9yO1xuICAgIGNvbnN0IGFsbG93TW9kaWZpZXJzID0gaXNDb25zdHJ1Y3RvcjtcbiAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX0ZVTkNUSU9OIHwgU0NPUEVfU1VQRVIgfCAoaW5DbGFzc1Njb3BlID8gU0NPUEVfQ0xBU1MgOiAwKSB8IChhbGxvd0RpcmVjdFN1cGVyID8gU0NPUEVfRElSRUNUX1NVUEVSIDogMCkpO1xuICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgbm9kZS5nZW5lcmF0b3IpKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgYWxsb3dNb2RpZmllcnMpO1xuICAgIGNvbnN0IGZpbmlzaGVkTm9kZSA9IHRoaXMucGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2gobm9kZSwgdHlwZSwgdHJ1ZSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHJldHVybiBmaW5pc2hlZE5vZGU7XG4gIH1cblxuICBwYXJzZUFycmF5TGlrZShjbG9zZSwgY2FuQmVQYXR0ZXJuLCBpc1R1cGxlLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKGlzVHVwbGUpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwicmVjb3JkQW5kVHVwbGVcIik7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBmYWxzZTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KGNsb3NlLCAhaXNUdXBsZSwgcmVmRXhwcmVzc2lvbkVycm9ycywgbm9kZSk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNUdXBsZSA/IFwiVHVwbGVFeHByZXNzaW9uXCIgOiBcIkFycmF5RXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIHBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIHBhcmFtcywgaXNBc3luYywgdHJhaWxpbmdDb21tYUxvYykge1xuICAgIHRoaXMuc2NvcGUuZW50ZXIoU0NPUEVfRlVOQ1RJT04gfCBTQ09QRV9BUlJPVyk7XG4gICAgbGV0IGZsYWdzID0gZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBmYWxzZSk7XG5cbiAgICBpZiAoIXRoaXMubWF0Y2goNSkgJiYgdGhpcy5wcm9kUGFyYW0uaGFzSW4pIHtcbiAgICAgIGZsYWdzIHw9IFBBUkFNX0lOO1xuICAgIH1cblxuICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKGZsYWdzKTtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcbiAgICBjb25zdCBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuXG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0QXJyb3dGdW5jdGlvblBhcmFtZXRlcnMobm9kZSwgcGFyYW1zLCB0cmFpbGluZ0NvbW1hTG9jKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBmYWxzZTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIHRydWUpO1xuICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIHNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcywgdHJhaWxpbmdDb21tYUxvYykge1xuICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRyYWlsaW5nQ29tbWFMb2MsIGZhbHNlKTtcbiAgICBub2RlLnBhcmFtcyA9IHBhcmFtcztcbiAgfVxuXG4gIHBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCBpc01ldGhvZCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuXG4gIHBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbiwgaXNNZXRob2QgPSBmYWxzZSkge1xuICAgIGNvbnN0IGlzRXhwcmVzc2lvbiA9IGFsbG93RXhwcmVzc2lvbiAmJiAhdGhpcy5tYXRjaCg1KTtcbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5lbnRlcihuZXdFeHByZXNzaW9uU2NvcGUoKSk7XG5cbiAgICBpZiAoaXNFeHByZXNzaW9uKSB7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgZmFsc2UsIGFsbG93RXhwcmVzc2lvbiwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICAgIGNvbnN0IG9sZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzO1xuICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBbXTtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKHRoaXMucHJvZFBhcmFtLmN1cnJlbnRGbGFncygpIHwgUEFSQU1fUkVUVVJOKTtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jayh0cnVlLCBmYWxzZSwgaGFzU3RyaWN0TW9kZURpcmVjdGl2ZSA9PiB7XG4gICAgICAgIGNvbnN0IG5vblNpbXBsZSA9ICF0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKTtcblxuICAgICAgICBpZiAoaGFzU3RyaWN0TW9kZURpcmVjdGl2ZSAmJiBub25TaW1wbGUpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlLCB7XG4gICAgICAgICAgICBhdDogKG5vZGUua2luZCA9PT0gXCJtZXRob2RcIiB8fCBub2RlLmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikgJiYgISFub2RlLmtleSA/IG5vZGUua2V5LmxvYy5lbmQgOiBub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdHJpY3RNb2RlQ2hhbmdlZCA9ICFvbGRTdHJpY3QgJiYgdGhpcy5zdGF0ZS5zdHJpY3Q7XG4gICAgICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgIXRoaXMuc3RhdGUuc3RyaWN0ICYmICFhbGxvd0V4cHJlc3Npb24gJiYgIWlzTWV0aG9kICYmICFub25TaW1wbGUsIGFsbG93RXhwcmVzc2lvbiwgc3RyaWN0TW9kZUNoYW5nZWQpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCAmJiBub2RlLmlkKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgQklORF9PVVRTSURFLCBzdHJpY3RNb2RlQ2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgfVxuXG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICB9XG5cbiAgaXNTaW1wbGVQYXJhbWV0ZXIobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiO1xuICB9XG5cbiAgaXNTaW1wbGVQYXJhbUxpc3QocGFyYW1zKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCF0aGlzLmlzU2ltcGxlUGFyYW1ldGVyKHBhcmFtc1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNoZWNrUGFyYW1zKG5vZGUsIGFsbG93RHVwbGljYXRlcywgaXNBcnJvd0Z1bmN0aW9uLCBzdHJpY3RNb2RlQ2hhbmdlZCA9IHRydWUpIHtcbiAgICBjb25zdCBjaGVja0NsYXNoZXMgPSAhYWxsb3dEdXBsaWNhdGVzICYmIG5ldyBTZXQoKTtcbiAgICBjb25zdCBmb3JtYWxQYXJhbWV0ZXJzID0ge1xuICAgICAgdHlwZTogXCJGb3JtYWxQYXJhbWV0ZXJzXCJcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBub2RlLnBhcmFtcykge1xuICAgICAgdGhpcy5jaGVja0xWYWwocGFyYW0sIHtcbiAgICAgICAgaW46IGZvcm1hbFBhcmFtZXRlcnMsXG4gICAgICAgIGJpbmRpbmc6IEJJTkRfVkFSLFxuICAgICAgICBjaGVja0NsYXNoZXMsXG4gICAgICAgIHN0cmljdE1vZGVDaGFuZ2VkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUV4cHJMaXN0KGNsb3NlLCBhbGxvd0VtcHR5LCByZWZFeHByZXNzaW9uRXJyb3JzLCBub2RlRm9yRXh0cmEpIHtcbiAgICBjb25zdCBlbHRzID0gW107XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcblxuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcblxuICAgICAgICBpZiAodGhpcy5tYXRjaChjbG9zZSkpIHtcbiAgICAgICAgICBpZiAobm9kZUZvckV4dHJhKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRyYWlsaW5nQ29tbWFFeHRyYVRvTm9kZShub2RlRm9yRXh0cmEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsdHMucHVzaCh0aGlzLnBhcnNlRXhwckxpc3RJdGVtKGFsbG93RW1wdHksIHJlZkV4cHJlc3Npb25FcnJvcnMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWx0cztcbiAgfVxuXG4gIHBhcnNlRXhwckxpc3RJdGVtKGFsbG93RW1wdHksIHJlZkV4cHJlc3Npb25FcnJvcnMsIGFsbG93UGxhY2Vob2xkZXIpIHtcbiAgICBsZXQgZWx0O1xuXG4gICAgaWYgKHRoaXMubWF0Y2goMTIpKSB7XG4gICAgICBpZiAoIWFsbG93RW1wdHkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFRva2VuLCB7XG4gICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSxcbiAgICAgICAgICB1bmV4cGVjdGVkOiBcIixcIlxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZWx0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICBjb25zdCBzcHJlYWROb2RlU3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgY29uc3Qgc3ByZWFkTm9kZVN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVNwcmVhZChyZWZFeHByZXNzaW9uRXJyb3JzKSwgc3ByZWFkTm9kZVN0YXJ0UG9zLCBzcHJlYWROb2RlU3RhcnRMb2MpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCgxNykpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwicGFydGlhbEFwcGxpY2F0aW9uXCIpO1xuXG4gICAgICBpZiAoIWFsbG93UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZEFyZ3VtZW50UGxhY2Vob2xkZXIsIHtcbiAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5zdGFydExvY1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGVsdCA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFyZ3VtZW50UGxhY2Vob2xkZXJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4ocmVmRXhwcmVzc2lvbkVycm9ycywgdGhpcy5wYXJzZVBhcmVuSXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsdDtcbiAgfVxuXG4gIHBhcnNlSWRlbnRpZmllcihsaWJlcmFsKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZShub2RlLnN0YXJ0LCBsaWJlcmFsKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVJZGVudGlmaWVyKG5vZGUsIG5hbWUpO1xuICB9XG5cbiAgY3JlYXRlSWRlbnRpZmllcihub2RlLCBuYW1lKSB7XG4gICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgICBub2RlLmxvYy5pZGVudGlmaWVyTmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklkZW50aWZpZXJcIik7XG4gIH1cblxuICBwYXJzZUlkZW50aWZpZXJOYW1lKHBvcywgbGliZXJhbCkge1xuICAgIGxldCBuYW1lO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0TG9jLFxuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHR5cGUpKSB7XG4gICAgICBuYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW5Jc0tleXdvcmQgPSB0b2tlbktleXdvcmRPcklkZW50aWZpZXJJc0tleXdvcmQodHlwZSk7XG5cbiAgICBpZiAobGliZXJhbCkge1xuICAgICAgaWYgKHRva2VuSXNLZXl3b3JkKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZVRva2VuKDEyOCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQobmFtZSwgc3RhcnRMb2MsIHRva2VuSXNLZXl3b3JkLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICBjaGVja1Jlc2VydmVkV29yZCh3b3JkLCBzdGFydExvYywgY2hlY2tLZXl3b3JkcywgaXNCaW5kaW5nKSB7XG4gICAgaWYgKHdvcmQubGVuZ3RoID4gMTApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNhbkJlUmVzZXJ2ZWRXb3JkKHdvcmQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHdvcmQgPT09IFwieWllbGRcIikge1xuICAgICAgaWYgKHRoaXMucHJvZFBhcmFtLmhhc1lpZWxkKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLllpZWxkQmluZGluZ0lkZW50aWZpZXIsIHtcbiAgICAgICAgICBhdDogc3RhcnRMb2NcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHdvcmQgPT09IFwiYXdhaXRcIikge1xuICAgICAgaWYgKHRoaXMucHJvZFBhcmFtLmhhc0F3YWl0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkF3YWl0QmluZGluZ0lkZW50aWZpZXIsIHtcbiAgICAgICAgICBhdDogc3RhcnRMb2NcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2NvcGUuaW5TdGF0aWNCbG9jaykge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Bd2FpdEJpbmRpbmdJZGVudGlmaWVySW5TdGF0aWNCbG9jaywge1xuICAgICAgICAgIGF0OiBzdGFydExvY1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5yZWNvcmRBc3luY0Fycm93UGFyYW1ldGVyc0Vycm9yKHtcbiAgICAgICAgYXQ6IHN0YXJ0TG9jXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHdvcmQgPT09IFwiYXJndW1lbnRzXCIpIHtcbiAgICAgIGlmICh0aGlzLnNjb3BlLmluQ2xhc3NBbmROb3RJbk5vbkFycm93RnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQXJndW1lbnRzSW5DbGFzcywge1xuICAgICAgICAgIGF0OiBzdGFydExvY1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGVja0tleXdvcmRzICYmIGlzS2V5d29yZCh3b3JkKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZEtleXdvcmQsIHtcbiAgICAgICAgYXQ6IHN0YXJ0TG9jLFxuICAgICAgICBrZXl3b3JkOiB3b3JkXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXNlcnZlZFRlc3QgPSAhdGhpcy5zdGF0ZS5zdHJpY3QgPyBpc1Jlc2VydmVkV29yZCA6IGlzQmluZGluZyA/IGlzU3RyaWN0QmluZFJlc2VydmVkV29yZCA6IGlzU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuXG4gICAgaWYgKHJlc2VydmVkVGVzdCh3b3JkLCB0aGlzLmluTW9kdWxlKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFJlc2VydmVkV29yZCwge1xuICAgICAgICBhdDogc3RhcnRMb2MsXG4gICAgICAgIHJlc2VydmVkV29yZDogd29yZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaXNBd2FpdEFsbG93ZWQoKSB7XG4gICAgaWYgKHRoaXMucHJvZFBhcmFtLmhhc0F3YWl0KSByZXR1cm4gdHJ1ZTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbiAmJiAhdGhpcy5zY29wZS5pbkZ1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwYXJzZUF3YWl0KHN0YXJ0UG9zLCBzdGFydExvYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkUGFyYW1ldGVySW5pdGlhbGl6ZXJFcnJvcihFcnJvcnMuQXdhaXRFeHByZXNzaW9uRm9ybWFsUGFyYW1ldGVyLCB7XG4gICAgICBhdDogbm9kZVxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuZWF0KDU1KSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuT2Jzb2xldGVBd2FpdFN0YXIsIHtcbiAgICAgICAgYXQ6IG5vZGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zY29wZS5pbkZ1bmN0aW9uICYmICF0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikge1xuICAgICAgaWYgKHRoaXMuaXNBbWJpZ3VvdXNBd2FpdCgpKSB7XG4gICAgICAgIHRoaXMuYW1iaWd1b3VzU2NyaXB0RGlmZmVyZW50QXN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5zdGF0ZS5zb2xvQXdhaXQpIHtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgaXNBbWJpZ3VvdXNBd2FpdCgpIHtcbiAgICBpZiAodGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkgcmV0dXJuIHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHJldHVybiB0eXBlID09PSA1MyB8fCB0eXBlID09PSAxMCB8fCB0eXBlID09PSAwIHx8IHRva2VuSXNUZW1wbGF0ZSh0eXBlKSB8fCB0eXBlID09PSAxMzMgfHwgdHlwZSA9PT0gNTYgfHwgdGhpcy5oYXNQbHVnaW4oXCJ2OGludHJpbnNpY1wiKSAmJiB0eXBlID09PSA1NDtcbiAgfVxuXG4gIHBhcnNlWWllbGQoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkUGFyYW1ldGVySW5pdGlhbGl6ZXJFcnJvcihFcnJvcnMuWWllbGRJblBhcmFtZXRlciwge1xuICAgICAgYXQ6IG5vZGVcbiAgICB9KTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBsZXQgZGVsZWdhdGluZyA9IGZhbHNlO1xuICAgIGxldCBhcmd1bWVudCA9IG51bGw7XG5cbiAgICBpZiAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIGRlbGVnYXRpbmcgPSB0aGlzLmVhdCg1NSk7XG5cbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTM1OlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGlmICghZGVsZWdhdGluZykgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUuZGVsZWdhdGUgPSBkZWxlZ2F0aW5nO1xuICAgIG5vZGUuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiWWllbGRFeHByZXNzaW9uXCIpO1xuICB9XG5cbiAgY2hlY2tQaXBlbGluZUF0SW5maXhPcGVyYXRvcihsZWZ0LCBsZWZ0U3RhcnRMb2MpIHtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7XG4gICAgICBwcm9wb3NhbDogXCJzbWFydFwiXG4gICAgfV0pKSB7XG4gICAgICBpZiAobGVmdC50eXBlID09PSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlBpcGVsaW5lSGVhZFNlcXVlbmNlRXhwcmVzc2lvbiwge1xuICAgICAgICAgIGF0OiBsZWZ0U3RhcnRMb2NcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGFyc2VTbWFydFBpcGVsaW5lQm9keUluU3R5bGUoY2hpbGRFeHByLCBzdGFydFBvcywgc3RhcnRMb2MpIHtcbiAgICBpZiAodGhpcy5pc1NpbXBsZVJlZmVyZW5jZShjaGlsZEV4cHIpKSB7XG4gICAgICBjb25zdCBib2R5Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIGJvZHlOb2RlLmNhbGxlZSA9IGNoaWxkRXhwcjtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoYm9keU5vZGUsIFwiUGlwZWxpbmVCYXJlRnVuY3Rpb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJvZHlOb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgdGhpcy5jaGVja1NtYXJ0UGlwZVRvcGljQm9keUVhcmx5RXJyb3JzKHN0YXJ0TG9jKTtcbiAgICAgIGJvZHlOb2RlLmV4cHJlc3Npb24gPSBjaGlsZEV4cHI7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGJvZHlOb2RlLCBcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGlzU2ltcGxlUmVmZXJlbmNlKGV4cHJlc3Npb24pIHtcbiAgICBzd2l0Y2ggKGV4cHJlc3Npb24udHlwZSkge1xuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuICFleHByZXNzaW9uLmNvbXB1dGVkICYmIHRoaXMuaXNTaW1wbGVSZWZlcmVuY2UoZXhwcmVzc2lvbi5vYmplY3QpO1xuXG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrU21hcnRQaXBlVG9waWNCb2R5RWFybHlFcnJvcnMoc3RhcnRMb2MpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxOSkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlBpcGVsaW5lQm9keU5vQXJyb3csIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy50b3BpY1JlZmVyZW5jZVdhc1VzZWRJbkN1cnJlbnRDb250ZXh0KCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlBpcGVsaW5lVG9waWNVbnVzZWQsIHtcbiAgICAgICAgYXQ6IHN0YXJ0TG9jXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB3aXRoVG9waWNCaW5kaW5nQ29udGV4dChjYWxsYmFjaykge1xuICAgIGNvbnN0IG91dGVyQ29udGV4dFRvcGljU3RhdGUgPSB0aGlzLnN0YXRlLnRvcGljQ29udGV4dDtcbiAgICB0aGlzLnN0YXRlLnRvcGljQ29udGV4dCA9IHtcbiAgICAgIG1heE51bU9mUmVzb2x2YWJsZVRvcGljczogMSxcbiAgICAgIG1heFRvcGljSW5kZXg6IG51bGxcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnN0YXRlLnRvcGljQ29udGV4dCA9IG91dGVyQ29udGV4dFRvcGljU3RhdGU7XG4gICAgfVxuICB9XG5cbiAgd2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgIHByb3Bvc2FsOiBcInNtYXJ0XCJcbiAgICB9XSkpIHtcbiAgICAgIGNvbnN0IG91dGVyQ29udGV4dFRvcGljU3RhdGUgPSB0aGlzLnN0YXRlLnRvcGljQ29udGV4dDtcbiAgICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0ID0ge1xuICAgICAgICBtYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6IDAsXG4gICAgICAgIG1heFRvcGljSW5kZXg6IG51bGxcbiAgICAgIH07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQgPSBvdXRlckNvbnRleHRUb3BpY1N0YXRlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICB3aXRoU29sb0F3YWl0UGVybWl0dGluZ0NvbnRleHQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBvdXRlckNvbnRleHRTb2xvQXdhaXRTdGF0ZSA9IHRoaXMuc3RhdGUuc29sb0F3YWl0O1xuICAgIHRoaXMuc3RhdGUuc29sb0F3YWl0ID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS5zb2xvQXdhaXQgPSBvdXRlckNvbnRleHRTb2xvQXdhaXRTdGF0ZTtcbiAgICB9XG4gIH1cblxuICBhbGxvd0luQW5kKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZmxhZ3MgPSB0aGlzLnByb2RQYXJhbS5jdXJyZW50RmxhZ3MoKTtcbiAgICBjb25zdCBwcm9kUGFyYW1Ub1NldCA9IFBBUkFNX0lOICYgfmZsYWdzO1xuXG4gICAgaWYgKHByb2RQYXJhbVRvU2V0KSB7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihmbGFncyB8IFBBUkFNX0lOKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cblxuICBkaXNhbGxvd0luQW5kKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZmxhZ3MgPSB0aGlzLnByb2RQYXJhbS5jdXJyZW50RmxhZ3MoKTtcbiAgICBjb25zdCBwcm9kUGFyYW1Ub0NsZWFyID0gUEFSQU1fSU4gJiBmbGFncztcblxuICAgIGlmIChwcm9kUGFyYW1Ub0NsZWFyKSB7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihmbGFncyAmIH5QQVJBTV9JTik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG5cbiAgcmVnaXN0ZXJUb3BpY1JlZmVyZW5jZSgpIHtcbiAgICB0aGlzLnN0YXRlLnRvcGljQ29udGV4dC5tYXhUb3BpY0luZGV4ID0gMDtcbiAgfVxuXG4gIHRvcGljUmVmZXJlbmNlSXNBbGxvd2VkSW5DdXJyZW50Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4TnVtT2ZSZXNvbHZhYmxlVG9waWNzID49IDE7XG4gIH1cblxuICB0b3BpY1JlZmVyZW5jZVdhc1VzZWRJbkN1cnJlbnRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnRvcGljQ29udGV4dC5tYXhUb3BpY0luZGV4ICE9IG51bGwgJiYgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4VG9waWNJbmRleCA+PSAwO1xuICB9XG5cbiAgcGFyc2VGU2hhcnBQaXBlbGluZUJvZHkocHJlYykge1xuICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRydWU7XG4gICAgY29uc3QgcmV0ID0gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeU9yUHJpdmF0ZSgpLCBzdGFydFBvcywgc3RhcnRMb2MsIHByZWMpO1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgcGFyc2VNb2R1bGVFeHByZXNzaW9uKCkge1xuICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwibW9kdWxlQmxvY2tzXCIpO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZWF0KDUpO1xuICAgIGNvbnN0IHJldmVydFNjb3BlcyA9IHRoaXMuaW5pdGlhbGl6ZVNjb3Blcyh0cnVlKTtcbiAgICB0aGlzLmVudGVySW5pdGlhbFNjb3BlcygpO1xuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VQcm9ncmFtKHByb2dyYW0sIDgsIFwibW9kdWxlXCIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXZlcnRTY29wZXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLmVhdCg4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTW9kdWxlRXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIHBhcnNlUHJvcGVydHlOYW1lUHJlZml4T3BlcmF0b3IocHJvcCkge31cblxufVxuXG5jb25zdCBsb29wTGFiZWwgPSB7XG4gIGtpbmQ6IFwibG9vcFwiXG59LFxuICAgICAgc3dpdGNoTGFiZWwgPSB7XG4gIGtpbmQ6IFwic3dpdGNoXCJcbn07XG5jb25zdCBGVU5DX05PX0ZMQUdTID0gMGIwMDAsXG4gICAgICBGVU5DX1NUQVRFTUVOVCA9IDBiMDAxLFxuICAgICAgRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCA9IDBiMDEwLFxuICAgICAgRlVOQ19OVUxMQUJMRV9JRCA9IDBiMTAwO1xuY29uc3QgbG9uZVN1cnJvZ2F0ZSA9IC9bXFx1RDgwMC1cXHVERkZGXS91O1xuY29uc3Qga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciA9IC9pbig/OnN0YW5jZW9mKT8veTtcblxuZnVuY3Rpb24gYmFiZWw3Q29tcGF0VG9rZW5zKHRva2VucywgaW5wdXQpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRva2VuO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlID09PSAxMzQpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsb2MsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfSA9IHRva2VuO1xuICAgICAgICAgIGNvbnN0IGhhc2hFbmRQb3MgPSBzdGFydCArIDE7XG4gICAgICAgICAgY29uc3QgaGFzaEVuZExvYyA9IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChsb2Muc3RhcnQsIDEpO1xuICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSwgbmV3IFRva2VuKHtcbiAgICAgICAgICAgIHR5cGU6IGdldEV4cG9ydGVkVG9rZW4oMjcpLFxuICAgICAgICAgICAgdmFsdWU6IFwiI1wiLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBoYXNoRW5kUG9zLFxuICAgICAgICAgICAgc3RhcnRMb2M6IGxvYy5zdGFydCxcbiAgICAgICAgICAgIGVuZExvYzogaGFzaEVuZExvY1xuICAgICAgICAgIH0pLCBuZXcgVG9rZW4oe1xuICAgICAgICAgICAgdHlwZTogZ2V0RXhwb3J0ZWRUb2tlbigxMjgpLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgc3RhcnQ6IGhhc2hFbmRQb3MsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHN0YXJ0TG9jOiBoYXNoRW5kTG9jLFxuICAgICAgICAgICAgZW5kTG9jOiBsb2MuZW5kXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbklzVGVtcGxhdGUodHlwZSkpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsb2MsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfSA9IHRva2VuO1xuICAgICAgICAgIGNvbnN0IGJhY2txdW90ZUVuZCA9IHN0YXJ0ICsgMTtcbiAgICAgICAgICBjb25zdCBiYWNrcXVvdGVFbmRMb2MgPSBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQobG9jLnN0YXJ0LCAxKTtcbiAgICAgICAgICBsZXQgc3RhcnRUb2tlbjtcblxuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gOTYpIHtcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4gPSBuZXcgVG9rZW4oe1xuICAgICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDIyKSxcbiAgICAgICAgICAgICAgdmFsdWU6IFwiYFwiLFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogYmFja3F1b3RlRW5kLFxuICAgICAgICAgICAgICBzdGFydExvYzogbG9jLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmRMb2M6IGJhY2txdW90ZUVuZExvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4gPSBuZXcgVG9rZW4oe1xuICAgICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDgpLFxuICAgICAgICAgICAgICB2YWx1ZTogXCJ9XCIsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBiYWNrcXVvdGVFbmQsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jOiBsb2Muc3RhcnQsXG4gICAgICAgICAgICAgIGVuZExvYzogYmFja3F1b3RlRW5kTG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdGVtcGxhdGVWYWx1ZSwgdGVtcGxhdGVFbGVtZW50RW5kLCB0ZW1wbGF0ZUVsZW1lbnRFbmRMb2MsIGVuZFRva2VuO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT09IDI0KSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZUVsZW1lbnRFbmQgPSBlbmQgLSAxO1xuICAgICAgICAgICAgdGVtcGxhdGVFbGVtZW50RW5kTG9jID0gY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KGxvYy5lbmQsIC0xKTtcbiAgICAgICAgICAgIHRlbXBsYXRlVmFsdWUgPSB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiB2YWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICBlbmRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICAgIHR5cGU6IGdldEV4cG9ydGVkVG9rZW4oMjIpLFxuICAgICAgICAgICAgICB2YWx1ZTogXCJgXCIsXG4gICAgICAgICAgICAgIHN0YXJ0OiB0ZW1wbGF0ZUVsZW1lbnRFbmQsXG4gICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICBzdGFydExvYzogdGVtcGxhdGVFbGVtZW50RW5kTG9jLFxuICAgICAgICAgICAgICBlbmRMb2M6IGxvYy5lbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZUVsZW1lbnRFbmQgPSBlbmQgLSAyO1xuICAgICAgICAgICAgdGVtcGxhdGVFbGVtZW50RW5kTG9jID0gY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KGxvYy5lbmQsIC0yKTtcbiAgICAgICAgICAgIHRlbXBsYXRlVmFsdWUgPSB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiB2YWx1ZS5zbGljZSgxLCAtMik7XG4gICAgICAgICAgICBlbmRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICAgIHR5cGU6IGdldEV4cG9ydGVkVG9rZW4oMjMpLFxuICAgICAgICAgICAgICB2YWx1ZTogXCIke1wiLFxuICAgICAgICAgICAgICBzdGFydDogdGVtcGxhdGVFbGVtZW50RW5kLFxuICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgc3RhcnRMb2M6IHRlbXBsYXRlRWxlbWVudEVuZExvYyxcbiAgICAgICAgICAgICAgZW5kTG9jOiBsb2MuZW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbnMuc3BsaWNlKGksIDEsIHN0YXJ0VG9rZW4sIG5ldyBUb2tlbih7XG4gICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDIwKSxcbiAgICAgICAgICAgIHZhbHVlOiB0ZW1wbGF0ZVZhbHVlLFxuICAgICAgICAgICAgc3RhcnQ6IGJhY2txdW90ZUVuZCxcbiAgICAgICAgICAgIGVuZDogdGVtcGxhdGVFbGVtZW50RW5kLFxuICAgICAgICAgICAgc3RhcnRMb2M6IGJhY2txdW90ZUVuZExvYyxcbiAgICAgICAgICAgIGVuZExvYzogdGVtcGxhdGVFbGVtZW50RW5kTG9jXG4gICAgICAgICAgfSksIGVuZFRva2VuKTtcbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRva2VuLnR5cGUgPSBnZXRFeHBvcnRlZFRva2VuKHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmNsYXNzIFN0YXRlbWVudFBhcnNlciBleHRlbmRzIEV4cHJlc3Npb25QYXJzZXIge1xuICBwYXJzZVRvcExldmVsKGZpbGUsIHByb2dyYW0pIHtcbiAgICBmaWxlLnByb2dyYW0gPSB0aGlzLnBhcnNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICBmaWxlLmNvbW1lbnRzID0gdGhpcy5zdGF0ZS5jb21tZW50cztcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudG9rZW5zKSB7XG4gICAgICBmaWxlLnRva2VucyA9IGJhYmVsN0NvbXBhdFRva2Vucyh0aGlzLnRva2VucywgdGhpcy5pbnB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShmaWxlLCBcIkZpbGVcIik7XG4gIH1cblxuICBwYXJzZVByb2dyYW0ocHJvZ3JhbSwgZW5kID0gMTM1LCBzb3VyY2VUeXBlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGUpIHtcbiAgICBwcm9ncmFtLnNvdXJjZVR5cGUgPSBzb3VyY2VUeXBlO1xuICAgIHByb2dyYW0uaW50ZXJwcmV0ZXIgPSB0aGlzLnBhcnNlSW50ZXJwcmV0ZXJEaXJlY3RpdmUoKTtcbiAgICB0aGlzLnBhcnNlQmxvY2tCb2R5KHByb2dyYW0sIHRydWUsIHRydWUsIGVuZCk7XG5cbiAgICBpZiAodGhpcy5pbk1vZHVsZSAmJiAhdGhpcy5vcHRpb25zLmFsbG93VW5kZWNsYXJlZEV4cG9ydHMgJiYgdGhpcy5zY29wZS51bmRlZmluZWRFeHBvcnRzLnNpemUgPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IFtsb2NhbE5hbWUsIGF0XSBvZiBBcnJheS5mcm9tKHRoaXMuc2NvcGUudW5kZWZpbmVkRXhwb3J0cykpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlRXhwb3J0VW5kZWZpbmVkLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbG9jYWxOYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvZ3JhbSwgXCJQcm9ncmFtXCIpO1xuICB9XG5cbiAgc3RtdFRvRGlyZWN0aXZlKHN0bXQpIHtcbiAgICBjb25zdCBkaXJlY3RpdmUgPSBzdG10O1xuICAgIGRpcmVjdGl2ZS50eXBlID0gXCJEaXJlY3RpdmVcIjtcbiAgICBkaXJlY3RpdmUudmFsdWUgPSBkaXJlY3RpdmUuZXhwcmVzc2lvbjtcbiAgICBkZWxldGUgZGlyZWN0aXZlLmV4cHJlc3Npb247XG4gICAgY29uc3QgZGlyZWN0aXZlTGl0ZXJhbCA9IGRpcmVjdGl2ZS52YWx1ZTtcbiAgICBjb25zdCBleHByZXNzaW9uVmFsdWUgPSBkaXJlY3RpdmVMaXRlcmFsLnZhbHVlO1xuICAgIGNvbnN0IHJhdyA9IHRoaXMuaW5wdXQuc2xpY2UoZGlyZWN0aXZlTGl0ZXJhbC5zdGFydCwgZGlyZWN0aXZlTGl0ZXJhbC5lbmQpO1xuICAgIGNvbnN0IHZhbCA9IGRpcmVjdGl2ZUxpdGVyYWwudmFsdWUgPSByYXcuc2xpY2UoMSwgLTEpO1xuICAgIHRoaXMuYWRkRXh0cmEoZGlyZWN0aXZlTGl0ZXJhbCwgXCJyYXdcIiwgcmF3KTtcbiAgICB0aGlzLmFkZEV4dHJhKGRpcmVjdGl2ZUxpdGVyYWwsIFwicmF3VmFsdWVcIiwgdmFsKTtcbiAgICB0aGlzLmFkZEV4dHJhKGRpcmVjdGl2ZUxpdGVyYWwsIFwiZXhwcmVzc2lvblZhbHVlXCIsIGV4cHJlc3Npb25WYWx1ZSk7XG4gICAgZGlyZWN0aXZlTGl0ZXJhbC50eXBlID0gXCJEaXJlY3RpdmVMaXRlcmFsXCI7XG4gICAgcmV0dXJuIGRpcmVjdGl2ZTtcbiAgfVxuXG4gIHBhcnNlSW50ZXJwcmV0ZXJEaXJlY3RpdmUoKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDI4KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkludGVycHJldGVyRGlyZWN0aXZlXCIpO1xuICB9XG5cbiAgaXNMZXQoY29udGV4dCkge1xuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoOTkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaXNMZXRLZXl3b3JkKGNvbnRleHQpO1xuICB9XG5cbiAgaXNMZXRLZXl3b3JkKGNvbnRleHQpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5TdGFydCgpO1xuICAgIGNvbnN0IG5leHRDaCA9IHRoaXMuY29kZVBvaW50QXRQb3MobmV4dCk7XG5cbiAgICBpZiAobmV4dENoID09PSA5MiB8fCBuZXh0Q2ggPT09IDkxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChuZXh0Q2ggPT09IDEyMykgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobmV4dENoKSkge1xuICAgICAga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvci5sYXN0SW5kZXggPSBuZXh0O1xuXG4gICAgICBpZiAoa2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvci50ZXN0KHRoaXMuaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IGVuZENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLmxhc3RJbmRleCk7XG5cbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJDaGFyKGVuZENoKSAmJiBlbmRDaCAhPT0gOTIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcGFyc2VTdGF0ZW1lbnQoY29udGV4dCwgdG9wTGV2ZWwpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgyNikpIHtcbiAgICAgIHRoaXMucGFyc2VEZWNvcmF0b3JzKHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50Q29udGVudChjb250ZXh0LCB0b3BMZXZlbCk7XG4gIH1cblxuICBwYXJzZVN0YXRlbWVudENvbnRlbnQoY29udGV4dCwgdG9wTGV2ZWwpIHtcbiAgICBsZXQgc3RhcnR0eXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGxldCBraW5kO1xuXG4gICAgaWYgKHRoaXMuaXNMZXQoY29udGV4dCkpIHtcbiAgICAgIHN0YXJ0dHlwZSA9IDc0O1xuICAgICAga2luZCA9IFwibGV0XCI7XG4gICAgfVxuXG4gICAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCB0cnVlKTtcblxuICAgICAgY2FzZSA2MzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIGZhbHNlKTtcblxuICAgICAgY2FzZSA2NDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKTtcblxuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEb1N0YXRlbWVudChub2RlKTtcblxuICAgICAgY2FzZSA5MTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JTdGF0ZW1lbnQobm9kZSk7XG5cbiAgICAgIGNhc2UgNjg6XG4gICAgICAgIGlmICh0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDQ2KSBicmVhaztcblxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RyaWN0RnVuY3Rpb24sIHtcbiAgICAgICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dCAhPT0gXCJpZlwiICYmIGNvbnRleHQgIT09IFwibGFiZWxcIikge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU2xvcHB5RnVuY3Rpb24sIHtcbiAgICAgICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgZmFsc2UsICFjb250ZXh0KTtcblxuICAgICAgY2FzZSA4MDpcbiAgICAgICAgaWYgKGNvbnRleHQpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpO1xuXG4gICAgICBjYXNlIDY5OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUlmU3RhdGVtZW50KG5vZGUpO1xuXG4gICAgICBjYXNlIDcwOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChub2RlKTtcblxuICAgICAgY2FzZSA3MTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSk7XG5cbiAgICAgIGNhc2UgNzI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSk7XG5cbiAgICAgIGNhc2UgNzM6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpO1xuXG4gICAgICBjYXNlIDc1OlxuICAgICAgY2FzZSA3NDpcbiAgICAgICAga2luZCA9IGtpbmQgfHwgdGhpcy5zdGF0ZS52YWx1ZTtcblxuICAgICAgICBpZiAoY29udGV4dCAmJiBraW5kICE9PSBcInZhclwiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZExleGljYWxEZWNsYXJhdGlvbiwge1xuICAgICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQpO1xuXG4gICAgICBjYXNlIDkyOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpO1xuXG4gICAgICBjYXNlIDc2OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSk7XG5cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCbG9jaygpO1xuXG4gICAgICBjYXNlIDEzOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpO1xuXG4gICAgICBjYXNlIDgzOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbmV4dFRva2VuQ2hhckNvZGUgPSB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCk7XG5cbiAgICAgICAgICBpZiAobmV4dFRva2VuQ2hhckNvZGUgPT09IDQwIHx8IG5leHRUb2tlbkNoYXJDb2RlID09PSA0Nikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgODI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUgJiYgIXRvcExldmVsKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkSW1wb3J0RXhwb3J0LCB7XG4gICAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gODMpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VJbXBvcnQobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJJbXBvcnREZWNsYXJhdGlvblwiICYmICghcmVzdWx0LmltcG9ydEtpbmQgfHwgcmVzdWx0LmltcG9ydEtpbmQgPT09IFwidmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VFeHBvcnQobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIgJiYgKCFyZXN1bHQuZXhwb3J0S2luZCB8fCByZXN1bHQuZXhwb3J0S2luZCA9PT0gXCJ2YWx1ZVwiKSB8fCByZXN1bHQudHlwZSA9PT0gXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiICYmICghcmVzdWx0LmV4cG9ydEtpbmQgfHwgcmVzdWx0LmV4cG9ydEtpbmQgPT09IFwidmFsdWVcIikgfHwgcmVzdWx0LnR5cGUgPT09IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5hc3NlcnRNb2R1bGVOb2RlQWxsb3dlZChyZXN1bHQpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Bc3luY0Z1bmN0aW9uSW5TaW5nbGVTdGF0ZW1lbnRDb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWF5YmVOYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblxuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcihzdGFydHR5cGUpICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQoMTQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQobm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpO1xuICAgIH1cbiAgfVxuXG4gIGFzc2VydE1vZHVsZU5vZGVBbGxvd2VkKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUgJiYgIXRoaXMuaW5Nb2R1bGUpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydE91dHNpZGVNb2R1bGUsIHtcbiAgICAgICAgYXQ6IG5vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHRha2VEZWNvcmF0b3JzKG5vZGUpIHtcbiAgICBjb25zdCBkZWNvcmF0b3JzID0gdGhpcy5zdGF0ZS5kZWNvcmF0b3JTdGFja1t0aGlzLnN0YXRlLmRlY29yYXRvclN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICBub2RlLmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzO1xuICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShub2RlLCBkZWNvcmF0b3JzWzBdKTtcbiAgICAgIHRoaXMuc3RhdGUuZGVjb3JhdG9yU3RhY2tbdGhpcy5zdGF0ZS5kZWNvcmF0b3JTdGFjay5sZW5ndGggLSAxXSA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIGNhbkhhdmVMZWFkaW5nRGVjb3JhdG9yKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDgwKTtcbiAgfVxuXG4gIHBhcnNlRGVjb3JhdG9ycyhhbGxvd0V4cG9ydCkge1xuICAgIGNvbnN0IGN1cnJlbnRDb250ZXh0RGVjb3JhdG9ycyA9IHRoaXMuc3RhdGUuZGVjb3JhdG9yU3RhY2tbdGhpcy5zdGF0ZS5kZWNvcmF0b3JTdGFjay5sZW5ndGggLSAxXTtcblxuICAgIHdoaWxlICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgY29uc3QgZGVjb3JhdG9yID0gdGhpcy5wYXJzZURlY29yYXRvcigpO1xuICAgICAgY3VycmVudENvbnRleHREZWNvcmF0b3JzLnB1c2goZGVjb3JhdG9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCg4MikpIHtcbiAgICAgIGlmICghYWxsb3dFeHBvcnQpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikgJiYgIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnNCZWZvcmVFeHBvcnRcIikpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yRXhwb3J0Q2xhc3MsIHtcbiAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5zdGFydExvY1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNhbkhhdmVMZWFkaW5nRGVjb3JhdG9yKCkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRMZWFkaW5nRGVjb3JhdG9yLCB7XG4gICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwYXJzZURlY29yYXRvcigpIHtcbiAgICB0aGlzLmV4cGVjdE9uZVBsdWdpbihbXCJkZWNvcmF0b3JzXCIsIFwiZGVjb3JhdG9ycy1sZWdhY3lcIl0pO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgdGhpcy5zdGF0ZS5kZWNvcmF0b3JTdGFjay5wdXNoKFtdKTtcbiAgICAgIGNvbnN0IHN0YXJ0UG9zID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgIGxldCBleHByO1xuXG4gICAgICBpZiAodGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMTEpO1xuICAgICAgICBleHByID0gdGhpcy53cmFwUGFyZW50aGVzaXMoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlSWRlbnRpZmllcihmYWxzZSk7XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgICAgICAgbm9kZS5vYmplY3QgPSBleHByO1xuICAgICAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5wYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIpO1xuICAgICAgdGhpcy5zdGF0ZS5kZWNvcmF0b3JTdGFjay5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY29yYXRvclwiKTtcbiAgfVxuXG4gIHBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHMoZXhwcikge1xuICAgIGlmICh0aGlzLmVhdCgxMCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShleHByKTtcbiAgICAgIG5vZGUuY2FsbGVlID0gZXhwcjtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKDExLCBmYWxzZSk7XG4gICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3Qobm9kZS5hcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgcGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIGlzQnJlYWspIHtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmICh0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgbm9kZS5sYWJlbCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG5cbiAgICB0aGlzLnZlcmlmeUJyZWFrQ29udGludWUobm9kZSwgaXNCcmVhayk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHZlcmlmeUJyZWFrQ29udGludWUobm9kZSwgaXNCcmVhaykge1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc3RhdGUubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBsYWIgPSB0aGlzLnN0YXRlLmxhYmVsc1tpXTtcblxuICAgICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIGJyZWFrO1xuICAgICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gdGhpcy5zdGF0ZS5sYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0eXBlID0gaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIjtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLklsbGVnYWxCcmVha0NvbnRpbnVlLCB7XG4gICAgICAgIGF0OiBub2RlLFxuICAgICAgICB0eXBlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwYXJzZURlYnVnZ2VyU3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHBhcnNlSGVhZGVyRXhwcmVzc2lvbigpIHtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgY29uc3QgdmFsID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHBhcnNlRG9TdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZVN0YXRlbWVudChcImRvXCIpKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgICB0aGlzLmV4cGVjdCg5Mik7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmVhdCgxMyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRvV2hpbGVTdGF0ZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZUZvclN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIGxldCBhd2FpdEF0ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLmlzQXdhaXRBbGxvd2VkKCkgJiYgdGhpcy5lYXRDb250ZXh0dWFsKDk2KSkge1xuICAgICAgYXdhaXRBdCA9IHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jO1xuICAgIH1cblxuICAgIHRoaXMuc2NvcGUuZW50ZXIoU0NPUEVfT1RIRVIpO1xuICAgIHRoaXMuZXhwZWN0KDEwKTtcblxuICAgIGlmICh0aGlzLm1hdGNoKDEzKSkge1xuICAgICAgaWYgKGF3YWl0QXQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBudWxsKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydHNXaXRoTGV0ID0gdGhpcy5pc0NvbnRleHR1YWwoOTkpO1xuICAgIGNvbnN0IGlzTGV0ID0gc3RhcnRzV2l0aExldCAmJiB0aGlzLmlzTGV0S2V5d29yZCgpO1xuXG4gICAgaWYgKHRoaXMubWF0Y2goNzQpIHx8IHRoaXMubWF0Y2goNzUpIHx8IGlzTGV0KSB7XG4gICAgICBjb25zdCBpbml0Tm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBjb25zdCBraW5kID0gaXNMZXQgPyBcImxldFwiIDogdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5wYXJzZVZhcihpbml0Tm9kZSwgdHJ1ZSwga2luZCk7XG4gICAgICBjb25zdCBpbml0ID0gdGhpcy5maW5pc2hOb2RlKGluaXROb2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG5cbiAgICAgIGlmICgodGhpcy5tYXRjaCg1OCkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTAxKSkgJiYgaW5pdC5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCwgYXdhaXRBdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhd2FpdEF0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRzV2l0aEFzeW5jID0gdGhpcy5pc0NvbnRleHR1YWwoOTUpO1xuICAgIGNvbnN0IHJlZkV4cHJlc3Npb25FcnJvcnMgPSBuZXcgRXhwcmVzc2lvbkVycm9ycygpO1xuICAgIGNvbnN0IGluaXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBjb25zdCBpc0Zvck9mID0gdGhpcy5pc0NvbnRleHR1YWwoMTAxKTtcblxuICAgIGlmIChpc0Zvck9mKSB7XG4gICAgICBpZiAoc3RhcnRzV2l0aExldCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Gb3JPZkxldCwge1xuICAgICAgICAgIGF0OiBpbml0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXdhaXRBdCA9PT0gbnVsbCAmJiBzdGFydHNXaXRoQXN5bmMgJiYgaW5pdC50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Gb3JPZkFzeW5jLCB7XG4gICAgICAgICAgYXQ6IGluaXRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRm9yT2YgfHwgdGhpcy5tYXRjaCg1OCkpIHtcbiAgICAgIHRoaXMuY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGluaXQsIHRydWUpO1xuICAgICAgY29uc3QgdHlwZSA9IGlzRm9yT2YgPyBcIkZvck9mU3RhdGVtZW50XCIgOiBcIkZvckluU3RhdGVtZW50XCI7XG4gICAgICB0aGlzLmNoZWNrTFZhbChpbml0LCB7XG4gICAgICAgIGluOiB7XG4gICAgICAgICAgdHlwZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCwgYXdhaXRBdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChhd2FpdEF0ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCk7XG4gIH1cblxuICBwYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGlzQXN5bmMsIGRlY2xhcmF0aW9uUG9zaXRpb24pIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIEZVTkNfU1RBVEVNRU5UIHwgKGRlY2xhcmF0aW9uUG9zaXRpb24gPyAwIDogRlVOQ19IQU5HSU5HX1NUQVRFTUVOVCksIGlzQXN5bmMpO1xuICB9XG5cbiAgcGFyc2VJZlN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKTtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIik7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCg2NikgPyB0aGlzLnBhcnNlU3RhdGVtZW50KFwiaWZcIikgOiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpIHtcbiAgICBpZiAoIXRoaXMucHJvZFBhcmFtLmhhc1JldHVybiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbGxlZ2FsUmV0dXJuLCB7XG4gICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmICh0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgbm9kZS5hcmd1bWVudCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpO1xuICB9XG5cbiAgcGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKTtcbiAgICBjb25zdCBjYXNlcyA9IG5vZGUuY2FzZXMgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wdXNoKHN3aXRjaExhYmVsKTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX09USEVSKTtcbiAgICBsZXQgY3VyO1xuXG4gICAgZm9yIChsZXQgc2F3RGVmYXVsdDsgIXRoaXMubWF0Y2goOCk7KSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg2MSkgfHwgdGhpcy5tYXRjaCg2NSkpIHtcbiAgICAgICAgY29uc3QgaXNDYXNlID0gdGhpcy5tYXRjaCg2MSk7XG4gICAgICAgIGlmIChjdXIpIHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTtcbiAgICAgICAgY2FzZXMucHVzaChjdXIgPSB0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgY3VyLmNvbnNlcXVlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgaWYgKGlzQ2FzZSkge1xuICAgICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2F3RGVmYXVsdCkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoLCB7XG4gICAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5leHBlY3QoMTQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudChudWxsKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk5ld2xpbmVBZnRlclRocm93LCB7XG4gICAgICAgIGF0OiB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpO1xuICB9XG5cbiAgcGFyc2VDYXRjaENsYXVzZVBhcmFtKCkge1xuICAgIGNvbnN0IHBhcmFtID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgY29uc3Qgc2ltcGxlID0gcGFyYW0udHlwZSA9PT0gXCJJZGVudGlmaWVyXCI7XG4gICAgdGhpcy5zY29wZS5lbnRlcihzaW1wbGUgPyBTQ09QRV9TSU1QTEVfQ0FUQ0ggOiAwKTtcbiAgICB0aGlzLmNoZWNrTFZhbChwYXJhbSwge1xuICAgICAgaW46IHtcbiAgICAgICAgdHlwZTogXCJDYXRjaENsYXVzZVwiXG4gICAgICB9LFxuICAgICAgYmluZGluZzogQklORF9MRVhJQ0FMLFxuICAgICAgYWxsb3dpbmdTbG9wcHlMZXRCaW5kaW5nOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG5cbiAgcGFyc2VUcnlTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYmxvY2sgPSB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICBub2RlLmhhbmRsZXIgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMubWF0Y2goNjIpKSB7XG4gICAgICBjb25zdCBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VDYXRjaENsYXVzZVBhcmFtKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NvcGUuZW50ZXIoU0NPUEVfT1RIRVIpO1xuICAgICAgfVxuXG4gICAgICBjbGF1c2UuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlQmxvY2soZmFsc2UsIGZhbHNlKSk7XG4gICAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICAgIG5vZGUuaGFuZGxlciA9IHRoaXMuZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gICAgfVxuXG4gICAgbm9kZS5maW5hbGl6ZXIgPSB0aGlzLmVhdCg2NykgPyB0aGlzLnBhcnNlQmxvY2soKSA6IG51bGw7XG5cbiAgICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk5vQ2F0Y2hPckZpbmFsbHksIHtcbiAgICAgICAgYXQ6IG5vZGVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplciA9IGZhbHNlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5wYXJzZVZhcihub2RlLCBmYWxzZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gIH1cblxuICBwYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlSGVhZGVyRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZVN0YXRlbWVudChcIndoaWxlXCIpKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RyaWN0V2l0aCwge1xuICAgICAgICBhdDogdGhpcy5zdGF0ZS5zdGFydExvY1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5vYmplY3QgPSB0aGlzLnBhcnNlSGVhZGVyRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlU3RhdGVtZW50KFwid2l0aFwiKSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZUxhYmVsZWRTdGF0ZW1lbnQobm9kZSwgbWF5YmVOYW1lLCBleHByLCBjb250ZXh0KSB7XG4gICAgZm9yIChjb25zdCBsYWJlbCBvZiB0aGlzLnN0YXRlLmxhYmVscykge1xuICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IG1heWJlTmFtZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5MYWJlbFJlZGVjbGFyYXRpb24sIHtcbiAgICAgICAgICBhdDogZXhwcixcbiAgICAgICAgICBsYWJlbE5hbWU6IG1heWJlTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBraW5kID0gdG9rZW5Jc0xvb3AodGhpcy5zdGF0ZS50eXBlKSA/IFwibG9vcFwiIDogdGhpcy5tYXRjaCg3MSkgPyBcInN3aXRjaFwiIDogbnVsbDtcblxuICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVsc1tpXTtcblxuICAgICAgaWYgKGxhYmVsLnN0YXRlbWVudFN0YXJ0ID09PSBub2RlLnN0YXJ0KSB7XG4gICAgICAgIGxhYmVsLnN0YXRlbWVudFN0YXJ0ID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgICAgbGFiZWwua2luZCA9IGtpbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wdXNoKHtcbiAgICAgIG5hbWU6IG1heWJlTmFtZSxcbiAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICBzdGF0ZW1lbnRTdGFydDogdGhpcy5zdGF0ZS5zdGFydFxuICAgIH0pO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoY29udGV4dCA/IGNvbnRleHQuaW5kZXhPZihcImxhYmVsXCIpID09PSAtMSA/IGNvbnRleHQgKyBcImxhYmVsXCIgOiBjb250ZXh0IDogXCJsYWJlbFwiKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgICBub2RlLmxhYmVsID0gZXhwcjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKTtcbiAgfVxuXG4gIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKSB7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZXhwcjtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpO1xuICB9XG5cbiAgcGFyc2VCbG9jayhhbGxvd0RpcmVjdGl2ZXMgPSBmYWxzZSwgY3JlYXRlTmV3TGV4aWNhbFNjb3BlID0gdHJ1ZSwgYWZ0ZXJCbG9ja1BhcnNlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG5cbiAgICBpZiAoYWxsb3dEaXJlY3RpdmVzKSB7XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5jbGVhcigpO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0KDUpO1xuXG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkge1xuICAgICAgdGhpcy5zY29wZS5lbnRlcihTQ09QRV9PVEhFUik7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZUJsb2NrQm9keShub2RlLCBhbGxvd0RpcmVjdGl2ZXMsIGZhbHNlLCA4LCBhZnRlckJsb2NrUGFyc2UpO1xuXG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkge1xuICAgICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpO1xuICB9XG5cbiAgaXNWYWxpZERpcmVjdGl2ZShzdG10KSB7XG4gICAgcmV0dXJuIHN0bXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgc3RtdC5leHByZXNzaW9uLnR5cGUgPT09IFwiU3RyaW5nTGl0ZXJhbFwiICYmICFzdG10LmV4cHJlc3Npb24uZXh0cmEucGFyZW50aGVzaXplZDtcbiAgfVxuXG4gIHBhcnNlQmxvY2tCb2R5KG5vZGUsIGFsbG93RGlyZWN0aXZlcywgdG9wTGV2ZWwsIGVuZCwgYWZ0ZXJCbG9ja1BhcnNlKSB7XG4gICAgY29uc3QgYm9keSA9IG5vZGUuYm9keSA9IFtdO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSBub2RlLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICB0aGlzLnBhcnNlQmxvY2tPck1vZHVsZUJsb2NrQm9keShib2R5LCBhbGxvd0RpcmVjdGl2ZXMgPyBkaXJlY3RpdmVzIDogdW5kZWZpbmVkLCB0b3BMZXZlbCwgZW5kLCBhZnRlckJsb2NrUGFyc2UpO1xuICB9XG5cbiAgcGFyc2VCbG9ja09yTW9kdWxlQmxvY2tCb2R5KGJvZHksIGRpcmVjdGl2ZXMsIHRvcExldmVsLCBlbmQsIGFmdGVyQmxvY2tQYXJzZSkge1xuICAgIGNvbnN0IG9sZFN0cmljdCA9IHRoaXMuc3RhdGUuc3RyaWN0O1xuICAgIGxldCBoYXNTdHJpY3RNb2RlRGlyZWN0aXZlID0gZmFsc2U7XG4gICAgbGV0IHBhcnNlZE5vbkRpcmVjdGl2ZSA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKGVuZCkpIHtcbiAgICAgIGNvbnN0IHN0bXQgPSB0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwsIHRvcExldmVsKTtcblxuICAgICAgaWYgKGRpcmVjdGl2ZXMgJiYgIXBhcnNlZE5vbkRpcmVjdGl2ZSkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkRGlyZWN0aXZlKHN0bXQpKSB7XG4gICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy5zdG10VG9EaXJlY3RpdmUoc3RtdCk7XG4gICAgICAgICAgZGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSk7XG5cbiAgICAgICAgICBpZiAoIWhhc1N0cmljdE1vZGVEaXJlY3RpdmUgJiYgZGlyZWN0aXZlLnZhbHVlLnZhbHVlID09PSBcInVzZSBzdHJpY3RcIikge1xuICAgICAgICAgICAgaGFzU3RyaWN0TW9kZURpcmVjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNldFN0cmljdCh0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZE5vbkRpcmVjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuc3RyaWN0RXJyb3JzLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIGJvZHkucHVzaChzdG10KTtcbiAgICB9XG5cbiAgICBpZiAoYWZ0ZXJCbG9ja1BhcnNlKSB7XG4gICAgICBhZnRlckJsb2NrUGFyc2UuY2FsbCh0aGlzLCBoYXNTdHJpY3RNb2RlRGlyZWN0aXZlKTtcbiAgICB9XG5cbiAgICBpZiAoIW9sZFN0cmljdCkge1xuICAgICAgdGhpcy5zZXRTdHJpY3QoZmFsc2UpO1xuICAgIH1cblxuICAgIHRoaXMubmV4dCgpO1xuICB9XG5cbiAgcGFyc2VGb3Iobm9kZSwgaW5pdCkge1xuICAgIG5vZGUuaW5pdCA9IGluaXQ7XG4gICAgdGhpcy5zZW1pY29sb24oZmFsc2UpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMubWF0Y2goMTMpID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5zZW1pY29sb24oZmFsc2UpO1xuICAgIG5vZGUudXBkYXRlID0gdGhpcy5tYXRjaCgxMSkgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIikpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZUZvckluKG5vZGUsIGluaXQsIGF3YWl0QXQpIHtcbiAgICBjb25zdCBpc0ZvckluID0gdGhpcy5tYXRjaCg1OCk7XG4gICAgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAoaXNGb3JJbikge1xuICAgICAgaWYgKGF3YWl0QXQgIT09IG51bGwpIHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hd2FpdCA9IGF3YWl0QXQgIT09IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGluaXQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiYgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaW5pdCAhPSBudWxsICYmICghaXNGb3JJbiB8fCB0aGlzLnN0YXRlLnN0cmljdCB8fCBpbml0LmtpbmQgIT09IFwidmFyXCIgfHwgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Gb3JJbk9mTG9vcEluaXRpYWxpemVyLCB7XG4gICAgICAgIGF0OiBpbml0LFxuICAgICAgICB0eXBlOiBpc0ZvckluID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRMaHMsIHtcbiAgICAgICAgYXQ6IGluaXQsXG4gICAgICAgIGFuY2VzdG9yOiB7XG4gICAgICAgICAgdHlwZTogXCJGb3JTdGF0ZW1lbnRcIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBub2RlLmxlZnQgPSBpbml0O1xuICAgIG5vZGUucmlnaHQgPSBpc0ZvckluID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIikpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNGb3JJbiA/IFwiRm9ySW5TdGF0ZW1lbnRcIiA6IFwiRm9yT2ZTdGF0ZW1lbnRcIik7XG4gIH1cblxuICBwYXJzZVZhcihub2RlLCBpc0Zvciwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gICAgbm9kZS5raW5kID0ga2luZDtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IGRlY2wgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuICAgICAgZGVjbC5pbml0ID0gIXRoaXMuZWF0KDI5KSA/IG51bGwgOiBpc0ZvciA/IHRoaXMucGFyc2VNYXliZUFzc2lnbkRpc2FsbG93SW4oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcblxuICAgICAgaWYgKGRlY2wuaW5pdCA9PT0gbnVsbCAmJiAhYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgaWYgKGRlY2wuaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgIShpc0ZvciAmJiAodGhpcy5tYXRjaCg1OCkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTAxKSkpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjbGFyYXRpb25NaXNzaW5nSW5pdGlhbGl6ZXIsIHtcbiAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MsXG4gICAgICAgICAgICBraW5kOiBcImRlc3RydWN0dXJpbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGtpbmQgPT09IFwiY29uc3RcIiAmJiAhKHRoaXMubWF0Y2goNTgpIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEwMSkpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjbGFyYXRpb25NaXNzaW5nSW5pdGlhbGl6ZXIsIHtcbiAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MsXG4gICAgICAgICAgICBraW5kOiBcImNvbnN0XCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZWNsYXJhdGlvbnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpO1xuICAgICAgaWYgKCF0aGlzLmVhdCgxMikpIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VWYXJJZChkZWNsLCBraW5kKSB7XG4gICAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKGRlY2wuaWQsIHtcbiAgICAgIGluOiB7XG4gICAgICAgIHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdG9yXCJcbiAgICAgIH0sXG4gICAgICBiaW5kaW5nOiBraW5kID09PSBcInZhclwiID8gQklORF9WQVIgOiBCSU5EX0xFWElDQUxcbiAgICB9KTtcbiAgfVxuXG4gIHBhcnNlRnVuY3Rpb24obm9kZSwgc3RhdGVtZW50ID0gRlVOQ19OT19GTEFHUywgaXNBc3luYyA9IGZhbHNlKSB7XG4gICAgY29uc3QgaXNTdGF0ZW1lbnQgPSBzdGF0ZW1lbnQgJiBGVU5DX1NUQVRFTUVOVDtcbiAgICBjb25zdCBpc0hhbmdpbmdTdGF0ZW1lbnQgPSBzdGF0ZW1lbnQgJiBGVU5DX0hBTkdJTkdfU1RBVEVNRU5UO1xuICAgIGNvbnN0IHJlcXVpcmVJZCA9ICEhaXNTdGF0ZW1lbnQgJiYgIShzdGF0ZW1lbnQgJiBGVU5DX05VTExBQkxFX0lEKTtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcblxuICAgIGlmICh0aGlzLm1hdGNoKDU1KSAmJiBpc0hhbmdpbmdTdGF0ZW1lbnQpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkdlbmVyYXRvckluU2luZ2xlU3RhdGVtZW50Q29udGV4dCwge1xuICAgICAgICBhdDogdGhpcy5zdGF0ZS5zdGFydExvY1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbm9kZS5nZW5lcmF0b3IgPSB0aGlzLmVhdCg1NSk7XG5cbiAgICBpZiAoaXNTdGF0ZW1lbnQpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlRnVuY3Rpb25JZChyZXF1aXJlSWQpO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5zY29wZS5lbnRlcihTQ09QRV9GVU5DVElPTik7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuXG4gICAgaWYgKCFpc1N0YXRlbWVudCkge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VGdW5jdGlvbklkKCk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGZhbHNlKTtcbiAgICB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4ge1xuICAgICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCBpc1N0YXRlbWVudCA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIik7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuXG4gICAgaWYgKGlzU3RhdGVtZW50ICYmICFpc0hhbmdpbmdTdGF0ZW1lbnQpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJGdW5jdGlvblN0YXRlbWVudElkKG5vZGUpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZUZ1bmN0aW9uSWQocmVxdWlyZUlkKSB7XG4gICAgcmV0dXJuIHJlcXVpcmVJZCB8fCB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpID8gdGhpcy5wYXJzZUlkZW50aWZpZXIoKSA6IG51bGw7XG4gIH1cblxuICBwYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGFsbG93TW9kaWZpZXJzKSB7XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmVudGVyKG5ld1BhcmFtZXRlckRlY2xhcmF0aW9uU2NvcGUoKSk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QoMTEsIDQxLCBmYWxzZSwgYWxsb3dNb2RpZmllcnMpO1xuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcbiAgfVxuXG4gIHJlZ2lzdGVyRnVuY3Rpb25TdGF0ZW1lbnRJZChub2RlKSB7XG4gICAgaWYgKCFub2RlLmlkKSByZXR1cm47XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsIHRoaXMuc3RhdGUuc3RyaWN0IHx8IG5vZGUuZ2VuZXJhdG9yIHx8IG5vZGUuYXN5bmMgPyB0aGlzLnNjb3BlLnRyZWF0RnVuY3Rpb25zQXNWYXIgPyBCSU5EX1ZBUiA6IEJJTkRfTEVYSUNBTCA6IEJJTkRfRlVOQ1RJT04sIG5vZGUuaWQubG9jLnN0YXJ0KTtcbiAgfVxuXG4gIHBhcnNlQ2xhc3Mobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnRha2VEZWNvcmF0b3JzKG5vZGUpO1xuICAgIGNvbnN0IG9sZFN0cmljdCA9IHRoaXMuc3RhdGUuc3RyaWN0O1xuICAgIHRoaXMuc3RhdGUuc3RyaWN0ID0gdHJ1ZTtcbiAgICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCk7XG4gICAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUNsYXNzQm9keSghIW5vZGUuc3VwZXJDbGFzcywgb2xkU3RyaWN0KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKTtcbiAgfVxuXG4gIGlzQ2xhc3NQcm9wZXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgyOSkgfHwgdGhpcy5tYXRjaCgxMykgfHwgdGhpcy5tYXRjaCg4KTtcbiAgfVxuXG4gIGlzQ2xhc3NNZXRob2QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTApO1xuICB9XG5cbiAgaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICByZXR1cm4gIW1ldGhvZC5jb21wdXRlZCAmJiAhbWV0aG9kLnN0YXRpYyAmJiAobWV0aG9kLmtleS5uYW1lID09PSBcImNvbnN0cnVjdG9yXCIgfHwgbWV0aG9kLmtleS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgfVxuXG4gIHBhcnNlQ2xhc3NCb2R5KGhhZFN1cGVyQ2xhc3MsIG9sZFN0cmljdCkge1xuICAgIHRoaXMuY2xhc3NTY29wZS5lbnRlcigpO1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgaGFkQ29uc3RydWN0b3I6IGZhbHNlLFxuICAgICAgaGFkU3VwZXJDbGFzc1xuICAgIH07XG4gICAgbGV0IGRlY29yYXRvcnMgPSBbXTtcbiAgICBjb25zdCBjbGFzc0JvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNsYXNzQm9keS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHtcbiAgICAgIHdoaWxlICghdGhpcy5tYXRjaCg4KSkge1xuICAgICAgICBpZiAodGhpcy5lYXQoMTMpKSB7XG4gICAgICAgICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yU2VtaWNvbG9uLCB7XG4gICAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2goMjYpKSB7XG4gICAgICAgICAgZGVjb3JhdG9ycy5wdXNoKHRoaXMucGFyc2VEZWNvcmF0b3IoKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZW1iZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuXG4gICAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgIG1lbWJlci5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKG1lbWJlciwgZGVjb3JhdG9yc1swXSk7XG4gICAgICAgICAgZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXJzZUNsYXNzTWVtYmVyKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSk7XG5cbiAgICAgICAgaWYgKG1lbWJlci5raW5kID09PSBcImNvbnN0cnVjdG9yXCIgJiYgbWVtYmVyLmRlY29yYXRvcnMgJiYgbWVtYmVyLmRlY29yYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvckNvbnN0cnVjdG9yLCB7XG4gICAgICAgICAgICBhdDogbWVtYmVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgICB0aGlzLm5leHQoKTtcblxuICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVHJhaWxpbmdEZWNvcmF0b3IsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY2xhc3NTY29wZS5leGl0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShjbGFzc0JvZHksIFwiQ2xhc3NCb2R5XCIpO1xuICB9XG5cbiAgcGFyc2VDbGFzc01lbWJlckZyb21Nb2RpZmllcihjbGFzc0JvZHksIG1lbWJlcikge1xuICAgIGNvbnN0IGtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuXG4gICAgaWYgKHRoaXMuaXNDbGFzc01ldGhvZCgpKSB7XG4gICAgICBjb25zdCBtZXRob2QgPSBtZW1iZXI7XG4gICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgICBtZXRob2QuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIG1ldGhvZC5rZXkgPSBrZXk7XG4gICAgICBtZXRob2Quc3RhdGljID0gZmFsc2U7XG4gICAgICB0aGlzLnB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ2xhc3NQcm9wZXJ0eSgpKSB7XG4gICAgICBjb25zdCBwcm9wID0gbWVtYmVyO1xuICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgcHJvcC5rZXkgPSBrZXk7XG4gICAgICBwcm9wLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eShwcm9wKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlKSB7XG4gICAgY29uc3QgaXNTdGF0aWMgPSB0aGlzLmlzQ29udGV4dHVhbCgxMDQpO1xuXG4gICAgaWYgKGlzU3RhdGljKSB7XG4gICAgICBpZiAodGhpcy5wYXJzZUNsYXNzTWVtYmVyRnJvbU1vZGlmaWVyKGNsYXNzQm9keSwgbWVtYmVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVhdCg1KSkge1xuICAgICAgICB0aGlzLnBhcnNlQ2xhc3NTdGF0aWNCbG9jayhjbGFzc0JvZHksIG1lbWJlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlLCBpc1N0YXRpYyk7XG4gIH1cblxuICBwYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgaXNTdGF0aWMpIHtcbiAgICBjb25zdCBwdWJsaWNNZXRob2QgPSBtZW1iZXI7XG4gICAgY29uc3QgcHJpdmF0ZU1ldGhvZCA9IG1lbWJlcjtcbiAgICBjb25zdCBwdWJsaWNQcm9wID0gbWVtYmVyO1xuICAgIGNvbnN0IHByaXZhdGVQcm9wID0gbWVtYmVyO1xuICAgIGNvbnN0IGFjY2Vzc29yUHJvcCA9IG1lbWJlcjtcbiAgICBjb25zdCBtZXRob2QgPSBwdWJsaWNNZXRob2Q7XG4gICAgY29uc3QgcHVibGljTWVtYmVyID0gcHVibGljTWV0aG9kO1xuICAgIG1lbWJlci5zdGF0aWMgPSBpc1N0YXRpYztcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lUHJlZml4T3BlcmF0b3IobWVtYmVyKTtcblxuICAgIGlmICh0aGlzLmVhdCg1NSkpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIGNvbnN0IGlzUHJpdmF0ZU5hbWUgPSB0aGlzLm1hdGNoKDEzNCk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShtZXRob2QpO1xuXG4gICAgICBpZiAoaXNQcml2YXRlTmFtZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBwcml2YXRlTWV0aG9kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkNvbnN0cnVjdG9ySXNHZW5lcmF0b3IsIHtcbiAgICAgICAgICBhdDogcHVibGljTWV0aG9kLmtleVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIHRydWUsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGlzQ29udGV4dHVhbCA9IHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkgJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgY29uc3QgaXNQcml2YXRlID0gdGhpcy5tYXRjaCgxMzQpO1xuICAgIGNvbnN0IGtleSA9IHRoaXMucGFyc2VDbGFzc0VsZW1lbnROYW1lKG1lbWJlcik7XG4gICAgY29uc3QgbWF5YmVRdWVzdGlvblRva2VuU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMucGFyc2VQb3N0TWVtYmVyTmFtZU1vZGlmaWVycyhwdWJsaWNNZW1iZXIpO1xuXG4gICAgaWYgKHRoaXMuaXNDbGFzc01ldGhvZCgpKSB7XG4gICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG5cbiAgICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgcHJpdmF0ZU1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0NvbnN0cnVjdG9yID0gdGhpcy5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKHB1YmxpY01ldGhvZCk7XG4gICAgICBsZXQgYWxsb3dzRGlyZWN0U3VwZXIgPSBmYWxzZTtcblxuICAgICAgaWYgKGlzQ29uc3RydWN0b3IpIHtcbiAgICAgICAgcHVibGljTWV0aG9kLmtpbmQgPSBcImNvbnN0cnVjdG9yXCI7XG5cbiAgICAgICAgaWYgKHN0YXRlLmhhZENvbnN0cnVjdG9yICYmICF0aGlzLmhhc1BsdWdpbihcInR5cGVzY3JpcHRcIikpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EdXBsaWNhdGVDb25zdHJ1Y3Rvciwge1xuICAgICAgICAgICAgYXQ6IGtleVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgJiYgdGhpcy5oYXNQbHVnaW4oXCJ0eXBlc2NyaXB0XCIpICYmIG1lbWJlci5vdmVycmlkZSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk92ZXJyaWRlT25Db25zdHJ1Y3Rvciwge1xuICAgICAgICAgICAgYXQ6IGtleVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaGFkQ29uc3RydWN0b3IgPSB0cnVlO1xuICAgICAgICBhbGxvd3NEaXJlY3RTdXBlciA9IHN0YXRlLmhhZFN1cGVyQ2xhc3M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgcHVibGljTWV0aG9kLCBmYWxzZSwgZmFsc2UsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDbGFzc1Byb3BlcnR5KCkpIHtcbiAgICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcml2YXRlUHJvcGVydHkoY2xhc3NCb2R5LCBwcml2YXRlUHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1Byb3BlcnR5KGNsYXNzQm9keSwgcHVibGljUHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0NvbnRleHR1YWwgJiYga2V5Lm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGtleSk7XG4gICAgICBjb25zdCBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KDU1KTtcblxuICAgICAgaWYgKHB1YmxpY01lbWJlci5vcHRpb25hbCkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQobWF5YmVRdWVzdGlvblRva2VuU3RhcnRMb2MpO1xuICAgICAgfVxuXG4gICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgICBjb25zdCBpc1ByaXZhdGUgPSB0aGlzLm1hdGNoKDEzNCk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShtZXRob2QpO1xuICAgICAgdGhpcy5wYXJzZVBvc3RNZW1iZXJOYW1lTW9kaWZpZXJzKHB1YmxpY01lbWJlcik7XG5cbiAgICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgcHJpdmF0ZU1ldGhvZCwgaXNHZW5lcmF0b3IsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JJc0FzeW5jLCB7XG4gICAgICAgICAgICBhdDogcHVibGljTWV0aG9kLmtleVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIGlzR2VuZXJhdG9yLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNDb250ZXh0dWFsICYmIChrZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBrZXkubmFtZSA9PT0gXCJzZXRcIikgJiYgISh0aGlzLm1hdGNoKDU1KSAmJiB0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkpIHtcbiAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGtleSk7XG4gICAgICBtZXRob2Qua2luZCA9IGtleS5uYW1lO1xuICAgICAgY29uc3QgaXNQcml2YXRlID0gdGhpcy5tYXRjaCgxMzQpO1xuICAgICAgdGhpcy5wYXJzZUNsYXNzRWxlbWVudE5hbWUocHVibGljTWV0aG9kKTtcblxuICAgICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBwcml2YXRlTWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JJc0FjY2Vzc29yLCB7XG4gICAgICAgICAgICBhdDogcHVibGljTWV0aG9kLmtleVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGVja0dldHRlclNldHRlclBhcmFtcyhwdWJsaWNNZXRob2QpO1xuICAgIH0gZWxzZSBpZiAoaXNDb250ZXh0dWFsICYmIGtleS5uYW1lID09PSBcImFjY2Vzc29yXCIgJiYgIXRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImRlY29yYXRvckF1dG9BY2Nlc3NvcnNcIik7XG4gICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgICAgY29uc3QgaXNQcml2YXRlID0gdGhpcy5tYXRjaCgxMzQpO1xuICAgICAgdGhpcy5wYXJzZUNsYXNzRWxlbWVudE5hbWUocHVibGljUHJvcCk7XG4gICAgICB0aGlzLnB1c2hDbGFzc0FjY2Vzc29yUHJvcGVydHkoY2xhc3NCb2R5LCBhY2Nlc3NvclByb3AsIGlzUHJpdmF0ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVQcm9wZXJ0eShjbGFzc0JvZHksIHByaXZhdGVQcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJvcGVydHkoY2xhc3NCb2R5LCBwdWJsaWNQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VDbGFzc0VsZW1lbnROYW1lKG1lbWJlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKCh0eXBlID09PSAxMjggfHwgdHlwZSA9PT0gMTI5KSAmJiBtZW1iZXIuc3RhdGljICYmIHZhbHVlID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5TdGF0aWNQcm90b3R5cGUsIHtcbiAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAxMzQpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkNvbnN0cnVjdG9yQ2xhc3NQcml2YXRlRmllbGQsIHtcbiAgICAgICAgICBhdDogdGhpcy5zdGF0ZS5zdGFydExvY1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5ID0gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCk7XG4gICAgICBtZW1iZXIua2V5ID0ga2V5O1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXJzZVByb3BlcnR5TmFtZShtZW1iZXIpO1xuICB9XG5cbiAgcGFyc2VDbGFzc1N0YXRpY0Jsb2NrKGNsYXNzQm9keSwgbWVtYmVyKSB7XG4gICAgdmFyIF9tZW1iZXIkZGVjb3JhdG9ycztcblxuICAgIHRoaXMuc2NvcGUuZW50ZXIoU0NPUEVfQ0xBU1MgfCBTQ09QRV9TVEFUSUNfQkxPQ0sgfCBTQ09QRV9TVVBFUik7XG4gICAgY29uc3Qgb2xkTGFiZWxzID0gdGhpcy5zdGF0ZS5sYWJlbHM7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBbXTtcbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihQQVJBTSk7XG4gICAgY29uc3QgYm9keSA9IG1lbWJlci5ib2R5ID0gW107XG4gICAgdGhpcy5wYXJzZUJsb2NrT3JNb2R1bGVCbG9ja0JvZHkoYm9keSwgdW5kZWZpbmVkLCBmYWxzZSwgOCk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzID0gb2xkTGFiZWxzO1xuICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlciwgXCJTdGF0aWNCbG9ja1wiKSk7XG5cbiAgICBpZiAoKF9tZW1iZXIkZGVjb3JhdG9ycyA9IG1lbWJlci5kZWNvcmF0b3JzKSAhPSBudWxsICYmIF9tZW1iZXIkZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvclN0YXRpY0Jsb2NrLCB7XG4gICAgICAgIGF0OiBtZW1iZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hDbGFzc1Byb3BlcnR5KGNsYXNzQm9keSwgcHJvcCkge1xuICAgIGlmICghcHJvcC5jb21wdXRlZCAmJiAocHJvcC5rZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IHByb3Aua2V5LnZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Db25zdHJ1Y3RvckNsYXNzRmllbGQsIHtcbiAgICAgICAgYXQ6IHByb3Aua2V5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjbGFzc0JvZHkuYm9keS5wdXNoKHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5KHByb3ApKTtcbiAgfVxuXG4gIHB1c2hDbGFzc1ByaXZhdGVQcm9wZXJ0eShjbGFzc0JvZHksIHByb3ApIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5wYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KHByb3ApO1xuICAgIGNsYXNzQm9keS5ib2R5LnB1c2gobm9kZSk7XG4gICAgdGhpcy5jbGFzc1Njb3BlLmRlY2xhcmVQcml2YXRlTmFtZSh0aGlzLmdldFByaXZhdGVOYW1lU1Yobm9kZS5rZXkpLCBDTEFTU19FTEVNRU5UX09USEVSLCBub2RlLmtleS5sb2Muc3RhcnQpO1xuICB9XG5cbiAgcHVzaENsYXNzQWNjZXNzb3JQcm9wZXJ0eShjbGFzc0JvZHksIHByb3AsIGlzUHJpdmF0ZSkge1xuICAgIGlmICghaXNQcml2YXRlICYmICFwcm9wLmNvbXB1dGVkKSB7XG4gICAgICBjb25zdCBrZXkgPSBwcm9wLmtleTtcblxuICAgICAgaWYgKGtleS5uYW1lID09PSBcImNvbnN0cnVjdG9yXCIgfHwga2V5LnZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JDbGFzc0ZpZWxkLCB7XG4gICAgICAgICAgYXQ6IGtleVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gdGhpcy5wYXJzZUNsYXNzQWNjZXNzb3JQcm9wZXJ0eShwcm9wKTtcbiAgICBjbGFzc0JvZHkuYm9keS5wdXNoKG5vZGUpO1xuXG4gICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgdGhpcy5jbGFzc1Njb3BlLmRlY2xhcmVQcml2YXRlTmFtZSh0aGlzLmdldFByaXZhdGVOYW1lU1Yobm9kZS5rZXkpLCBDTEFTU19FTEVNRU5UX09USEVSLCBub2RlLmtleS5sb2Muc3RhcnQpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLnBhcnNlTWV0aG9kKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyLCBcIkNsYXNzTWV0aG9kXCIsIHRydWUpKTtcbiAgfVxuXG4gIHB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyc2VNZXRob2QobWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgZmFsc2UsIGZhbHNlLCBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiLCB0cnVlKTtcbiAgICBjbGFzc0JvZHkuYm9keS5wdXNoKG5vZGUpO1xuICAgIGNvbnN0IGtpbmQgPSBub2RlLmtpbmQgPT09IFwiZ2V0XCIgPyBub2RlLnN0YXRpYyA/IENMQVNTX0VMRU1FTlRfU1RBVElDX0dFVFRFUiA6IENMQVNTX0VMRU1FTlRfSU5TVEFOQ0VfR0VUVEVSIDogbm9kZS5raW5kID09PSBcInNldFwiID8gbm9kZS5zdGF0aWMgPyBDTEFTU19FTEVNRU5UX1NUQVRJQ19TRVRURVIgOiBDTEFTU19FTEVNRU5UX0lOU1RBTkNFX1NFVFRFUiA6IENMQVNTX0VMRU1FTlRfT1RIRVI7XG4gICAgdGhpcy5kZWNsYXJlQ2xhc3NQcml2YXRlTWV0aG9kSW5TY29wZShub2RlLCBraW5kKTtcbiAgfVxuXG4gIGRlY2xhcmVDbGFzc1ByaXZhdGVNZXRob2RJblNjb3BlKG5vZGUsIGtpbmQpIHtcbiAgICB0aGlzLmNsYXNzU2NvcGUuZGVjbGFyZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihub2RlLmtleSksIGtpbmQsIG5vZGUua2V5LmxvYy5zdGFydCk7XG4gIH1cblxuICBwYXJzZVBvc3RNZW1iZXJOYW1lTW9kaWZpZXJzKG1ldGhvZE9yUHJvcCkge31cblxuICBwYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUpIHtcbiAgICB0aGlzLnBhcnNlSW5pdGlhbGl6ZXIobm9kZSk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIik7XG4gIH1cblxuICBwYXJzZUNsYXNzUHJvcGVydHkobm9kZSkge1xuICAgIHRoaXMucGFyc2VJbml0aWFsaXplcihub2RlKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDbGFzc1Byb3BlcnR5XCIpO1xuICB9XG5cbiAgcGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSkge1xuICAgIHRoaXMucGFyc2VJbml0aWFsaXplcihub2RlKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcIik7XG4gIH1cblxuICBwYXJzZUluaXRpYWxpemVyKG5vZGUpIHtcbiAgICB0aGlzLnNjb3BlLmVudGVyKFNDT1BFX0NMQVNTIHwgU0NPUEVfU1VQRVIpO1xuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmVudGVyKG5ld0V4cHJlc3Npb25TY29wZSgpKTtcbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihQQVJBTSk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMuZWF0KDI5KSA/IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKSA6IG51bGw7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgfVxuXG4gIHBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCwgYmluZGluZ1R5cGUgPSBCSU5EX0NMQVNTKSB7XG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuXG4gICAgICBpZiAoaXNTdGF0ZW1lbnQpIHtcbiAgICAgICAgdGhpcy5kZWNsYXJlTmFtZUZyb21JZGVudGlmaWVyKG5vZGUuaWQsIGJpbmRpbmdUeXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbmFsSWQgfHwgIWlzU3RhdGVtZW50KSB7XG4gICAgICAgIG5vZGUuaWQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ0NsYXNzTmFtZSwge1xuICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBhcnNlQ2xhc3NTdXBlcihub2RlKSB7XG4gICAgbm9kZS5zdXBlckNsYXNzID0gdGhpcy5lYXQoODEpID8gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCkgOiBudWxsO1xuICB9XG5cbiAgcGFyc2VFeHBvcnQobm9kZSkge1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSB0aGlzLm1heWJlUGFyc2VFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUpO1xuICAgIGNvbnN0IHBhcnNlQWZ0ZXJEZWZhdWx0ID0gIWhhc0RlZmF1bHQgfHwgdGhpcy5lYXQoMTIpO1xuICAgIGNvbnN0IGhhc1N0YXIgPSBwYXJzZUFmdGVyRGVmYXVsdCAmJiB0aGlzLmVhdEV4cG9ydFN0YXIobm9kZSk7XG4gICAgY29uc3QgaGFzTmFtZXNwYWNlID0gaGFzU3RhciAmJiB0aGlzLm1heWJlUGFyc2VFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSk7XG4gICAgY29uc3QgcGFyc2VBZnRlck5hbWVzcGFjZSA9IHBhcnNlQWZ0ZXJEZWZhdWx0ICYmICghaGFzTmFtZXNwYWNlIHx8IHRoaXMuZWF0KDEyKSk7XG4gICAgY29uc3QgaXNGcm9tUmVxdWlyZWQgPSBoYXNEZWZhdWx0IHx8IGhhc1N0YXI7XG5cbiAgICBpZiAoaGFzU3RhciAmJiAhaGFzTmFtZXNwYWNlKSB7XG4gICAgICBpZiAoaGFzRGVmYXVsdCkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB0aGlzLnBhcnNlRXhwb3J0RnJvbShub2RlLCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNTcGVjaWZpZXJzID0gdGhpcy5tYXliZVBhcnNlRXhwb3J0TmFtZWRTcGVjaWZpZXJzKG5vZGUpO1xuXG4gICAgaWYgKGhhc0RlZmF1bHQgJiYgcGFyc2VBZnRlckRlZmF1bHQgJiYgIWhhc1N0YXIgJiYgIWhhc1NwZWNpZmllcnMgfHwgaGFzTmFtZXNwYWNlICYmIHBhcnNlQWZ0ZXJOYW1lc3BhY2UgJiYgIWhhc1NwZWNpZmllcnMpIHtcbiAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZChudWxsLCA1KTtcbiAgICB9XG5cbiAgICBsZXQgaGFzRGVjbGFyYXRpb247XG5cbiAgICBpZiAoaXNGcm9tUmVxdWlyZWQgfHwgaGFzU3BlY2lmaWVycykge1xuICAgICAgaGFzRGVjbGFyYXRpb24gPSBmYWxzZTtcbiAgICAgIHRoaXMucGFyc2VFeHBvcnRGcm9tKG5vZGUsIGlzRnJvbVJlcXVpcmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzRGVjbGFyYXRpb24gPSB0aGlzLm1heWJlUGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNGcm9tUmVxdWlyZWQgfHwgaGFzU3BlY2lmaWVycyB8fCBoYXNEZWNsYXJhdGlvbikge1xuICAgICAgdGhpcy5jaGVja0V4cG9ydChub2RlLCB0cnVlLCBmYWxzZSwgISFub2RlLnNvdXJjZSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lYXQoNjUpKSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmNoZWNrRXhwb3J0KG5vZGUsIHRydWUsIHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKTtcbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgNSk7XG4gIH1cblxuICBlYXRFeHBvcnRTdGFyKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYXQoNTUpO1xuICB9XG5cbiAgbWF5YmVQYXJzZUV4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSkge1xuICAgIGlmICh0aGlzLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImV4cG9ydERlZmF1bHRGcm9tXCIpO1xuICAgICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHNwZWNpZmllci5leHBvcnRlZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW3RoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiKV07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtYXliZVBhcnNlRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTMpKSB7XG4gICAgICBpZiAoIW5vZGUuc3BlY2lmaWVycykgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0LCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHNwZWNpZmllci5leHBvcnRlZCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtYXliZVBhcnNlRXhwb3J0TmFtZWRTcGVjaWZpZXJzKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg1KSkge1xuICAgICAgaWYgKCFub2RlLnNwZWNpZmllcnMpIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgICAgY29uc3QgaXNUeXBlRXhwb3J0ID0gbm9kZS5leHBvcnRLaW5kID09PSBcInR5cGVcIjtcbiAgICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKC4uLnRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKGlzVHlwZUV4cG9ydCkpO1xuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImltcG9ydEFzc2VydGlvbnNcIikpIHtcbiAgICAgICAgbm9kZS5hc3NlcnRpb25zID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG1heWJlUGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgICBub2RlLmFzc2VydGlvbnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzQXN5bmNGdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDk1KSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgcmV0dXJuICFsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhdGUucG9zLCBuZXh0KSkgJiYgdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcImZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgcGFyc2VFeHBvcnREZWZhdWx0RXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCBleHByID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBpc0FzeW5jID0gdGhpcy5pc0FzeW5jRnVuY3Rpb24oKTtcblxuICAgIGlmICh0aGlzLm1hdGNoKDY4KSB8fCBpc0FzeW5jKSB7XG4gICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24oZXhwciwgRlVOQ19TVEFURU1FTlQgfCBGVU5DX05VTExBQkxFX0lELCBpc0FzeW5jKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCg4MCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3MoZXhwciwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF0Y2goMjYpKSB7XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJkZWNvcmF0b3JzXCIpICYmIHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnNCZWZvcmVFeHBvcnRcIikpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yQmVmb3JlRXhwb3J0LCB7XG4gICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2NcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFyc2VEZWNvcmF0b3JzKGZhbHNlKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3MoZXhwciwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF0Y2goNzUpIHx8IHRoaXMubWF0Y2goNzQpIHx8IHRoaXMuaXNMZXQoKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWREZWZhdWx0RXhwb3J0LCB7XG4gICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgcGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7XG4gIH1cblxuICBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHR5cGUpKSB7XG4gICAgICBpZiAodHlwZSA9PT0gOTUgJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2MgfHwgdHlwZSA9PT0gOTkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHR5cGUgPT09IDEyNiB8fCB0eXBlID09PSAxMjUpICYmICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0eXBlOiBuZXh0VHlwZVxuICAgICAgICB9ID0gdGhpcy5sb29rYWhlYWQoKTtcblxuICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIobmV4dFR5cGUpICYmIG5leHRUeXBlICE9PSA5NyB8fCBuZXh0VHlwZSA9PT0gNSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0T25lUGx1Z2luKFtcImZsb3dcIiwgXCJ0eXBlc2NyaXB0XCJdKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLm1hdGNoKDY1KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgY29uc3QgaGFzRnJvbSA9IHRoaXMuaXNVbnBhcnNlZENvbnRleHR1YWwobmV4dCwgXCJmcm9tXCIpO1xuXG4gICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KSA9PT0gNDQgfHwgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSAmJiBoYXNGcm9tKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXRjaCg2NSkgJiYgaGFzRnJvbSkge1xuICAgICAgY29uc3QgbmV4dEFmdGVyRnJvbSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLm5leHRUb2tlblN0YXJ0U2luY2UobmV4dCArIDQpKTtcbiAgICAgIHJldHVybiBuZXh0QWZ0ZXJGcm9tID09PSAzNCB8fCBuZXh0QWZ0ZXJGcm9tID09PSAzOTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwYXJzZUV4cG9ydEZyb20obm9kZSwgZXhwZWN0KSB7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCg5NykpIHtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUltcG9ydFNvdXJjZSgpO1xuICAgICAgdGhpcy5jaGVja0V4cG9ydChub2RlKTtcbiAgICAgIGNvbnN0IGFzc2VydGlvbnMgPSB0aGlzLm1heWJlUGFyc2VJbXBvcnRBc3NlcnRpb25zKCk7XG5cbiAgICAgIGlmIChhc3NlcnRpb25zKSB7XG4gICAgICAgIG5vZGUuYXNzZXJ0aW9ucyA9IGFzc2VydGlvbnM7XG4gICAgICAgIHRoaXMuY2hlY2tKU09OTW9kdWxlSW1wb3J0KG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhwZWN0KSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG5cbiAgc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBpZiAodHlwZSA9PT0gMjYpIHtcbiAgICAgIHRoaXMuZXhwZWN0T25lUGx1Z2luKFtcImRlY29yYXRvcnNcIiwgXCJkZWNvcmF0b3JzLWxlZ2FjeVwiXSk7XG5cbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnNCZWZvcmVFeHBvcnRcIikpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JCZWZvcmVFeHBvcnQsIHtcbiAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZSA9PT0gNzQgfHwgdHlwZSA9PT0gNzUgfHwgdHlwZSA9PT0gNjggfHwgdHlwZSA9PT0gODAgfHwgdGhpcy5pc0xldCgpIHx8IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCk7XG4gIH1cblxuICBjaGVja0V4cG9ydChub2RlLCBjaGVja05hbWVzLCBpc0RlZmF1bHQsIGlzRnJvbSkge1xuICAgIGlmIChjaGVja05hbWVzKSB7XG4gICAgICBpZiAoaXNEZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKG5vZGUsIFwiZGVmYXVsdFwiKTtcblxuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJleHBvcnREZWZhdWx0RnJvbVwiKSkge1xuICAgICAgICAgIHZhciBfZGVjbGFyYXRpb24kZXh0cmE7XG5cbiAgICAgICAgICBjb25zdCBkZWNsYXJhdGlvbiA9IG5vZGUuZGVjbGFyYXRpb247XG5cbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb24udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgZGVjbGFyYXRpb24ubmFtZSA9PT0gXCJmcm9tXCIgJiYgZGVjbGFyYXRpb24uZW5kIC0gZGVjbGFyYXRpb24uc3RhcnQgPT09IDQgJiYgISgoX2RlY2xhcmF0aW9uJGV4dHJhID0gZGVjbGFyYXRpb24uZXh0cmEpICE9IG51bGwgJiYgX2RlY2xhcmF0aW9uJGV4dHJhLnBhcmVudGhlc2l6ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5FeHBvcnREZWZhdWx0RnJvbUFzSWRlbnRpZmllciwge1xuICAgICAgICAgICAgICBhdDogZGVjbGFyYXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLnNwZWNpZmllcnMgJiYgbm9kZS5zcGVjaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBub2RlLnNwZWNpZmllcnMpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBleHBvcnRlZFxuICAgICAgICAgIH0gPSBzcGVjaWZpZXI7XG4gICAgICAgICAgY29uc3QgZXhwb3J0TmFtZSA9IGV4cG9ydGVkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gZXhwb3J0ZWQubmFtZSA6IGV4cG9ydGVkLnZhbHVlO1xuICAgICAgICAgIHRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKHNwZWNpZmllciwgZXhwb3J0TmFtZSk7XG5cbiAgICAgICAgICBpZiAoIWlzRnJvbSAmJiBzcGVjaWZpZXIubG9jYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgbG9jYWxcbiAgICAgICAgICAgIH0gPSBzcGVjaWZpZXI7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbC50eXBlICE9PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5FeHBvcnRCaW5kaW5nSXNTdHJpbmcsIHtcbiAgICAgICAgICAgICAgICBhdDogc3BlY2lmaWVyLFxuICAgICAgICAgICAgICAgIGxvY2FsTmFtZTogbG9jYWwudmFsdWUsXG4gICAgICAgICAgICAgICAgZXhwb3J0TmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQobG9jYWwubmFtZSwgbG9jYWwubG9jLnN0YXJ0LCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgIHRoaXMuc2NvcGUuY2hlY2tMb2NhbEV4cG9ydChsb2NhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuZGVjbGFyYXRpb24pIHtcbiAgICAgICAgaWYgKG5vZGUuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgfHwgbm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIikge1xuICAgICAgICAgIGNvbnN0IGlkID0gbm9kZS5kZWNsYXJhdGlvbi5pZDtcbiAgICAgICAgICBpZiAoIWlkKSB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gZmFpbHVyZVwiKTtcbiAgICAgICAgICB0aGlzLmNoZWNrRHVwbGljYXRlRXhwb3J0cyhub2RlLCBpZC5uYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBkZWNsYXJhdGlvbiBvZiBub2RlLmRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKGRlY2xhcmF0aW9uLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50Q29udGV4dERlY29yYXRvcnMgPSB0aGlzLnN0YXRlLmRlY29yYXRvclN0YWNrW3RoaXMuc3RhdGUuZGVjb3JhdG9yU3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoY3VycmVudENvbnRleHREZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQsIHtcbiAgICAgICAgYXQ6IG5vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrRGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICB0aGlzLmNoZWNrRHVwbGljYXRlRXhwb3J0cyhub2RlLCBub2RlLm5hbWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIikge1xuICAgICAgZm9yIChjb25zdCBwcm9wIG9mIG5vZGUucHJvcGVydGllcykge1xuICAgICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24ocHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBub2RlLmVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIikge1xuICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKG5vZGUudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLmFyZ3VtZW50KTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24obm9kZS5sZWZ0KTtcbiAgICB9XG4gIH1cblxuICBjaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgZXhwb3J0TmFtZSkge1xuICAgIGlmICh0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnMuaGFzKGV4cG9ydE5hbWUpKSB7XG4gICAgICBpZiAoZXhwb3J0TmFtZSA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlRGVmYXVsdEV4cG9ydCwge1xuICAgICAgICAgIGF0OiBub2RlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlRXhwb3J0LCB7XG4gICAgICAgICAgYXQ6IG5vZGUsXG4gICAgICAgICAgZXhwb3J0TmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnMuYWRkKGV4cG9ydE5hbWUpO1xuICB9XG5cbiAgcGFyc2VFeHBvcnRTcGVjaWZpZXJzKGlzSW5UeXBlRXhwb3J0KSB7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuXG4gICAgd2hpbGUgKCF0aGlzLmVhdCg4KSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIGlmICh0aGlzLmVhdCg4KSkgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzTWF5YmVUeXBlT25seSA9IHRoaXMuaXNDb250ZXh0dWFsKDEyNik7XG4gICAgICBjb25zdCBpc1N0cmluZyA9IHRoaXMubWF0Y2goMTI5KTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICBub2Rlcy5wdXNoKHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXIobm9kZSwgaXNTdHJpbmcsIGlzSW5UeXBlRXhwb3J0LCBpc01heWJlVHlwZU9ubHkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cblxuICBwYXJzZUV4cG9ydFNwZWNpZmllcihub2RlLCBpc1N0cmluZywgaXNJblR5cGVFeHBvcnQsIGlzTWF5YmVUeXBlT25seSkge1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoOTMpKSB7XG4gICAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKSB7XG4gICAgICBub2RlLmV4cG9ydGVkID0gY2xvbmVTdHJpbmdMaXRlcmFsKG5vZGUubG9jYWwpO1xuICAgIH0gZWxzZSBpZiAoIW5vZGUuZXhwb3J0ZWQpIHtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSBjbG9uZUlkZW50aWZpZXIobm9kZS5sb2NhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydFNwZWNpZmllclwiKTtcbiAgfVxuXG4gIHBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxMjkpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIGNvbnN0IHN1cnJvZ2F0ZSA9IHJlc3VsdC52YWx1ZS5tYXRjaChsb25lU3Vycm9nYXRlKTtcblxuICAgICAgaWYgKHN1cnJvZ2F0ZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Nb2R1bGVFeHBvcnROYW1lSGFzTG9uZVN1cnJvZ2F0ZSwge1xuICAgICAgICAgIGF0OiByZXN1bHQsXG4gICAgICAgICAgc3Vycm9nYXRlQ2hhckNvZGU6IHN1cnJvZ2F0ZVswXS5jaGFyQ29kZUF0KDApXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgfVxuXG4gIGlzSlNPTk1vZHVsZUltcG9ydChub2RlKSB7XG4gICAgaWYgKG5vZGUuYXNzZXJ0aW9ucyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gbm9kZS5hc3NlcnRpb25zLnNvbWUoKHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSkgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWUudmFsdWUgPT09IFwianNvblwiICYmIChrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBrZXkubmFtZSA9PT0gXCJ0eXBlXCIgOiBrZXkudmFsdWUgPT09IFwidHlwZVwiKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNoZWNrSlNPTk1vZHVsZUltcG9ydChub2RlKSB7XG4gICAgaWYgKHRoaXMuaXNKU09OTW9kdWxlSW1wb3J0KG5vZGUpICYmIG5vZGUudHlwZSAhPT0gXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNwZWNpZmllcnNcbiAgICAgIH0gPSBub2RlO1xuXG4gICAgICBpZiAobm9kZS5zcGVjaWZpZXJzICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgbm9uRGVmYXVsdE5hbWVkU3BlY2lmaWVyID0gc3BlY2lmaWVycy5maW5kKHNwZWNpZmllciA9PiB7XG4gICAgICAgICAgbGV0IGltcG9ydGVkO1xuXG4gICAgICAgICAgaWYgKHNwZWNpZmllci50eXBlID09PSBcIkV4cG9ydFNwZWNpZmllclwiKSB7XG4gICAgICAgICAgICBpbXBvcnRlZCA9IHNwZWNpZmllci5sb2NhbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNpZmllci50eXBlID09PSBcIkltcG9ydFNwZWNpZmllclwiKSB7XG4gICAgICAgICAgICBpbXBvcnRlZCA9IHNwZWNpZmllci5pbXBvcnRlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW1wb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydGVkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gaW1wb3J0ZWQubmFtZSAhPT0gXCJkZWZhdWx0XCIgOiBpbXBvcnRlZC52YWx1ZSAhPT0gXCJkZWZhdWx0XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobm9uRGVmYXVsdE5hbWVkU3BlY2lmaWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRKU09OQmluZGluZ05vdERlZmF1bHQsIHtcbiAgICAgICAgICAgIGF0OiBub25EZWZhdWx0TmFtZWRTcGVjaWZpZXIubG9jLnN0YXJ0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwYXJzZUltcG9ydChub2RlKSB7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG5cbiAgICBpZiAoIXRoaXMubWF0Y2goMTI5KSkge1xuICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IHRoaXMubWF5YmVQYXJzZURlZmF1bHRJbXBvcnRTcGVjaWZpZXIobm9kZSk7XG4gICAgICBjb25zdCBwYXJzZU5leHQgPSAhaGFzRGVmYXVsdCB8fCB0aGlzLmVhdCgxMik7XG4gICAgICBjb25zdCBoYXNTdGFyID0gcGFyc2VOZXh0ICYmIHRoaXMubWF5YmVQYXJzZVN0YXJJbXBvcnRTcGVjaWZpZXIobm9kZSk7XG4gICAgICBpZiAocGFyc2VOZXh0ICYmICFoYXNTdGFyKSB0aGlzLnBhcnNlTmFtZWRJbXBvcnRTcGVjaWZpZXJzKG5vZGUpO1xuICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDk3KTtcbiAgICB9XG5cbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VJbXBvcnRTb3VyY2UoKTtcbiAgICBjb25zdCBhc3NlcnRpb25zID0gdGhpcy5tYXliZVBhcnNlSW1wb3J0QXNzZXJ0aW9ucygpO1xuXG4gICAgaWYgKGFzc2VydGlvbnMpIHtcbiAgICAgIG5vZGUuYXNzZXJ0aW9ucyA9IGFzc2VydGlvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLm1heWJlUGFyc2VNb2R1bGVBdHRyaWJ1dGVzKCk7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja0pTT05Nb2R1bGVJbXBvcnQobm9kZSk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIik7XG4gIH1cblxuICBwYXJzZUltcG9ydFNvdXJjZSgpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goMTI5KSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICB9XG5cbiAgc2hvdWxkUGFyc2VEZWZhdWx0SW1wb3J0KG5vZGUpIHtcbiAgICByZXR1cm4gdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKTtcbiAgfVxuXG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyTG9jYWwobm9kZSwgc3BlY2lmaWVyLCB0eXBlKSB7XG4gICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaEltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIHR5cGUpKTtcbiAgfVxuXG4gIGZpbmlzaEltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIHR5cGUpIHtcbiAgICB0aGlzLmNoZWNrTFZhbChzcGVjaWZpZXIubG9jYWwsIHtcbiAgICAgIGluOiBzcGVjaWZpZXIsXG4gICAgICBiaW5kaW5nOiBCSU5EX0xFWElDQUxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHNwZWNpZmllciwgdHlwZSk7XG4gIH1cblxuICBwYXJzZUFzc2VydEVudHJpZXMoKSB7XG4gICAgY29uc3QgYXR0cnMgPSBbXTtcbiAgICBjb25zdCBhdHRyTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBkbyB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg4KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBjb25zdCBrZXlOYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcblxuICAgICAgaWYgKGF0dHJOYW1lcy5oYXMoa2V5TmFtZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlQXR0cmlidXRlc1dpdGhEdXBsaWNhdGVLZXlzLCB7XG4gICAgICAgICAgYXQ6IHRoaXMuc3RhdGUuc3RhcnRMb2MsXG4gICAgICAgICAga2V5OiBrZXlOYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBhdHRyTmFtZXMuYWRkKGtleU5hbWUpO1xuXG4gICAgICBpZiAodGhpcy5tYXRjaCgxMjkpKSB7XG4gICAgICAgIG5vZGUua2V5ID0gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwoa2V5TmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmV4cGVjdCgxNCk7XG5cbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMjkpKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLk1vZHVsZUF0dHJpYnV0ZUludmFsaWRWYWx1ZSwge1xuICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBub2RlLnZhbHVlID0gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICBhdHRycy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydEF0dHJpYnV0ZVwiKSk7XG4gICAgfSB3aGlsZSAodGhpcy5lYXQoMTIpKTtcblxuICAgIHJldHVybiBhdHRycztcbiAgfVxuXG4gIG1heWJlUGFyc2VNb2R1bGVBdHRyaWJ1dGVzKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDc2KSAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJtb2R1bGVBdHRyaWJ1dGVzXCIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcIm1vZHVsZUF0dHJpYnV0ZXNcIikpIHJldHVybiBbXTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG5ldyBTZXQoKTtcblxuICAgIGRvIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5rZXkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcblxuICAgICAgaWYgKG5vZGUua2V5Lm5hbWUgIT09IFwidHlwZVwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1vZHVsZUF0dHJpYnV0ZURpZmZlcmVudEZyb21UeXBlLCB7XG4gICAgICAgICAgYXQ6IG5vZGUua2V5XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cmlidXRlcy5oYXMobm9kZS5rZXkubmFtZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlQXR0cmlidXRlc1dpdGhEdXBsaWNhdGVLZXlzLCB7XG4gICAgICAgICAgYXQ6IG5vZGUua2V5LFxuICAgICAgICAgIGtleTogbm9kZS5rZXkubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlcy5hZGQobm9kZS5rZXkubmFtZSk7XG4gICAgICB0aGlzLmV4cGVjdCgxNCk7XG5cbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMjkpKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLk1vZHVsZUF0dHJpYnV0ZUludmFsaWRWYWx1ZSwge1xuICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBub2RlLnZhbHVlID0gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRBdHRyaWJ1dGVcIik7XG4gICAgICBhdHRycy5wdXNoKG5vZGUpO1xuICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG5cbiAgICByZXR1cm4gYXR0cnM7XG4gIH1cblxuICBtYXliZVBhcnNlSW1wb3J0QXNzZXJ0aW9ucygpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTQpICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImltcG9ydEFzc2VydGlvbnNcIik7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkgcmV0dXJuIFtdO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5lYXQoNSk7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLnBhcnNlQXNzZXJ0RW50cmllcygpO1xuICAgIHRoaXMuZWF0KDgpO1xuICAgIHJldHVybiBhdHRycztcbiAgfVxuXG4gIG1heWJlUGFyc2VEZWZhdWx0SW1wb3J0U3BlY2lmaWVyKG5vZGUpIHtcbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZURlZmF1bHRJbXBvcnQobm9kZSkpIHtcbiAgICAgIHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJMb2NhbChub2RlLCB0aGlzLnN0YXJ0Tm9kZSgpLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtYXliZVBhcnNlU3RhckltcG9ydFNwZWNpZmllcihub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNTUpKSB7XG4gICAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoOTMpO1xuICAgICAgdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllckxvY2FsKG5vZGUsIHNwZWNpZmllciwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwYXJzZU5hbWVkSW1wb3J0U3BlY2lmaWVycyhub2RlKSB7XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcblxuICAgIHdoaWxlICghdGhpcy5lYXQoOCkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZWF0KDE0KSkge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLkRlc3RydWN0dXJlTmFtZWRJbXBvcnQsIHtcbiAgICAgICAgICAgIGF0OiB0aGlzLnN0YXRlLnN0YXJ0TG9jXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIGlmICh0aGlzLmVhdCg4KSkgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBjb25zdCBpbXBvcnRlZElzU3RyaW5nID0gdGhpcy5tYXRjaCgxMjkpO1xuICAgICAgY29uc3QgaXNNYXliZVR5cGVPbmx5ID0gdGhpcy5pc0NvbnRleHR1YWwoMTI2KTtcbiAgICAgIHNwZWNpZmllci5pbXBvcnRlZCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICBjb25zdCBpbXBvcnRTcGVjaWZpZXIgPSB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiB8fCBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZW9mXCIsIGlzTWF5YmVUeXBlT25seSk7XG4gICAgICBub2RlLnNwZWNpZmllcnMucHVzaChpbXBvcnRTcGVjaWZpZXIpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgaXNJblR5cGVPbmx5SW1wb3J0LCBpc01heWJlVHlwZU9ubHkpIHtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDkzKSkge1xuICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpbXBvcnRlZFxuICAgICAgfSA9IHNwZWNpZmllcjtcblxuICAgICAgaWYgKGltcG9ydGVkSXNTdHJpbmcpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0QmluZGluZ0lzU3RyaW5nLCB7XG4gICAgICAgICAgYXQ6IHNwZWNpZmllcixcbiAgICAgICAgICBpbXBvcnROYW1lOiBpbXBvcnRlZC52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChpbXBvcnRlZC5uYW1lLCBzcGVjaWZpZXIubG9jLnN0YXJ0LCB0cnVlLCB0cnVlKTtcblxuICAgICAgaWYgKCFzcGVjaWZpZXIubG9jYWwpIHtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gY2xvbmVJZGVudGlmaWVyKGltcG9ydGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBcIkltcG9ydFNwZWNpZmllclwiKTtcbiAgfVxuXG4gIGlzVGhpc1BhcmFtKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHBhcmFtLm5hbWUgPT09IFwidGhpc1wiO1xuICB9XG5cbn1cblxuY2xhc3MgUGFyc2VyIGV4dGVuZHMgU3RhdGVtZW50UGFyc2VyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaW5wdXQpIHtcbiAgICBvcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICBzdXBlcihvcHRpb25zLCBpbnB1dCk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmluaXRpYWxpemVTY29wZXMoKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBwbHVnaW5zTWFwKHRoaXMub3B0aW9ucy5wbHVnaW5zKTtcbiAgICB0aGlzLmZpbGVuYW1lID0gb3B0aW9ucy5zb3VyY2VGaWxlbmFtZTtcbiAgfVxuXG4gIGdldFNjb3BlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gU2NvcGVIYW5kbGVyO1xuICB9XG5cbiAgcGFyc2UoKSB7XG4gICAgdGhpcy5lbnRlckluaXRpYWxTY29wZXMoKTtcbiAgICBjb25zdCBmaWxlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIGZpbGUuZXJyb3JzID0gbnVsbDtcbiAgICB0aGlzLnBhcnNlVG9wTGV2ZWwoZmlsZSwgcHJvZ3JhbSk7XG4gICAgZmlsZS5lcnJvcnMgPSB0aGlzLnN0YXRlLmVycm9ycztcbiAgICByZXR1cm4gZmlsZTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHBsdWdpbnNNYXAocGx1Z2lucykge1xuICBjb25zdCBwbHVnaW5NYXAgPSBuZXcgTWFwKCk7XG5cbiAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgIGNvbnN0IFtuYW1lLCBvcHRpb25zXSA9IEFycmF5LmlzQXJyYXkocGx1Z2luKSA/IHBsdWdpbiA6IFtwbHVnaW4sIHt9XTtcbiAgICBpZiAoIXBsdWdpbk1hcC5oYXMobmFtZSkpIHBsdWdpbk1hcC5zZXQobmFtZSwgb3B0aW9ucyB8fCB7fSk7XG4gIH1cblxuICByZXR1cm4gcGx1Z2luTWFwO1xufVxuXG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnM7XG5cbiAgaWYgKCgoX29wdGlvbnMgPSBvcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX29wdGlvbnMuc291cmNlVHlwZSkgPT09IFwidW5hbWJpZ3VvdXNcIikge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAgIHRyeSB7XG4gICAgICBvcHRpb25zLnNvdXJjZVR5cGUgPSBcIm1vZHVsZVwiO1xuICAgICAgY29uc3QgcGFyc2VyID0gZ2V0UGFyc2VyKG9wdGlvbnMsIGlucHV0KTtcbiAgICAgIGNvbnN0IGFzdCA9IHBhcnNlci5wYXJzZSgpO1xuXG4gICAgICBpZiAocGFyc2VyLnNhd1VuYW1iaWd1b3VzRVNNKSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJzZXIuYW1iaWd1b3VzU2NyaXB0RGlmZmVyZW50QXN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3B0aW9ucy5zb3VyY2VUeXBlID0gXCJzY3JpcHRcIjtcbiAgICAgICAgICByZXR1cm4gZ2V0UGFyc2VyKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpO1xuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXN0LnByb2dyYW0uc291cmNlVHlwZSA9IFwic2NyaXB0XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhc3Q7XG4gICAgfSBjYXRjaCAobW9kdWxlRXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9wdGlvbnMuc291cmNlVHlwZSA9IFwic2NyaXB0XCI7XG4gICAgICAgIHJldHVybiBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpLnBhcnNlKCk7XG4gICAgICB9IGNhdGNoIChfdW51c2VkMikge31cblxuICAgICAgdGhyb3cgbW9kdWxlRXJyb3I7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpLnBhcnNlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBwYXJzZXIgPSBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpO1xuXG4gIGlmIChwYXJzZXIub3B0aW9ucy5zdHJpY3RNb2RlKSB7XG4gICAgcGFyc2VyLnN0YXRlLnN0cmljdCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcGFyc2VyLmdldEV4cHJlc3Npb24oKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVFeHBvcnRlZFRva2VuVHlwZXMoaW50ZXJuYWxUb2tlblR5cGVzKSB7XG4gIGNvbnN0IHRva2VuVHlwZXMgPSB7fTtcblxuICBmb3IgKGNvbnN0IHR5cGVOYW1lIG9mIE9iamVjdC5rZXlzKGludGVybmFsVG9rZW5UeXBlcykpIHtcbiAgICB0b2tlblR5cGVzW3R5cGVOYW1lXSA9IGdldEV4cG9ydGVkVG9rZW4oaW50ZXJuYWxUb2tlblR5cGVzW3R5cGVOYW1lXSk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5UeXBlcztcbn1cblxuY29uc3QgdG9rVHlwZXMgPSBnZW5lcmF0ZUV4cG9ydGVkVG9rZW5UeXBlcyh0dCk7XG5cbmZ1bmN0aW9uIGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCkge1xuICBsZXQgY2xzID0gUGFyc2VyO1xuXG4gIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5wbHVnaW5zKSB7XG4gICAgdmFsaWRhdGVQbHVnaW5zKG9wdGlvbnMucGx1Z2lucyk7XG4gICAgY2xzID0gZ2V0UGFyc2VyQ2xhc3Mob3B0aW9ucy5wbHVnaW5zKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgY2xzKG9wdGlvbnMsIGlucHV0KTtcbn1cblxuY29uc3QgcGFyc2VyQ2xhc3NDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBnZXRQYXJzZXJDbGFzcyhwbHVnaW5zRnJvbU9wdGlvbnMpIHtcbiAgY29uc3QgcGx1Z2luTGlzdCA9IG1peGluUGx1Z2luTmFtZXMuZmlsdGVyKG5hbWUgPT4gaGFzUGx1Z2luKHBsdWdpbnNGcm9tT3B0aW9ucywgbmFtZSkpO1xuICBjb25zdCBrZXkgPSBwbHVnaW5MaXN0LmpvaW4oXCIvXCIpO1xuICBsZXQgY2xzID0gcGFyc2VyQ2xhc3NDYWNoZVtrZXldO1xuXG4gIGlmICghY2xzKSB7XG4gICAgY2xzID0gUGFyc2VyO1xuXG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2luTGlzdCkge1xuICAgICAgY2xzID0gbWl4aW5QbHVnaW5zW3BsdWdpbl0oY2xzKTtcbiAgICB9XG5cbiAgICBwYXJzZXJDbGFzc0NhY2hlW2tleV0gPSBjbHM7XG4gIH1cblxuICByZXR1cm4gY2xzO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnBhcnNlRXhwcmVzc2lvbiA9IHBhcnNlRXhwcmVzc2lvbjtcbmV4cG9ydHMudG9rVHlwZXMgPSB0b2tUeXBlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/parser/lib/index.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});